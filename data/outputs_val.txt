s . clear ( ) ;%NWL%test . equal ( s . size ( ) , 0 ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . empty ( ) returns true only if the set is empty " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . equal ( s . empty ( ) , true ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%9
test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . empty ( ) returns true only if the set is empty " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . equal ( s . empty ( ) , true ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%7
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . empty ( ) returns true only if the set is empty " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . equal ( s . empty ( ) , true ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . add ( " bar " ) ;%NWL%s . remove ( " foo " ) ;%NWL%5
} ) ;%NWL%tape ( " set . empty ( ) returns true only if the set is empty " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . equal ( s . empty ( ) , true ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . add ( " bar " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%5
tape ( " set . empty ( ) returns true only if the set is empty " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . equal ( s . empty ( ) , true ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . add ( " bar " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . remove ( " foo " ) ;%NWL%s . remove ( " foo " ) ;%NWL%3
var s = d3 . set ( ) ;%NWL%test . equal ( s . empty ( ) , true ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . add ( " bar " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%3
test . equal ( s . empty ( ) , true ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . add ( " bar " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . equal ( s . empty ( ) , false ) ;%NWL%s . remove ( " foo " ) ;%NWL%s . remove ( " bar " ) ;%NWL%5
test . equal ( s . empty ( ) , false ) ;%NWL%s . remove ( " bar " ) ;%NWL%test . equal ( s . empty ( ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . each ( callback ) passes value , value and the set " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ,%NWL%c = [ ] ;%NWL%s . each ( function ( v0 , v1 , s )  { c . push ( [ v0 , v1 , s ] ) ; } ) ;%NWL%c . sort ( ) ;%NWL%test . end ( ) ;%NWL%3
c . sort ( ) ;%NWL%test . deepEqual ( c ,  [ [ " bar " ,  " bar " , s ] ,  [ " foo " ,  " foo " , s ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . each ( callback ) uses the global context " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ,%NWL%c = [ ] ;%NWL%s . each ( function ( )  { c . push ( this ) ; } ) ;%NWL%test . strictEqual ( c [ 0 ] , global ) ;%NWL%test . strictEqual ( c [ 1 ] , global ) ;%NWL%test . end ( ) ;%NWL%2
c2 = [ ] ;%NWL%s1 . each ( function ( v )  { c1 . push ( v ) ; } ) ;%NWL%s2 . each ( function ( v )  { c2 . push ( v ) ; } ) ;%NWL%c1 . sort ( ) ;%NWL%c2 . sort ( ) ;%NWL%test . deepEqual ( c1 , c2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) returns an array of string values " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . end ( ) ;%NWL%6
} ) ;%NWL%tape ( " set . values ( ) returns an array of string values " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( ) ,  [ " bar " ,  " foo " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) empty sets have an empty values array " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%s . add ( " foo " ) ;%NWL%s . remove ( " foo " ) ;%NWL%9
tape ( " set . values ( ) returns an array of string values " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( ) ,  [ " bar " ,  " foo " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) empty sets have an empty values array " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%s . add ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " foo " ] ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%7
var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( ) ,  [ " bar " ,  " foo " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) empty sets have an empty values array " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%s . add ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%s . add ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) values are returned in arbitrary order " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%9
s . add ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) values are returned in arbitrary order " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%var s = d3 . set ( [ " bar " ,  " foo " ] ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " set . values ( ) values are returned in arbitrary order " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%var s = d3 . set ( [ " bar " ,  " foo " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) properly unescapes prefixed keys " , function ( test )  {%NWL%var s = d3 . set ( [ " __proto__ " ,  " $weird " ] ) ;%NWL%test . end ( ) ;%NWL%6
var s = d3 . set ( [ " bar " ,  " foo " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) properly unescapes prefixed keys " , function ( test )  {%NWL%var s = d3 . set ( [ " __proto__ " ,  " $weird " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " $weird " ,  " __proto__ " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) observes changes via add and remove " , function ( test )  {%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%1
tape ( " set . values ( ) properly unescapes prefixed keys " , function ( test )  {%NWL%var s = d3 . set ( [ " __proto__ " ,  " $weird " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " $weird " ,  " __proto__ " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) observes changes via add and remove " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%9
var s = d3 . set ( [ " __proto__ " ,  " $weird " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " $weird " ,  " __proto__ " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) observes changes via add and remove " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%s . add ( " bar " ) ;%NWL%s . add ( " foo " ) ;%NWL%7
test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " $weird " ,  " __proto__ " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) observes changes via add and remove " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%s . add ( " bar " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . values ( ) observes changes via add and remove " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%s . add ( " bar " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%s . add ( " foo " ) ;%NWL%s . remove ( " bar " ) ;%NWL%7
tape ( " set . values ( ) observes changes via add and remove " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%s . add ( " bar " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%s . add ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%s . remove ( " bar " ) ;%NWL%s . remove ( " foo " ) ;%NWL%3
test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%s . add ( " bar " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%s . add ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%s . remove ( " bar " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%s . remove ( " foo " ) ;%NWL%1
s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%s . add ( " bar " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " bar " ] ) ;%NWL%s . add ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( d3 . ascending ) ,  [ " bar " ,  " foo " ] ) ;%NWL%s . remove ( " bar " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%9
test . deepEqual ( s . values ( ) ,  [ " foo " ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . deepEqual ( s . values ( ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . has ( value ) empty sets do not have object built - ins " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . equal ( s . has ( " __proto__ " ) , false ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " set . has ( value ) empty sets do not have object built - ins " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . equal ( s . has ( " __proto__ " ) , false ) ;%NWL%test . equal ( s . has ( " hasOwnProperty " ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . has ( value ) coerces values to strings " , function ( test )  {%NWL%var s = d3 . set ( [ " 42 " ,  " null " ,  " undefined " ] ) ;%NWL%test . equal ( s . has ( 42 ) , true ) ;%NWL%test . equal ( s . has ( null ) , true ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " set . has ( value ) coerces values to strings " , function ( test )  {%NWL%var s = d3 . set ( [ " 42 " ,  " null " ,  " undefined " ] ) ;%NWL%test . equal ( s . has ( 42 ) , true ) ;%NWL%test . equal ( s . has ( null ) , true ) ;%NWL%test . equal ( s . has ( undefined ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . has ( value ) observes changes via add and remove " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ] ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%9
var s = d3 . set ( [ " 42 " ,  " null " ,  " undefined " ] ) ;%NWL%test . equal ( s . has ( 42 ) , true ) ;%NWL%test . equal ( s . has ( null ) , true ) ;%NWL%test . equal ( s . has ( undefined ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . has ( value ) observes changes via add and remove " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ] ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%s . add ( " foo " ) ;%NWL%s . remove ( " foo " ) ;%NWL%9
test . equal ( s . has ( null ) , true ) ;%NWL%test . equal ( s . has ( undefined ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . has ( value ) observes changes via add and remove " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ] ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%s . remove ( " foo " ) ;%NWL%s . add ( " foo " ) ;%NWL%7
test . equal ( s . has ( undefined ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . has ( value ) observes changes via add and remove " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ] ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . equal ( s . has ( " foo " ) , false ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . has ( value ) observes changes via add and remove " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ] ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . equal ( s . has ( " foo " ) , false ) ;%NWL%s . add ( " foo " ) ;%NWL%test . end ( ) ;%NWL%0
s . add ( " foo " ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%s . remove ( " foo " ) ;%NWL%test . equal ( s . has ( " foo " ) , false ) ;%NWL%s . add ( " foo " ) ;%NWL%test . equal ( s . has ( " foo " ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . has ( value ) returns undefined for missing values " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ] ) ;%NWL%test . end ( ) ;%NWL%6
} ) ;%NWL%tape ( " set . has ( value ) returns undefined for missing values " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ] ) ;%NWL%test . equal ( s . has ( " bar " ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . add ( value ) returns the set " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . equal ( s . add ( " foo " ) , s ) ;%NWL%test . equal ( s . add ( 2 ) , s ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " set . add ( value ) returns the set " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . equal ( s . add ( " foo " ) , s ) ;%NWL%test . equal ( s . add ( 2 ) , s ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( ) ,  [ " 2 " ,  " foo " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . add ( value ) can add values using built - in names " , function ( test )  {%NWL%var s = d3 . set ( ) . add ( " __proto__ " ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( s . values ( ) . sort ( ) ,  [ " 2 " ,  " foo " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . add ( value ) can add values using built - in names " , function ( test )  {%NWL%var s = d3 . set ( ) . add ( " __proto__ " ) ;%NWL%test . equal ( s . has ( " __proto__ " ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . add ( value ) can add values using zero - prefixed names " , function ( test )  {%NWL%var s = d3 . set ( ) . add ( " $weird " ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . add ( value ) coerces values to strings " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%s . add ( 42 ) ;%NWL%test . equal ( s . has ( 42 ) , true ) ;%NWL%s . add ( null ) ;%NWL%test . equal ( s . has ( null ) , true ) ;%NWL%s . add ( undefined ) ;%NWL%test . equal ( s . has ( undefined ) , true ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( s . has ( null ) , true ) ;%NWL%s . add ( undefined ) ;%NWL%test . equal ( s . has ( undefined ) , true ) ;%NWL%test . deepEqual ( s . values ( ) . sort ( ) ,  [ " 42 " ,  " null " ,  " undefined " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . add ( value ) can add null , undefined or empty string values " , function ( test )  {%NWL%var s = d3 . set ( ) . add ( " " ) . add ( " null " ) . add ( " undefined " ) ;%NWL%test . equal ( s . has ( " " ) , true ) ;%NWL%test . equal ( s . has ( " null " ) , true ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " set . add ( value ) can add null , undefined or empty string values " , function ( test )  {%NWL%var s = d3 . set ( ) . add ( " " ) . add ( " null " ) . add ( " undefined " ) ;%NWL%test . equal ( s . has ( " " ) , true ) ;%NWL%test . equal ( s . has ( " null " ) , true ) ;%NWL%test . equal ( s . has ( " undefined " ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . remove ( value ) returns true if the value was removed " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ] ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( s . has ( " undefined " ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . remove ( value ) returns true if the value was removed " , function ( test )  {%NWL%var s = d3 . set ( [ " foo " ] ) ;%NWL%test . equal ( s . remove ( " foo " ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " set . remove ( value ) returns false if the value is not an element " , function ( test )  {%NWL%var s = d3 . set ( ) ;%NWL%test . end ( ) ;%NWL%1
tape ( " values ( object ) enumerates every value " , function ( test )  {%NWL%test . deepEqual ( d3 . values ( { a: 1 , b: 2 } ) . sort ( d3 . ascending ) ,  [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " values ( object ) includes values defined on prototypes " , function ( test )  {%NWL%function abc ( )  {%NWL%this . a = 1;%NWL%this . b = 2;%NWL%}%NWL%abc . prototype . c = 3;%NWL%test . end ( ) ;%NWL%2
}%NWL%abc . prototype . c = 3;%NWL%test . deepEqual ( d3 . values ( new abc ) . sort ( d3 . ascending ) ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " values ( object ) includes null , undefined and NaN values " , function ( test )  {%NWL%var v = d3 . values ( { a: null , b: undefined , c: NaN } ) . map ( box ) . sort ( order ) . map ( unbox ) ;%NWL%test . equal ( v . length , 3 ) ;%NWL%test . equal ( v [ 0 ] , null ) ;%NWL%test . equal ( v [ 1 ] , undefined ) ;%NWL%test . end ( ) ;%NWL%3
var tape = require ( " tape " ) ,%NWL%color = require ( " . . / " ) ;%NWL%require ( " . / rgbEqual " ) ;%NWL%require ( " . / hslEqual " ) ;%NWL%tape ( " color ( format ) parses CSS color names ( e . g . , \ " rebeccapurple\ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " moccasin " ) , 255 , 228 , 181 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " aliceblue " ) , 240 , 248 , 255 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " moccasin " ) , 255 , 228 , 181 , 1 ) ;%NWL%5
var tape = require ( " tape " ) ,%NWL%color = require ( " . . / " ) ;%NWL%require ( " . / rgbEqual " ) ;%NWL%require ( " . / hslEqual " ) ;%NWL%tape ( " color ( format ) parses CSS color names ( e . g . , \ " rebeccapurple\ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " moccasin " ) , 255 , 228 , 181 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " aliceblue " ) , 240 , 248 , 255 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " yellow " ) , 255 , 255 , 0 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " aliceblue " ) , 240 , 248 , 255 , 1 ) ;%NWL%6
var tape = require ( " tape " ) ,%NWL%color = require ( " . . / " ) ;%NWL%require ( " . / rgbEqual " ) ;%NWL%require ( " . / hslEqual " ) ;%NWL%tape ( " color ( format ) parses CSS color names ( e . g . , \ " rebeccapurple\ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " moccasin " ) , 255 , 228 , 181 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " aliceblue " ) , 240 , 248 , 255 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " yellow " ) , 255 , 255 , 0 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " moccasin " ) , 255 , 228 , 181 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " yellow " ) , 255 , 255 , 0 , 1 ) ;%NWL%7
test . rgbEqual ( color . color ( " aliceblue " ) , 240 , 248 , 255 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " yellow " ) , 255 , 255 , 0 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " moccasin " ) , 255 , 228 , 181 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " aliceblue " ) , 240 , 248 , 255 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " yellow " ) , 255 , 255 , 0 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " rebeccapurple " ) , 102 , 51 , 153 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " transparent " ) , NaN , NaN , NaN , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses 6 - digit hexadecimal ( e . g . , \ " #abcdef\ " ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . rgbEqual ( color . color ( " yellow " ) , 255 , 255 , 0 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " rebeccapurple " ) , 102 , 51 , 153 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " transparent " ) , NaN , NaN , NaN , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses 6 - digit hexadecimal ( e . g . , \ " #abcdef\ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " #abcdef " ) , 171 , 205 , 239 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses 3 - digit hexadecimal ( e . g . , \ " #abc\ " ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " color ( format ) parses 6 - digit hexadecimal ( e . g . , \ " #abcdef\ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " #abcdef " ) , 171 , 205 , 239 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses 3 - digit hexadecimal ( e . g . , \ " #abc\ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " #abc " ) , 170 , 187 , 204 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses RGB integer format ( e . g . , \ " rgb ( 12 , 34 , 56 ) \ " ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " color ( format ) parses 3 - digit hexadecimal ( e . g . , \ " #abc\ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " #abc " ) , 170 , 187 , 204 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses RGB integer format ( e . g . , \ " rgb ( 12 , 34 , 56 ) \ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " rgb ( 12 , 34 , 56 ) " ) , 12 , 34 , 56 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses RGBA integer format ( e . g . , \ " rgba ( 12 , 34 , 56 , 0 . 4 ) \ " ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " color ( format ) parses RGB integer format ( e . g . , \ " rgb ( 12 , 34 , 56 ) \ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " rgb ( 12 , 34 , 56 ) " ) , 12 , 34 , 56 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses RGBA integer format ( e . g . , \ " rgba ( 12 , 34 , 56 , 0 . 4 ) \ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " rgba ( 12 , 34 , 56 , 0 . 4 ) " ) , 12 , 34 , 56 , 0 . 4 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses RGB percentage format ( e . g . , \ " rgb ( 12% , 34% , 56% ) \ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " rgb ( 12% , 34% , 56% ) " ) , 31 , 87 , 143 , 1 ) ;%NWL%test . end ( ) ;%NWL%2
test . rgbEqual ( color . color ( " rgba ( 12 , 34 , 56 , 0 . 4 ) " ) , 12 , 34 , 56 , 0 . 4 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses RGB percentage format ( e . g . , \ " rgb ( 12% , 34% , 56% ) \ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " rgb ( 12% , 34% , 56% ) " ) , 31 , 87 , 143 , 1 ) ;%NWL%test . rgbStrictEqual ( color . color ( " rgb ( 100% , 100% , 100% ) " ) , 255 , 255 , 255 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses RGBA percentage format ( e . g . , \ " rgba ( 12% , 34% , 56% , 0 . 4 ) \ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " rgba ( 12% , 34% , 56% , 0 . 4 ) " ) , 31 , 87 , 143 , 0 . 4 ) ;%NWL%test . end ( ) ;%NWL%1
test . rgbEqual ( color . color ( " rgb ( 12% , 34% , 56% ) " ) , 31 , 87 , 143 , 1 ) ;%NWL%test . rgbStrictEqual ( color . color ( " rgb ( 100% , 100% , 100% ) " ) , 255 , 255 , 255 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses RGBA percentage format ( e . g . , \ " rgba ( 12% , 34% , 56% , 0 . 4 ) \ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " rgba ( 12% , 34% , 56% , 0 . 4 ) " ) , 31 , 87 , 143 , 0 . 4 ) ;%NWL%test . rgbStrictEqual ( color . color ( " rgba ( 100% , 100% , 100% , 0 . 4 ) " ) , 255 , 255 , 255 , 0 . 4 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses HSL format ( e . g . , \ " hsl ( 60 , 100% , 20% ) \ " ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " color ( format ) parses RGBA percentage format ( e . g . , \ " rgba ( 12% , 34% , 56% , 0 . 4 ) \ " ) " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " rgba ( 12% , 34% , 56% , 0 . 4 ) " ) , 31 , 87 , 143 , 0 . 4 ) ;%NWL%test . rgbStrictEqual ( color . color ( " rgba ( 100% , 100% , 100% , 0 . 4 ) " ) , 255 , 255 , 255 , 0 . 4 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses HSL format ( e . g . , \ " hsl ( 60 , 100% , 20% ) \ " ) " , function ( test )  {%NWL%test . hslEqual ( color . color ( " hsl ( 60 , 100% , 20% ) " ) , 60 , 1 , 0 . 2 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) parses HSLA format ( e . g . , \ " hsla ( 60 , 100% , 20% , 0 . 4 ) \ " ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " color ( format ) parses HSLA format ( e . g . , \ " hsla ( 60 , 100% , 20% , 0 . 4 ) \ " ) " , function ( test )  {%NWL%test . hslEqual ( color . color ( " hsla ( 60 , 100% , 20% , 0 . 4 ) " ) , 60 , 1 , 0 . 2 , 0 . 4 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) ignores leading and trailing whitespace " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " aliceblue\t\n " ) , 240 , 248 , 255 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " #abc\t\n " ) , 170 , 187 , 204 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " #aabbcc\t\n " ) , 170 , 187 , 204 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " rgb ( 120 , 30 , 50 ) \t\n " ) , 120 , 30 , 50 , 1 ) ;%NWL%test . end ( ) ;%NWL%3
test . rgbEqual ( color . color ( " #aabbcc\t\n " ) , 170 , 187 , 204 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " rgb ( 120 , 30 , 50 ) \t\n " ) , 120 , 30 , 50 , 1 ) ;%NWL%test . hslEqual ( color . color ( " hsl ( 120 , 30% , 50% ) \t\n " ) , 120 , 0 . 3 , 0 . 5 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) ignores whitespace between numbers " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " rgb ( 120 , 30 , 50 )  " ) , 120 , 30 , 50 , 1 ) ;%NWL%test . hslEqual ( color . color ( " hsl ( 120 , 30% , 50% )  " ) , 120 , 0 . 3 , 0 . 5 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " rgba ( 12 , 34 , 56 , 0 . 4 )  " ) , 12 , 34 , 56 , 0 . 4 ) ;%NWL%test . rgbEqual ( color . color ( " rgba ( 12% , 34% , 56% , 0 . 4 )  " ) , 31 , 87 , 143 , 0 . 4 ) ;%NWL%test . end ( ) ;%NWL%3
test . rgbEqual ( color . color ( " rgba ( 12 , 34 , 56 , + 0 . 4 ) " ) , 12 , 34 , 56 , 0 . 4 ) ;%NWL%test . rgbEqual ( color . color ( " rgba ( 12 , 34 , 56 , - 0 . 4 ) " ) , NaN , NaN , NaN ,  - 0 . 4 ) ;%NWL%test . rgbEqual ( color . color ( " rgba ( 12% , 34% , 56% , + 0 . 4 ) " ) , 31 , 87 , 143 , 0 . 4 ) ;%NWL%test . rgbEqual ( color . color ( " rgba ( 12% , 34% , 56% , - 0 . 4 ) " ) , NaN , NaN , NaN ,  - 0 . 4 ) ;%NWL%test . hslEqual ( color . color ( " hsla ( 60 , 100% , 20% , + 0 . 4 ) " ) , 60 , 1 , 0 . 2 , 0 . 4 ) ;%NWL%test . hslEqual ( color . color ( " hsla ( 60 , 100% , 20% , - 0 . 4 ) " ) , NaN , NaN , NaN ,  - 0 . 4 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) allows decimals for non - integer values " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " rgb ( 20 . 0% , 30 . 4% , 51 . 2% ) " ) , 51 , 78 , 131 , 1 ) ;%NWL%test . end ( ) ;%NWL%6
} ) ;%NWL%tape ( " color ( format ) allows decimals for non - integer values " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " rgb ( 20 . 0% , 30 . 4% , 51 . 2% ) " ) , 51 , 78 , 131 , 1 ) ;%NWL%test . hslEqual ( color . color ( " hsl ( 20 . 0 , 30 . 4% , 51 . 2% ) " ) , 20 , 0 . 304 , 0 . 512 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) allows leading decimal for hue , opacity and percentages " , function ( test )  {%NWL%test . hslEqual ( color . color ( " hsl ( . 9 , . 3% , . 5% ) " ) , 0 . 9 , 0 . 003 , 0 . 005 , 1 ) ;%NWL%test . hslEqual ( color . color ( " hsla ( . 9 , . 3% , . 5% , . 5 ) " ) , 0 . 9 , 0 . 003 , 0 . 005 , 0 . 5 ) ;%NWL%test . rgbEqual ( color . color ( " rgb ( . 1% , . 2% , . 3% ) " ) , 0 , 1 , 1 , 1 ) ;%NWL%test . end ( ) ;%NWL%4
test . hslEqual ( color . color ( " hsl ( . 9 , . 3% , . 5% ) " ) , 0 . 9 , 0 . 003 , 0 . 005 , 1 ) ;%NWL%test . hslEqual ( color . color ( " hsla ( . 9 , . 3% , . 5% , . 5 ) " ) , 0 . 9 , 0 . 003 , 0 . 005 , 0 . 5 ) ;%NWL%test . rgbEqual ( color . color ( " rgb ( . 1% , . 2% , . 3% ) " ) , 0 , 1 , 1 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " rgba ( 120 , 30 , 50 , . 5 ) " ) , 120 , 30 , 50 , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) allows exponential format for hue , opacity and percentages " , function ( test )  {%NWL%test . hslEqual ( color . color ( " hsl ( 1e1 , 2e1% , 3e1% ) " ) , 10 , 0 . 2 , 0 . 3 , 1 ) ;%NWL%test . hslEqual ( color . color ( " hsla ( 9e - 1 , 3e - 1% , 5e - 1% , 5e - 1 ) " ) , 0 . 9 , 0 . 003 , 0 . 005 , 0 . 5 ) ;%NWL%test . rgbEqual ( color . color ( " rgb ( 1e - 1% , 2e - 1% , 3e - 1% ) " ) , 0 , 1 , 1 , 1 ) ;%NWL%test . end ( ) ;%NWL%4
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) allows exponential format for hue , opacity and percentages " , function ( test )  {%NWL%test . hslEqual ( color . color ( " hsl ( 1e1 , 2e1% , 3e1% ) " ) , 10 , 0 . 2 , 0 . 3 , 1 ) ;%NWL%test . hslEqual ( color . color ( " hsla ( 9e - 1 , 3e - 1% , 5e - 1% , 5e - 1 ) " ) , 0 . 9 , 0 . 003 , 0 . 005 , 0 . 5 ) ;%NWL%test . rgbEqual ( color . color ( " rgb ( 1e - 1% , 2e - 1% , 3e - 1% ) " ) , 0 , 1 , 1 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " rgba ( 120 , 30 , 50 , 1e - 1 ) " ) , 120 , 30 , 50 , 0 . 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) does not allow decimals for integer values " , function ( test )  {%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " color ( format ) does not allow decimals for integer values " , function ( test )  {%NWL%test . equal ( color . color ( " rgb ( 120 . 5 , 30 , 50 ) " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) does not allow empty decimals " , function ( test )  {%NWL%test . equal ( color . color ( " rgb ( 120 . , 30 , 50 ) " ) , null ) ;%NWL%test . equal ( color . color ( " rgb ( 120 . % , 30% , 50% ) " ) , null ) ;%NWL%test . equal ( color . color ( " rgba ( 120 , 30 , 50 , 1 . ) " ) , null ) ;%NWL%test . equal ( color . color ( " rgba ( 12% , 30% , 50% , 1 . ) " ) , null ) ;%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " color ( format ) does not allow empty decimals " , function ( test )  {%NWL%test . equal ( color . color ( " rgb ( 120 . , 30 , 50 ) " ) , null ) ;%NWL%test . equal ( color . color ( " rgb ( 120 . % , 30% , 50% ) " ) , null ) ;%NWL%test . equal ( color . color ( " rgba ( 120 , 30 , 50 , 1 . ) " ) , null ) ;%NWL%test . equal ( color . color ( " rgba ( 12% , 30% , 50% , 1 . ) " ) , null ) ;%NWL%test . equal ( color . color ( " hsla ( 60 , 100% , 20% , 1 . ) " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) does not allow made - up names " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . equal ( color . color ( " bostock " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) does not allow whitespace before open paren or percent sign " , function ( test )  {%NWL%test . equal ( color . color ( " rgb ( 120 , 30 , 50 ) " ) , null ) ;%NWL%test . equal ( color . color ( " rgb ( 12% , 30% , 50% ) " ) , null ) ;%NWL%test . equal ( color . color ( " hsl ( 120 , 30% , 50% ) " ) , null ) ;%NWL%test . equal ( color . color ( " hsl ( 120 , 30 % , 50% ) " ) , null ) ;%NWL%test . equal ( color . color ( " rgba ( 120 , 30 , 50 , 1 ) " ) , null ) ;%NWL%test . equal ( color . color ( " rgba ( 12% , 30% , 50% , 1 ) " ) , null ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( color . color ( " rgba ( 12% , 30% , 50% , 1 ) " ) , null ) ;%NWL%test . equal ( color . color ( " hsla ( 120 , 30% , 50% , 1 ) " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) is case - insensitive " , function ( test )  {%NWL%test . rgbEqual ( color . color ( " aLiCeBlUE " ) , 240 , 248 , 255 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " transPARENT " ) , NaN , NaN , NaN , 0 ) ;%NWL%test . rgbEqual ( color . color ( " #aBc\t\n " ) , 170 , 187 , 204 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " #aaBBCC\t\n " ) , 170 , 187 , 204 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " rGB ( 120 , 30 , 50 ) \t\n " ) , 120 , 30 , 50 , 1 ) ;%NWL%test . end ( ) ;%NWL%2
test . rgbEqual ( color . color ( " #aaBBCC\t\n " ) , 170 , 187 , 204 , 1 ) ;%NWL%test . rgbEqual ( color . color ( " rGB ( 120 , 30 , 50 ) \t\n " ) , 120 , 30 , 50 , 1 ) ;%NWL%test . hslEqual ( color . color ( " HSl ( 120 , 30% , 50% ) \t\n " ) , 120 , 0 . 3 , 0 . 5 , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " color ( format ) returns undefined RGB channel values for unknown formats " , function ( test )  {%NWL%test . equal ( color . color ( " invalid " ) , null ) ;%NWL%test . equal ( color . color ( " hasOwnProperty " ) , null ) ;%NWL%test . equal ( color . color ( " __proto__ " ) , null ) ;%NWL%test . equal ( color . color ( " #ab " ) , null ) ;%NWL%test . end ( ) ;%NWL%3
var i = 7e5%NWL%d3 . select ( ' canvas ' ) . append ( " rect " )%NWL%. attr ( ' x ' , function ( )  { return Math . random ( )  * 500 } )%NWL%. attr ( ' y ' , function ( )  { return Math . random ( )  * 500 } )%NWL%. attr ( " width " , 100 )%NWL%. attr ( " width " , 100 )%NWL%. attr ( ' fill ' , function ( d , i )  {%NWL%return ' pink '%NWL%d3 . select ( ' canvas ' ) . append ( " rect " )%NWL%1
if ( g = fragmentByStart [ endIndex ] )  {%NWL%delete fragmentByEnd [ f . end ] ;%NWL%delete fragmentByStart [ g . start ] ;%NWL%if ( f === g )  {%NWL%f . ring . push ( end ) ;%NWL%callback ( f . ring ) ;%NWL%} else {%NWL%fragmentByStart [ f . start ] = fragmentByEnd [ g . end ] = { start: f . start , end: g . end , ring: f . ring . concat ( g . ring ) } ;%NWL%}%NWL%} else {%NWL%f . ring . push ( end ) ;%NWL%4
}%NWL%} else {%NWL%delete fragmentByEnd [ f . end ] ;%NWL%f . ring . push ( end ) ;%NWL%fragmentByEnd [ f . end = endIndex ] = f;%NWL%}%NWL%} else if ( f = fragmentByStart [ endIndex ] )  {%NWL%if ( g = fragmentByEnd [ startIndex ] )  {%NWL%delete fragmentByStart [ f . start ] ;%NWL%delete fragmentByEnd [ g . end ] ;%NWL%f . ring . push ( end ) ;%NWL%3
var result = input . map ( function ( i )  {%NWL%return rule_1 ( i , mean , std ) ;%NWL%} ) ;%NWL%tape ( ' rule_1 marks appropriate points ' , function ( test )  {%NWL%test . ok ( result [ 0 ] ,  ' Positive val ' ) ;%NWL%test . ok ( result [ 1 ] ,  ' Negative val ' ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_1 marks ignores other points ' , function ( test )  {%NWL%test . notOk ( result [ 2 ] ,  ' Positive val ' ) ;%NWL%test . end ( ) ;%NWL%6
import { event } from " d3 - selection " ;%NWL%export function nopropagation ( )  {%NWL%event . stopImmediatePropagation ( ) ;%NWL%}%NWL%event . preventDefault ( ) ;%NWL%2
import { event } from " d3 - selection " ;%NWL%export function nopropagation ( )  {%NWL%event . stopImmediatePropagation ( ) ;%NWL%}%NWL%export default function ( )  {%NWL%event . stopImmediatePropagation ( ) ;%NWL%2
. append ( ' rect ' )%NWL%. attr ( ' width ' , 4 )%NWL%. attr ( ' height ' , function ( d )  { return y ( d . y )  } )%NWL%. attr ( ' x ' , function ( d , i )  { return x ( d . x )  } )%NWL%. attr ( ' y ' , function ( d )  { return size . height - y ( d . y )  - 30 } )%NWL%. attr ( ' fill ' ,  ' indianred ' )%NWL%var axis = d3 . svg . axis ( )%NWL%. scale ( x )%NWL%. orient ( " bottom " )%NWL%svg%NWL%var brush = d3 . svg . brush ( ) . x ( x ) . on ( " brush " , brushmove ) . extent ( [ - 500 ,  - 400 ] )%NWL%6
var extent = brush . extent ( )%NWL%extent = ( extent [ 1 ] < 2040 ) ?%NWL%extent . map ( function ( d )  { return d + 1 } ) :%NWL%extent . map ( function ( d )  { return d - 2500 } )%NWL%brush . extent ( extent )%NWL%brush . event ( b )%NWL%b . call ( brush )%NWL%} )%NWL%function brushmove ( )  {%NWL%adnan ( d3 . event . target . extent ( ) )%NWL%var tip = d3 . tip ( ) . attr ( ' class ' ,  ' d3 - tip ' )%NWL%0
function brushmove ( )  {%NWL%adnan ( d3 . event . target . extent ( ) )%NWL%}%NWL%var tip = d3 . tip ( ) . attr ( ' class ' ,  ' d3 - tip ' )%NWL%. html ( function ( d )  { return d . event  } )%NWL%function adnan ( s )  {%NWL%pathgl . uniform ( ' dates ' , s )%NWL%document . title = s . map ( Math . round )%NWL%d3 . select ( ' . current_year ' ) . text ( from < 0 ? ' '  + Math . abs ( + from )  +  ' BC ' : from )%NWL%return%NWL%var x = d3 . event . x , y = d3 . event . y%NWL%3
dsv = require ( " . . / " ) ,%NWL%fs = require ( " fs " ) ,%NWL%table = require ( " . / table " ) ,%NWL%spectrum = require ( " csv - spectrum " ) ;%NWL%tape ( " csvParse ( string ) returns the expected objects " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n1 , 2 , 3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( fs . readFileSync ( " test / data / sample . csv " ,  " utf - 8 " ) ) , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string ) does not strip whitespace " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( dsv . csvParse ( " a , b , c\n1 , 2 , 3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( fs . readFileSync ( " test / data / sample . csv " ,  " utf - 8 " ) ) , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n 1 , 2 , 3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n\ " 1\ " , 2 , 3 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " csvParse ( string ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n 1 , 2 , 3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n\ " 1\ " , 2 , 3 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n\ " 1\ " , 2 , 3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( dsv . csvParse ( " a , b , c\n\ " 1\ " , 2 , 3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParse ( " a\n\ " \ " \ " hello\ " \ " \ " " ) , table ( [ { a: " \ " hello\ " " } ] ,  [ " a " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParse ( " a\n\ " new\nline\ " " ) , table ( [ { a: " new\nline " } ] ,  [ " a " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a\n\ " new\rline\ " " ) , table ( [ { a: " new\rline " } ] ,  [ " a " ] ) ) ;%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%tape ( " csvParse ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParse ( " a\n\ " new\nline\ " " ) , table ( [ { a: " new\nline " } ] ,  [ " a " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a\n\ " new\rline\ " " ) , table ( [ { a: " new\rline " } ] ,  [ " a " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a\n\ " new\r\nline\ " " ) , table ( [ { a: " new\r\nline " } ] ,  [ " a " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string ) observes Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n1 , 2 , 3\n4 , 5 , \ " 6\ " \n7 , 8 , 9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\r1 , 2 , 3\r4 , 5 , \ " 6\ " \r7 , 8 , 9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " csvParse ( string ) observes Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n1 , 2 , 3\n4 , 5 , \ " 6\ " \n7 , 8 , 9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\r1 , 2 , 3\r4 , 5 , \ " 6\ " \r7 , 8 , 9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\r\n1 , 2 , 3\r\n4 , 5 , \ " 6\ " \r\n7 , 8 , 9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string ) returns columns in the input order " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n " ) . columns ,  [ " a " ,  " b " ,  " c " ] ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a , c , b\n " ) . columns ,  [ " a " ,  " c " ,  " b " ] ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a , 0 , 1\n " ) . columns ,  [ " a " ,  " 0 " ,  " 1 " ] ) ;%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( dsv . csvParse ( " 1 , 0 , a\n " ) . columns ,  [ " 1 " ,  " 0 " ,  " a " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string ) passes the csv - spectrum test suite " , function ( test )  {%NWL%spectrum ( function ( error , samples )  {%NWL%samples . forEach ( function ( sample )  {%NWL%var actual = dsv . csvParse ( sample . csv . toString ( ) ) ,%NWL%expected = JSON . parse ( sample . json . toString ( ) ) ;%NWL%delete actual . columns;%NWL%test . deepEqual ( actual , expected ) ;%NWL%test . end ( ) ;%NWL%1
expected = JSON . parse ( sample . json . toString ( ) ) ;%NWL%delete actual . columns;%NWL%test . deepEqual ( actual , expected ) ;%NWL%} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string , row ) returns the expected converted objects " , function ( test )  {%NWL%function row ( d )  { d . Hello = - d . Hello; return d; }%NWL%test . deepEqual ( dsv . csvParse ( fs . readFileSync ( " test / data / sample . csv " ,  " utf - 8 " ) , row ) , table ( [ { Hello: - 42 , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " csvParse ( string , row ) returns the expected converted objects " , function ( test )  {%NWL%function row ( d )  { d . Hello = - d . Hello; return d; }%NWL%test . deepEqual ( dsv . csvParse ( fs . readFileSync ( " test / data / sample . csv " ,  " utf - 8 " ) , row ) , table ( [ { Hello: - 42 , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n1 , 2 , 3\n " , function ( d )  { return d; } ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( dsv . csvParse ( " field\n42\n\n\n\n " , row ) , table ( [ { field: " 42 " } , false ] ,  [ " field " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n1 , 2 , 3\n2 , 3 , 4 " , function ( d )  { return d . a & 1 ? null : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " csvParse ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( dsv . csvParse ( " field\n42\n\n\n\n " , row ) , table ( [ { field: " 42 " } , false ] ,  [ " field " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n1 , 2 , 3\n2 , 3 , 4 " , function ( d )  { return d . a & 1 ? null : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . csvParse ( " a , b , c\n1 , 2 , 3\n2 , 3 , 4 " , function ( d )  { return d . a & 1 ? undefined : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string , row ) calls row ( d , i ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%dsv . csvParse ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( dsv . csvParse ( " a , b , c\n1 , 2 , 3\n2 , 3 , 4 " , function ( d )  { return d . a & 1 ? undefined : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParse ( string , row ) calls row ( d , i ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%dsv . csvParse ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: { a: " 1 " } , i: 0 } ,  { d: { a: " 2 " } , i: 1 } ,  { d: { a: " 3 " } , i: 2 } ,  { d: { a: " 4 " } , i: 3 } ] ) ;;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string ) returns the expected array of array of string " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
dsv . csvParse ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: { a: " 1 " } , i: 0 } ,  { d: { a: " 2 " } , i: 1 } ,  { d: { a: " 3 " } , i: 2 } ,  { d: { a: " 4 " } , i: 3 } ] ) ;;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string ) returns the expected array of array of string " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParseRows ( " a , b , c\n " ) ,  [ [ " a " ,  " b " ,  " c " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParseRows ( " \ " 1\ " , 2 , 3\n " ) ,  [ [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " csvParseRows ( string ) returns the expected array of array of string " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParseRows ( " a , b , c\n " ) ,  [ [ " a " ,  " b " ,  " c " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParseRows ( " \ " 1\ " , 2 , 3\n " ) ,  [ [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ;%NWL%test . deepEqual ( dsv . csvParseRows ( " \ " hello\ " " ) ,  [ [ " hello " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( dsv . csvParseRows ( " \ " hello\ " " ) ,  [ [ " hello " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParseRows ( " \ " \ " \ " hello\ " \ " \ " " ) ,  [ [ " \ " hello\ " " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParseRows ( " \ " new\nline\ " " ) ,  [ [ " new\nline " ] ] ) ;%NWL%test . deepEqual ( dsv . csvParseRows ( " \ " new\rline\ " " ) ,  [ [ " new\rline " ] ] ) ;%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%tape ( " csvParseRows ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParseRows ( " \ " new\nline\ " " ) ,  [ [ " new\nline " ] ] ) ;%NWL%test . deepEqual ( dsv . csvParseRows ( " \ " new\rline\ " " ) ,  [ [ " new\rline " ] ] ) ;%NWL%test . deepEqual ( dsv . csvParseRows ( " \ " new\r\nline\ " " ) ,  [ [ " new\r\nline " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string ) parses Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParseRows ( " a , b , c\n1 , 2 , 3\n4 , 5 , \ " 6\ " \n7 , 8 , 9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . deepEqual ( dsv . csvParseRows ( " a , b , c\r1 , 2 , 3\r4 , 5 , \ " 6\ " \r7 , 8 , 9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " csvParseRows ( string ) parses Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . csvParseRows ( " a , b , c\n1 , 2 , 3\n4 , 5 , \ " 6\ " \n7 , 8 , 9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . deepEqual ( dsv . csvParseRows ( " a , b , c\r1 , 2 , 3\r4 , 5 , \ " 6\ " \r7 , 8 , 9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . deepEqual ( dsv . csvParseRows ( " a , b , c\r\n1 , 2 , 3\r\n4 , 5 , \ " 6\ " \r\n7 , 8 , 9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string , row ) returns the expected converted array of array of string " , function ( test )  {%NWL%function row ( d , i )  { if ( i ) d [ 0 ] = - d [ 0 ] ; return d; }%NWL%test . deepEqual ( dsv . csvParseRows ( fs . readFileSync ( " test / data / sample . csv " ,  " utf - 8 " ) , row ) ,  [ [ " Hello " ,  " World " ] ,  [ - 42 ,  " \ " fish\ " " ] ] ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " csvParseRows ( string , row ) returns the expected converted array of array of string " , function ( test )  {%NWL%function row ( d , i )  { if ( i ) d [ 0 ] = - d [ 0 ] ; return d; }%NWL%test . deepEqual ( dsv . csvParseRows ( fs . readFileSync ( " test / data / sample . csv " ,  " utf - 8 " ) , row ) ,  [ [ " Hello " ,  " World " ] ,  [ - 42 ,  " \ " fish\ " " ] ] ) ;%NWL%test . deepEqual ( dsv . csvParseRows ( " a , b , c\n1 , 2 , 3\n " , function ( d )  { return d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( dsv . csvParseRows ( " field\n42\n\n\n " , row ) ,  [ [ " field " ] , false ] ) ;%NWL%test . deepEqual ( dsv . csvParseRows ( " a , b , c\n1 , 2 , 3\n2 , 3 , 4 " , function ( d , i )  { return i & 1 ? null : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " csvParseRows ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( dsv . csvParseRows ( " field\n42\n\n\n " , row ) ,  [ [ " field " ] , false ] ) ;%NWL%test . deepEqual ( dsv . csvParseRows ( " a , b , c\n1 , 2 , 3\n2 , 3 , 4 " , function ( d , i )  { return i & 1 ? null : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . deepEqual ( dsv . csvParseRows ( " a , b , c\n1 , 2 , 3\n2 , 3 , 4 " , function ( d , i )  { return i & 1 ? undefined : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string , row ) invokes row ( d , i ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%dsv . csvParseRows ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( dsv . csvParseRows ( " a , b , c\n1 , 2 , 3\n2 , 3 , 4 " , function ( d , i )  { return i & 1 ? undefined : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvParseRows ( string , row ) invokes row ( d , i ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%dsv . csvParseRows ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: [ " a " ] , i: 0 } ,  { d: [ " 1 " ] , i: 1 } ,  { d: [ " 2 " ] , i: 2 } ,  { d: [ " 3 " ] , i: 3 } ,  { d: [ " 4 " ] , i: 4 } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array ) takes an array of objects as input " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
dsv . csvParseRows ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: [ " a " ] , i: 0 } ,  { d: [ " 1 " ] , i: 1 } ,  { d: [ " 2 " ] , i: 2 } ,  { d: [ " 3 " ] , i: 3 } ,  { d: [ " 4 " ] , i: 4 } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array ) takes an array of objects as input " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ) ,  " a , b , c\n1 , 2 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array ) escapes field names and values containing delimiters " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { " foo , bar " : true } ] ) ,  " \ " foo , bar\ " \ntrue " ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " csvFormat ( array ) takes an array of objects as input " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ) ,  " a , b , c\n1 , 2 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array ) escapes field names and values containing delimiters " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { " foo , bar " : true } ] ) ,  " \ " foo , bar\ " \ntrue " ) ;%NWL%test . deepEqual ( dsv . csvFormat ( [ { field: " foo , bar " } ] ) ,  " field\n\ " foo , bar\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array ) computes the union of all fields " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " csvFormat ( array ) escapes field names and values containing delimiters " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { " foo , bar " : true } ] ) ,  " \ " foo , bar\ " \ntrue " ) ;%NWL%test . deepEqual ( dsv . csvFormat ( [ { field: " foo , bar " } ] ) ,  " field\n\ " foo , bar\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array ) computes the union of all fields " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 } ,  { a: 1 , b: 2 } ,  { a: 1 , b: 2 , c: 3 } ,  { b: 1 , c: 2 } ,  { c: 1 } ] ) ,  " a , b , c\n1 , , \n1 , 2 , \n1 , 2 , 3\n , 1 , 2\n , , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array ) orders fields by first - seen " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array ) orders fields by first - seen " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 } ,  { c: 3 , b: 4 } ,  { c: 5 , a: 1 , b: 2 } ] ) ,  " a , b , c\n1 , 2 , \n , 4 , 3\n1 , 2 , 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array , columns ) observes the specified array of column names " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " b " ,  " a " ] ) ,  " c , b , a\n3 , 2 , 1 " ) ;%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " a " ] ) ,  " c , a\n3 , 1 " ) ;%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ ] ) ,  " \n " ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " csvFormat ( array , columns ) observes the specified array of column names " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " b " ,  " a " ] ) ,  " c , b , a\n3 , 2 , 1 " ) ;%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " a " ] ) ,  " c , a\n3 , 1 " ) ;%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ ] ) ,  " \n " ) ;%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " d " ] ) ,  " d\n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array , columns ) coerces column names to strings " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 ,  " \ " fish\ " " : 3 } ] ,  [ { toString: function ( )  { return " \ " fish\ " " ; } } ] ) ,  " \ " \ " \ " fish\ " \ " \ " \n3 " ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " d " ] ) ,  " d\n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array , columns ) coerces column names to strings " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 ,  " \ " fish\ " " : 3 } ] ,  [ { toString: function ( )  { return " \ " fish\ " " ; } } ] ) ,  " \ " \ " \ " fish\ " \ " \ " \n3 " ) ;%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " a " , null ,  " b " , undefined ,  " c " ] ) ,  " a , , b , , c\n1 , , 2 , , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array , columns ) coerces field values to strings " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: { toString: function ( )  { return " \ " fish\ " " ; } } } ] ) ,  " a\n\ " \ " \ " fish\ " \ " \ " " ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 ,  " \ " fish\ " " : 3 } ] ,  [ { toString: function ( )  { return " \ " fish\ " " ; } } ] ) ,  " \ " \ " \ " fish\ " \ " \ " \n3 " ) ;%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " a " , null ,  " b " , undefined ,  " c " ] ) ,  " a , , b , , c\n1 , , 2 , , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormat ( array , columns ) coerces field values to strings " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: { toString: function ( )  { return " \ " fish\ " " ; } } } ] ) ,  " a\n\ " \ " \ " fish\ " \ " \ " " ) ;%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: null , b: undefined , c: 3 } ] ) ,  " a , b , c\n , , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) takes an array of array of string as input " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " csvFormat ( array , columns ) coerces field values to strings " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: { toString: function ( )  { return " \ " fish\ " " ; } } } ] ) ,  " a\n\ " \ " \ " fish\ " \ " \ " " ) ;%NWL%test . deepEqual ( dsv . csvFormat ( [ { a: null , b: undefined , c: 3 } ] ) ,  " a , b , c\n , , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) takes an array of array of string as input " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a , b , c\n1 , 2 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) separates lines using Unix newline " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) takes an array of array of string as input " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a , b , c\n1 , 2 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) separates lines using Unix newline " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ ] ,  [ ] ] ) ,  " \n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a , b , c\n1 , 2 , 3 " ) ;%NWL%3
} ) ;%NWL%tape ( " csvFormatRows ( array ) takes an array of array of string as input " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a , b , c\n1 , 2 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) separates lines using Unix newline " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ ] ,  [ ] ] ) ,  " \n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) does not strip whitespace " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " csvFormatRows ( array ) separates lines using Unix newline " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ ] ,  [ ] ] ) ,  " \n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a , b , c\n1 , 2 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) does not quote simple values " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " csvFormatRows ( array ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a , b , c\n1 , 2 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) does not quote simple values " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " a " ] ,  [ 1 ] ] ) ,  " a\n1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) escapes double quotes " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " csvFormatRows ( array ) does not quote simple values " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " a " ] ,  [ 1 ] ] ) ,  " a\n1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) escapes double quotes " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " \ " fish\ " " ] ] ) ,  " \ " \ " \ " fish\ " \ " \ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) escapes Unix newlines " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " csvFormatRows ( array ) escapes double quotes " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " \ " fish\ " " ] ] ) ,  " \ " \ " \ " fish\ " \ " \ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) escapes Unix newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " new\nline " ] ] ) ,  " \ " new\nline\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) escapes Windows newlines " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " csvFormatRows ( array ) escapes Unix newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " new\nline " ] ] ) ,  " \ " new\nline\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) escapes Windows newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . csvFormatRows ( [ [ " new\rline " ] ] ) ,  " \ " new\rline\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " csvFormatRows ( array ) escapes values containing delimiters " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
dsv = require ( " . . / " ) ,%NWL%fs = require ( " fs " ) ,%NWL%table = require ( " . / table " ) ;%NWL%var psv = dsv . dsvFormat ( " | " ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string ) returns the expected objects " , function ( test )  {%NWL%test . deepEqual ( psv . parse ( " a|b|c\n1|2|3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( fs . readFileSync ( " test / data / sample . psv " ,  " utf - 8 " ) ) , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string ) does not strip whitespace " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( psv . parse ( " a|b|c\n1|2|3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( fs . readFileSync ( " test / data / sample . psv " ,  " utf - 8 " ) ) , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( psv . parse ( " a|b|c\n 1| 2|3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( psv . parse ( " a|b|c\n\ " 1\ " |2|3 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " dsv ( \ " |\ " ) . parse ( string ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( psv . parse ( " a|b|c\n 1| 2|3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( psv . parse ( " a|b|c\n\ " 1\ " |2|3 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( " a|b|c\n\ " 1\ " |2|3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( psv . parse ( " a|b|c\n\ " 1\ " |2|3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . deepEqual ( psv . parse ( " a\n\ " \ " \ " hello\ " \ " \ " " ) , table ( [ { a: " \ " hello\ " " } ] ,  [ " a " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( psv . parse ( " a\n\ " new\nline\ " " ) , table ( [ { a: " new\nline " } ] ,  [ " a " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( " a\n\ " new\rline\ " " ) , table ( [ { a: " new\rline " } ] ,  [ " a " ] ) ) ;%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( psv . parse ( " a\n\ " new\nline\ " " ) , table ( [ { a: " new\nline " } ] ,  [ " a " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( " a\n\ " new\rline\ " " ) , table ( [ { a: " new\rline " } ] ,  [ " a " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( " a\n\ " new\r\nline\ " " ) , table ( [ { a: " new\r\nline " } ] ,  [ " a " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string ) observes Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( psv . parse ( " a|b|c\n1|2|3\n4|5|\ " 6\ " \n7|8|9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( " a|b|c\r1|2|3\r4|5|\ " 6\ " \r7|8|9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string ) observes Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( psv . parse ( " a|b|c\n1|2|3\n4|5|\ " 6\ " \n7|8|9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( " a|b|c\r1|2|3\r4|5|\ " 6\ " \r7|8|9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( " a|b|c\r\n1|2|3\r\n4|5|\ " 6\ " \r\n7|8|9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string , row ) returns the expected converted objects " , function ( test )  {%NWL%function row ( d )  { d . Hello = - d . Hello; return d; }%NWL%test . deepEqual ( psv . parse ( fs . readFileSync ( " test / data / sample . psv " ,  " utf - 8 " ) , row ) , table ( [ { Hello: - 42 , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " dsv ( \ " |\ " ) . parse ( string , row ) returns the expected converted objects " , function ( test )  {%NWL%function row ( d )  { d . Hello = - d . Hello; return d; }%NWL%test . deepEqual ( psv . parse ( fs . readFileSync ( " test / data / sample . psv " ,  " utf - 8 " ) , row ) , table ( [ { Hello: - 42 , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( " a|b|c\n1|2|3\n " , function ( d )  { return d; } ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( psv . parse ( " field\n42\n\n\n\n " , row ) , table ( [ { field: " 42 " } , false ] ,  [ " field " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( " a|b|c\n1|2|3\n2|3|4 " , function ( d )  { return d . a & 1 ? null : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " dsv ( \ " |\ " ) . parse ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( psv . parse ( " field\n42\n\n\n\n " , row ) , table ( [ { field: " 42 " } , false ] ,  [ " field " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( " a|b|c\n1|2|3\n2|3|4 " , function ( d )  { return d . a & 1 ? null : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( psv . parse ( " a|b|c\n1|2|3\n2|3|4 " , function ( d )  { return d . a & 1 ? undefined : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string , row ) invokes row ( d , i , columns ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%psv . parse ( " a\n1\n2\n3\n4 " , function ( d , i , columns )  { rows . push ( { d: d , i: i , columns: columns } ) ; } ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( psv . parse ( " a|b|c\n1|2|3\n2|3|4 " , function ( d )  { return d . a & 1 ? undefined : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parse ( string , row ) invokes row ( d , i , columns ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%psv . parse ( " a\n1\n2\n3\n4 " , function ( d , i , columns )  { rows . push ( { d: d , i: i , columns: columns } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: { a: " 1 " } , i: 0 , columns: [ " a " ] } ,  { d: { a: " 2 " } , i: 1 , columns: [ " a " ] } ,  { d: { a: " 3 " } , i: 2 , columns: [ " a " ] } ,  { d: { a: " 4 " } , i: 3 , columns: [ " a " ] } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string ) returns the expected array of array of string " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
psv . parse ( " a\n1\n2\n3\n4 " , function ( d , i , columns )  { rows . push ( { d: d , i: i , columns: columns } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: { a: " 1 " } , i: 0 , columns: [ " a " ] } ,  { d: { a: " 2 " } , i: 1 , columns: [ " a " ] } ,  { d: { a: " 3 " } , i: 2 , columns: [ " a " ] } ,  { d: { a: " 4 " } , i: 3 , columns: [ " a " ] } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string ) returns the expected array of array of string " , function ( test )  {%NWL%test . deepEqual ( psv . parseRows ( " a|b|c\n " ) ,  [ [ " a " ,  " b " ,  " c " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( psv . parseRows ( " \ " 1\ " |2|3\n " ) ,  [ [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " dsv ( \ " |\ " ) . parseRows ( string ) returns the expected array of array of string " , function ( test )  {%NWL%test . deepEqual ( psv . parseRows ( " a|b|c\n " ) ,  [ [ " a " ,  " b " ,  " c " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( psv . parseRows ( " \ " 1\ " |2|3\n " ) ,  [ [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ;%NWL%test . deepEqual ( psv . parseRows ( " \ " hello\ " " ) ,  [ [ " hello " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( psv . parseRows ( " \ " hello\ " " ) ,  [ [ " hello " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . deepEqual ( psv . parseRows ( " \ " \ " \ " hello\ " \ " \ " " ) ,  [ [ " \ " hello\ " " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( psv . parseRows ( " \ " new\nline\ " " ) ,  [ [ " new\nline " ] ] ) ;%NWL%test . deepEqual ( psv . parseRows ( " \ " new\rline\ " " ) ,  [ [ " new\rline " ] ] ) ;%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( psv . parseRows ( " \ " new\nline\ " " ) ,  [ [ " new\nline " ] ] ) ;%NWL%test . deepEqual ( psv . parseRows ( " \ " new\rline\ " " ) ,  [ [ " new\rline " ] ] ) ;%NWL%test . deepEqual ( psv . parseRows ( " \ " new\r\nline\ " " ) ,  [ [ " new\r\nline " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string ) parses Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( psv . parseRows ( " a|b|c\n1|2|3\n4|5|\ " 6\ " \n7|8|9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . deepEqual ( psv . parseRows ( " a|b|c\r1|2|3\r4|5|\ " 6\ " \r7|8|9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string ) parses Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( psv . parseRows ( " a|b|c\n1|2|3\n4|5|\ " 6\ " \n7|8|9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . deepEqual ( psv . parseRows ( " a|b|c\r1|2|3\r4|5|\ " 6\ " \r7|8|9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . deepEqual ( psv . parseRows ( " a|b|c\r\n1|2|3\r\n4|5|\ " 6\ " \r\n7|8|9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string , row ) returns the expected converted array of array of string " , function ( test )  {%NWL%function row ( d , i )  { if ( i ) d [ 0 ] = - d [ 0 ] ; return d; }%NWL%test . deepEqual ( psv . parseRows ( fs . readFileSync ( " test / data / sample . psv " ,  " utf - 8 " ) , row ) ,  [ [ " Hello " ,  " World " ] ,  [ - 42 ,  " \ " fish\ " " ] ] ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " dsv ( \ " |\ " ) . parseRows ( string , row ) returns the expected converted array of array of string " , function ( test )  {%NWL%function row ( d , i )  { if ( i ) d [ 0 ] = - d [ 0 ] ; return d; }%NWL%test . deepEqual ( psv . parseRows ( fs . readFileSync ( " test / data / sample . psv " ,  " utf - 8 " ) , row ) ,  [ [ " Hello " ,  " World " ] ,  [ - 42 ,  " \ " fish\ " " ] ] ) ;%NWL%test . deepEqual ( psv . parseRows ( " a|b|c\n1|2|3\n " , function ( d )  { return d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( psv . parseRows ( " field\n42\n\n\n " , row ) ,  [ [ " field " ] , false ] ) ;%NWL%test . deepEqual ( psv . parseRows ( " a|b|c\n1|2|3\n2|3|4 " , function ( d , i )  { return i & 1 ? null : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " dsv ( \ " |\ " ) . parseRows ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( psv . parseRows ( " field\n42\n\n\n " , row ) ,  [ [ " field " ] , false ] ) ;%NWL%test . deepEqual ( psv . parseRows ( " a|b|c\n1|2|3\n2|3|4 " , function ( d , i )  { return i & 1 ? null : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . deepEqual ( psv . parseRows ( " a|b|c\n1|2|3\n2|3|4 " , function ( d , i )  { return i & 1 ? undefined : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string , row ) invokes row ( d , i ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%psv . parseRows ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( psv . parseRows ( " a|b|c\n1|2|3\n2|3|4 " , function ( d , i )  { return i & 1 ? undefined : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . parseRows ( string , row ) invokes row ( d , i ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%psv . parseRows ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: [ " a " ] , i: 0 } ,  { d: [ " 1 " ] , i: 1 } ,  { d: [ " 2 " ] , i: 2 } ,  { d: [ " 3 " ] , i: 3 } ,  { d: [ " 4 " ] , i: 4 } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . format ( array ) takes an array of objects as input " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
psv . parseRows ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: [ " a " ] , i: 0 } ,  { d: [ " 1 " ] , i: 1 } ,  { d: [ " 2 " ] , i: 2 } ,  { d: [ " 3 " ] , i: 3 } ,  { d: [ " 4 " ] , i: 4 } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . format ( array ) takes an array of objects as input " , function ( test )  {%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ) ,  " a|b|c\n1|2|3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . format ( array ) escapes field names and values containing delimiters " , function ( test )  {%NWL%test . deepEqual ( psv . format ( [ { " foo|bar " : true } ] ) ,  " \ " foo|bar\ " \ntrue " ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " dsv ( \ " |\ " ) . format ( array ) takes an array of objects as input " , function ( test )  {%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ) ,  " a|b|c\n1|2|3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . format ( array ) escapes field names and values containing delimiters " , function ( test )  {%NWL%test . deepEqual ( psv . format ( [ { " foo|bar " : true } ] ) ,  " \ " foo|bar\ " \ntrue " ) ;%NWL%test . deepEqual ( psv . format ( [ { field: " foo|bar " } ] ) ,  " field\n\ " foo|bar\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . format ( array ) computes the union of all fields " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " dsv ( \ " |\ " ) . format ( array ) escapes field names and values containing delimiters " , function ( test )  {%NWL%test . deepEqual ( psv . format ( [ { " foo|bar " : true } ] ) ,  " \ " foo|bar\ " \ntrue " ) ;%NWL%test . deepEqual ( psv . format ( [ { field: " foo|bar " } ] ) ,  " field\n\ " foo|bar\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . format ( array ) computes the union of all fields " , function ( test )  {%NWL%test . deepEqual ( psv . format ( [ { a: 1 } ,  { a: 1 , b: 2 } ,  { a: 1 , b: 2 , c: 3 } ,  { b: 1 , c: 2 } ,  { c: 1 } ] ) ,  " a|b|c\n1||\n1|2|\n1|2|3\n|1|2\n||1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . format ( array ) orders fields by first - seen " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . format ( array ) orders fields by first - seen " , function ( test )  {%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 } ,  { c: 3 , b: 4 } ,  { c: 5 , a: 1 , b: 2 } ] ) ,  " a|b|c\n1|2|\n|4|3\n1|2|5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . format ( array , columns ) observes the specified array of column names " , function ( test )  {%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " b " ,  " a " ] ) ,  " c|b|a\n3|2|1 " ) ;%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " a " ] ) ,  " c|a\n3|1 " ) ;%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ ] ) ,  " \n " ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . format ( array , columns ) observes the specified array of column names " , function ( test )  {%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " b " ,  " a " ] ) ,  " c|b|a\n3|2|1 " ) ;%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " a " ] ) ,  " c|a\n3|1 " ) ;%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ ] ) ,  " \n " ) ;%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " d " ] ) ,  " d\n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) takes an array of array of string as input " , function ( test )  {%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " a " ] ) ,  " c|a\n3|1 " ) ;%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ ] ) ,  " \n " ) ;%NWL%test . deepEqual ( psv . format ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " d " ] ) ,  " d\n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) takes an array of array of string as input " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a|b|c\n1|2|3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) separates lines using Unix newline " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) takes an array of array of string as input " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a|b|c\n1|2|3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) separates lines using Unix newline " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ ] ,  [ ] ] ) ,  " \n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) does not strip whitespace " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) separates lines using Unix newline " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ ] ,  [ ] ] ) ,  " \n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a | b|c\n1|2|3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) does not quote simple values " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a | b|c\n1|2|3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) does not quote simple values " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ " a " ] ,  [ 1 ] ] ) ,  " a\n1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) escapes double quotes " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) does not quote simple values " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ " a " ] ,  [ 1 ] ] ) ,  " a\n1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) escapes double quotes " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ " \ " fish\ " " ] ] ) ,  " \ " \ " \ " fish\ " \ " \ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) escapes Unix newlines " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) escapes double quotes " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ " \ " fish\ " " ] ] ) ,  " \ " \ " \ " fish\ " \ " \ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) escapes Unix newlines " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ " new\nline " ] ] ) ,  " \ " new\nline\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) escapes Windows newlines " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) escapes Unix newlines " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ " new\nline " ] ] ) ,  " \ " new\nline\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) escapes Windows newlines " , function ( test )  {%NWL%test . deepEqual ( psv . formatRows ( [ [ " new\rline " ] ] ) ,  " \ " new\rline\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " dsv ( \ " |\ " ) . formatRows ( array ) escapes values containing delimiters " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
var tape = require ( " tape " ) ,%NWL%dsv = require ( " . . / " ) ,%NWL%fs = require ( " fs " ) ,%NWL%table = require ( " . / table " ) ;%NWL%tape ( " tsvParse ( string ) returns the expected objects " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n1\t2\t3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( fs . readFileSync ( " test / data / sample . tsv " ,  " utf - 8 " ) ) , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string ) does not strip whitespace " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n1\t2\t3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( fs . readFileSync ( " test / data / sample . tsv " ,  " utf - 8 " ) ) , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n 1\t 2\t3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n\ " 1\ " \t2\t3 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " tsvParse ( string ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n 1\t 2\t3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n\ " 1\ " \t2\t3 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n\ " 1\ " \t2\t3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n\ " 1\ " \t2\t3\n " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParse ( " a\n\ " \ " \ " hello\ " \ " \ " " ) , table ( [ { a: " \ " hello\ " " } ] ,  [ " a " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParse ( " a\n\ " new\nline\ " " ) , table ( [ { a: " new\nline " } ] ,  [ " a " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( " a\n\ " new\rline\ " " ) , table ( [ { a: " new\rline " } ] ,  [ " a " ] ) ) ;%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%tape ( " tsvParse ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParse ( " a\n\ " new\nline\ " " ) , table ( [ { a: " new\nline " } ] ,  [ " a " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( " a\n\ " new\rline\ " " ) , table ( [ { a: " new\rline " } ] ,  [ " a " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( " a\n\ " new\r\nline\ " " ) , table ( [ { a: " new\r\nline " } ] ,  [ " a " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string ) observes Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n1\t2\t3\n4\t5\t\ " 6\ " \n7\t8\t9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\r1\t2\t3\r4\t5\t\ " 6\ " \r7\t8\t9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " tsvParse ( string ) observes Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n1\t2\t3\n4\t5\t\ " 6\ " \n7\t8\t9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\r1\t2\t3\r4\t5\t\ " 6\ " \r7\t8\t9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\r\n1\t2\t3\r\n4\t5\t\ " 6\ " \r\n7\t8\t9 " ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ,  { a: " 4 " , b: " 5 " , c: " 6 " } ,  { a: " 7 " , b: " 8 " , c: " 9 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string , row ) returns the expected converted objects " , function ( test )  {%NWL%function row ( d )  { d . Hello = - d . Hello; return d; }%NWL%test . deepEqual ( dsv . tsvParse ( fs . readFileSync ( " test / data / sample . tsv " ,  " utf - 8 " ) , row ) , table ( [ { Hello: - 42 , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " tsvParse ( string , row ) returns the expected converted objects " , function ( test )  {%NWL%function row ( d )  { d . Hello = - d . Hello; return d; }%NWL%test . deepEqual ( dsv . tsvParse ( fs . readFileSync ( " test / data / sample . tsv " ,  " utf - 8 " ) , row ) , table ( [ { Hello: - 42 , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n1\t2\t3\n " , function ( d )  { return d; } ) , table ( [ { a: " 1 " , b: " 2 " , c: " 3 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( dsv . tsvParse ( " field\n42\n\n\n\n " , row ) , table ( [ { field: " 42 " } , false ] ,  [ " field " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n1\t2\t3\n2\t3\t4 " , function ( d )  { return d . a & 1 ? null : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " tsvParse ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( dsv . tsvParse ( " field\n42\n\n\n\n " , row ) , table ( [ { field: " 42 " } , false ] ,  [ " field " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n1\t2\t3\n2\t3\t4 " , function ( d )  { return d . a & 1 ? null : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n1\t2\t3\n2\t3\t4 " , function ( d )  { return d . a & 1 ? undefined : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string , row ) invokes row ( d , i ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%dsv . tsvParse ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( dsv . tsvParse ( " a\tb\tc\n1\t2\t3\n2\t3\t4 " , function ( d )  { return d . a & 1 ? undefined : d; } ) , table ( [ { a: " 2 " , b: " 3 " , c: " 4 " } ] ,  [ " a " ,  " b " ,  " c " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParse ( string , row ) invokes row ( d , i ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%dsv . tsvParse ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: { a: " 1 " } , i: 0 } ,  { d: { a: " 2 " } , i: 1 } ,  { d: { a: " 3 " } , i: 2 } ,  { d: { a: " 4 " } , i: 3 } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string ) returns the expected array of array of string " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
dsv . tsvParse ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: { a: " 1 " } , i: 0 } ,  { d: { a: " 2 " } , i: 1 } ,  { d: { a: " 3 " } , i: 2 } ,  { d: { a: " 4 " } , i: 3 } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string ) returns the expected array of array of string " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\n " ) ,  [ [ " a " ,  " b " ,  " c " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParseRows ( " \ " 1\ " \t2\t3\n " ) ,  [ [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " tsvParseRows ( string ) returns the expected array of array of string " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\n " ) ,  [ [ " a " ,  " b " ,  " c " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string ) parses quoted values " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParseRows ( " \ " 1\ " \t2\t3\n " ) ,  [ [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ;%NWL%test . deepEqual ( dsv . tsvParseRows ( " \ " hello\ " " ) ,  [ [ " hello " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( dsv . tsvParseRows ( " \ " hello\ " " ) ,  [ [ " hello " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string ) parses quoted values with quotes " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParseRows ( " \ " \ " \ " hello\ " \ " \ " " ) ,  [ [ " \ " hello\ " " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParseRows ( " \ " new\nline\ " " ) ,  [ [ " new\nline " ] ] ) ;%NWL%test . deepEqual ( dsv . tsvParseRows ( " \ " new\rline\ " " ) ,  [ [ " new\rline " ] ] ) ;%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%tape ( " tsvParseRows ( string ) parses quoted values with newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParseRows ( " \ " new\nline\ " " ) ,  [ [ " new\nline " ] ] ) ;%NWL%test . deepEqual ( dsv . tsvParseRows ( " \ " new\rline\ " " ) ,  [ [ " new\rline " ] ] ) ;%NWL%test . deepEqual ( dsv . tsvParseRows ( " \ " new\r\nline\ " " ) ,  [ [ " new\r\nline " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string ) parses Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\n1\t2\t3\n4\t5\t\ " 6\ " \n7\t8\t9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\r1\t2\t3\r4\t5\t\ " 6\ " \r7\t8\t9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " tsvParseRows ( string ) parses Unix , Mac and DOS newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\n1\t2\t3\n4\t5\t\ " 6\ " \n7\t8\t9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\r1\t2\t3\r4\t5\t\ " 6\ " \r7\t8\t9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\r\n1\t2\t3\r\n4\t5\t\ " 6\ " \r\n7\t8\t9 " ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ,  [ " 4 " ,  " 5 " ,  " 6 " ] ,  [ " 7 " ,  " 8 " ,  " 9 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string , row ) returns the expected converted array of array of string " , function ( test )  {%NWL%function row ( d , i )  { if ( i ) d [ 0 ] = - d [ 0 ] ; return d; }%NWL%test . deepEqual ( dsv . tsvParseRows ( fs . readFileSync ( " test / data / sample . tsv " ,  " utf - 8 " ) , row ) ,  [ [ " Hello " ,  " World " ] ,  [ - 42 ,  " \ " fish\ " " ] ] ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " tsvParseRows ( string , row ) returns the expected converted array of array of string " , function ( test )  {%NWL%function row ( d , i )  { if ( i ) d [ 0 ] = - d [ 0 ] ; return d; }%NWL%test . deepEqual ( dsv . tsvParseRows ( fs . readFileSync ( " test / data / sample . tsv " ,  " utf - 8 " ) , row ) ,  [ [ " Hello " ,  " World " ] ,  [ - 42 ,  " \ " fish\ " " ] ] ) ;%NWL%test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\n1\t2\t3\n " , function ( d )  { return d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( dsv . tsvParseRows ( " field\n42\n\n\n " , row ) ,  [ [ " field " ] , false ] ) ;%NWL%test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\n1\t2\t3\n2\t3\t4 " , function ( d , i )  { return i & 1 ? null : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " tsvParseRows ( string , row ) skips rows if row returns null or undefined " , function ( test )  {%NWL%function row ( d , i )  { return [ d , null , undefined , false ] [ i ] ; }%NWL%test . deepEqual ( dsv . tsvParseRows ( " field\n42\n\n\n " , row ) ,  [ [ " field " ] , false ] ) ;%NWL%test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\n1\t2\t3\n2\t3\t4 " , function ( d , i )  { return i & 1 ? null : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\n1\t2\t3\n2\t3\t4 " , function ( d , i )  { return i & 1 ? undefined : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string , row ) invokes row ( d , i ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%dsv . tsvParseRows ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( dsv . tsvParseRows ( " a\tb\tc\n1\t2\t3\n2\t3\t4 " , function ( d , i )  { return i & 1 ? undefined : d; } ) ,  [ [ " a " ,  " b " ,  " c " ] ,  [ " 2 " ,  " 3 " ,  " 4 " ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvParseRows ( string , row ) invokes row ( d , i ) for each row d , in order " , function ( test )  {%NWL%var rows = [ ] ;%NWL%dsv . tsvParseRows ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: [ " a " ] , i: 0 } ,  { d: [ " 1 " ] , i: 1 } ,  { d: [ " 2 " ] , i: 2 } ,  { d: [ " 3 " ] , i: 3 } ,  { d: [ " 4 " ] , i: 4 } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormat ( array ) takes an array of objects as input " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
dsv . tsvParseRows ( " a\n1\n2\n3\n4 " , function ( d , i )  { rows . push ( { d: d , i: i } ) ; } ) ;%NWL%test . deepEqual ( rows ,  [ { d: [ " a " ] , i: 0 } ,  { d: [ " 1 " ] , i: 1 } ,  { d: [ " 2 " ] , i: 2 } ,  { d: [ " 3 " ] , i: 3 } ,  { d: [ " 4 " ] , i: 4 } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormat ( array ) takes an array of objects as input " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ) ,  " a\tb\tc\n1\t2\t3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormat ( array ) escapes field names and values containing delimiters " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormat ( [ { " foo\tbar " : true } ] ) ,  " \ " foo\tbar\ " \ntrue " ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " tsvFormat ( array ) takes an array of objects as input " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ) ,  " a\tb\tc\n1\t2\t3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormat ( array ) escapes field names and values containing delimiters " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormat ( [ { " foo\tbar " : true } ] ) ,  " \ " foo\tbar\ " \ntrue " ) ;%NWL%test . deepEqual ( dsv . tsvFormat ( [ { field: " foo\tbar " } ] ) ,  " field\n\ " foo\tbar\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormat ( array ) computes the union of all fields " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " tsvFormat ( array ) escapes field names and values containing delimiters " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormat ( [ { " foo\tbar " : true } ] ) ,  " \ " foo\tbar\ " \ntrue " ) ;%NWL%test . deepEqual ( dsv . tsvFormat ( [ { field: " foo\tbar " } ] ) ,  " field\n\ " foo\tbar\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormat ( array ) computes the union of all fields " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 } ,  { a: 1 , b: 2 } ,  { a: 1 , b: 2 , c: 3 } ,  { b: 1 , c: 2 } ,  { c: 1 } ] ) ,  " a\tb\tc\n1\t\t\n1\t2\t\n1\t2\t3\n\t1\t2\n\t\t1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormat ( array ) orders fields by first - seen " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormat ( array ) orders fields by first - seen " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 } ,  { c: 3 , b: 4 } ,  { c: 5 , a: 1 , b: 2 } ] ) ,  " a\tb\tc\n1\t2\t\n\t4\t3\n1\t2\t5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormat ( array , columns ) observes the specified array of column names " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " b " ,  " a " ] ) ,  " c\tb\ta\n3\t2\t1 " ) ;%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " a " ] ) ,  " c\ta\n3\t1 " ) ;%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ ] ) ,  " \n " ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormat ( array , columns ) observes the specified array of column names " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " b " ,  " a " ] ) ,  " c\tb\ta\n3\t2\t1 " ) ;%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " a " ] ) ,  " c\ta\n3\t1 " ) ;%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ ] ) ,  " \n " ) ;%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " d " ] ) ,  " d\n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) takes an array of array of string as input " , function ( test )  {%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " c " ,  " a " ] ) ,  " c\ta\n3\t1 " ) ;%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ ] ) ,  " \n " ) ;%NWL%test . deepEqual ( dsv . tsvFormat ( [ { a: 1 , b: 2 , c: 3 } ] ,  [ " d " ] ) ,  " d\n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) takes an array of array of string as input " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a\tb\tc\n1\t2\t3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) separates lines using Unix newline " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " tsvFormatRows ( array ) takes an array of array of string as input " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a\tb\tc\n1\t2\t3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) separates lines using Unix newline " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ ] ,  [ ] ] ) ,  " \n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) does not strip whitespace " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " tsvFormatRows ( array ) separates lines using Unix newline " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ ] ,  [ ] ] ) ,  " \n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a \t b\tc\n1\t2\t3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) does not quote simple values " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " tsvFormatRows ( array ) does not strip whitespace " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a \t b\tc\n1\t2\t3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) does not quote simple values " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ " a " ] ,  [ 1 ] ] ) ,  " a\n1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) escapes double quotes " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " tsvFormatRows ( array ) does not quote simple values " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ " a " ] ,  [ 1 ] ] ) ,  " a\n1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) escapes double quotes " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ " \ " fish\ " " ] ] ) ,  " \ " \ " \ " fish\ " \ " \ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) escapes Unix newlines " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " tsvFormatRows ( array ) escapes double quotes " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ " \ " fish\ " " ] ] ) ,  " \ " \ " \ " fish\ " \ " \ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) escapes Unix newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ " new\nline " ] ] ) ,  " \ " new\nline\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) escapes Windows newlines " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " tsvFormatRows ( array ) escapes Unix newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ " new\nline " ] ] ) ,  " \ " new\nline\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) escapes Windows newlines " , function ( test )  {%NWL%test . deepEqual ( dsv . tsvFormatRows ( [ [ " new\rline " ] ] ) ,  " \ " new\rline\ " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " tsvFormatRows ( array ) escapes values containing delimiters " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . inDelta ( ease . easeBackIn ( 0 . 5 ) ,  - 0 . 087698 ) ;%NWL%test . inDelta ( ease . easeBackIn ( 0 . 6 ) ,  - 0 . 029028 ) ;%NWL%test . inDelta ( ease . easeBackIn ( 0 . 7 ) ,  + 0 . 092868 ) ;%NWL%test . inDelta ( ease . easeBackIn ( 0 . 8 ) ,  + 0 . 294198 ) ;%NWL%test . inDelta ( ease . easeBackIn ( 0 . 9 ) ,  + 0 . 591172 ) ;%NWL%test . inDelta ( ease . easeBackIn ( 1 . 0 ) ,  + 1 . 000000 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeBackIn ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeBackIn ( " . 9 " ) , ease . easeBackIn ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeBackOut ( 0 . 5 ) , backOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeBackOut ( 0 . 6 ) , backOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeBackOut ( 0 . 7 ) , backOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeBackOut ( 0 . 8 ) , backOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeBackOut ( 0 . 9 ) , backOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeBackOut ( 1 . 0 ) , backOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeBackOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeBackOut ( " . 9 " ) , ease . easeBackOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeBackInOut ( 0 . 5 ) , backInOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeBackInOut ( 0 . 6 ) , backInOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeBackInOut ( 0 . 7 ) , backInOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeBackInOut ( 0 . 8 ) , backInOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeBackInOut ( 0 . 9 ) , backInOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeBackInOut ( 1 . 0 ) , backInOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeBackInOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeBackInOut ( " . 9 " ) , ease . easeBackInOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeBounceIn ( 0 . 5 ) , 0 . 234375 ) ;%NWL%test . inDelta ( ease . easeBounceIn ( 0 . 6 ) , 0 . 090000 ) ;%NWL%test . inDelta ( ease . easeBounceIn ( 0 . 7 ) , 0 . 319375 ) ;%NWL%test . inDelta ( ease . easeBounceIn ( 0 . 8 ) , 0 . 697500 ) ;%NWL%test . inDelta ( ease . easeBounceIn ( 0 . 9 ) , 0 . 924375 ) ;%NWL%test . inDelta ( ease . easeBounceIn ( 1 . 0 ) , 1 . 000000 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeBounceIn ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeBounceIn ( " . 9 " ) , ease . easeBounceIn ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeBounceOut ( 0 . 5 ) , bounceOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeBounceOut ( 0 . 6 ) , bounceOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeBounceOut ( 0 . 7 ) , bounceOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeBounceOut ( 0 . 8 ) , bounceOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeBounceOut ( 0 . 9 ) , bounceOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeBounceOut ( 1 . 0 ) , bounceOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeBounceOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeBounceOut ( " . 9 " ) , ease . easeBounceOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeBounceInOut ( 0 . 5 ) , bounceInOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeBounceInOut ( 0 . 6 ) , bounceInOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeBounceInOut ( 0 . 7 ) , bounceInOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeBounceInOut ( 0 . 8 ) , bounceInOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeBounceInOut ( 0 . 9 ) , bounceInOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeBounceInOut ( 1 . 0 ) , bounceInOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeBounceInOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeBounceInOut ( " . 9 " ) , ease . easeBounceInOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeCircleIn ( 0 . 5 ) , 0 . 133975 ) ;%NWL%test . inDelta ( ease . easeCircleIn ( 0 . 6 ) , 0 . 200000 ) ;%NWL%test . inDelta ( ease . easeCircleIn ( 0 . 7 ) , 0 . 285857 ) ;%NWL%test . inDelta ( ease . easeCircleIn ( 0 . 8 ) , 0 . 400000 ) ;%NWL%test . inDelta ( ease . easeCircleIn ( 0 . 9 ) , 0 . 564110 ) ;%NWL%test . inDelta ( ease . easeCircleIn ( 1 . 0 ) , 1 . 000000 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeCircleIn ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeCircleIn ( " . 9 " ) , ease . easeCircleIn ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeCircleOut ( 0 . 5 ) , circleOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeCircleOut ( 0 . 6 ) , circleOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeCircleOut ( 0 . 7 ) , circleOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeCircleOut ( 0 . 8 ) , circleOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeCircleOut ( 0 . 9 ) , circleOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeCircleOut ( 1 . 0 ) , circleOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeCircleOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeCircleOut ( " . 9 " ) , ease . easeCircleOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeCircleInOut ( 0 . 5 ) , circleInOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeCircleInOut ( 0 . 6 ) , circleInOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeCircleInOut ( 0 . 7 ) , circleInOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeCircleInOut ( 0 . 8 ) , circleInOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeCircleInOut ( 0 . 9 ) , circleInOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeCircleInOut ( 1 . 0 ) , circleInOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeCircleInOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeCircleInOut ( " . 9 " ) , ease . easeCircleInOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeCubicIn ( 0 . 5 ) , 0 . 125 ) ;%NWL%test . inDelta ( ease . easeCubicIn ( 0 . 6 ) , 0 . 216 ) ;%NWL%test . inDelta ( ease . easeCubicIn ( 0 . 7 ) , 0 . 343 ) ;%NWL%test . inDelta ( ease . easeCubicIn ( 0 . 8 ) , 0 . 512 ) ;%NWL%test . inDelta ( ease . easeCubicIn ( 0 . 9 ) , 0 . 729 ) ;%NWL%test . inDelta ( ease . easeCubicIn ( 1 . 0 ) , 1 . 000 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeCubicIn ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeCubicIn ( " . 9 " ) , ease . easeCubicIn ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeCubicOut ( 0 . 5 ) , cubicOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeCubicOut ( 0 . 6 ) , cubicOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeCubicOut ( 0 . 7 ) , cubicOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeCubicOut ( 0 . 8 ) , cubicOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeCubicOut ( 0 . 9 ) , cubicOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeCubicOut ( 1 . 0 ) , cubicOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeCubicOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeCubicOut ( " . 9 " ) , ease . easeCubicOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeCubicInOut ( 0 . 5 ) , cubicInOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeCubicInOut ( 0 . 6 ) , cubicInOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeCubicInOut ( 0 . 7 ) , cubicInOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeCubicInOut ( 0 . 8 ) , cubicInOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeCubicInOut ( 0 . 9 ) , cubicInOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeCubicInOut ( 1 . 0 ) , cubicInOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeCubicInOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeCubicInOut ( " . 9 " ) , ease . easeCubicInOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeElasticIn ( 0 . 5 ) ,  - 0 . 015625 ) ;%NWL%test . inDelta ( ease . easeElasticIn ( 0 . 6 ) ,  - 0 . 031250 ) ;%NWL%test . inDelta ( ease . easeElasticIn ( 0 . 7 ) ,  0 . 125000 ) ;%NWL%test . inDelta ( ease . easeElasticIn ( 0 . 8 ) ,  - 0 . 125000 ) ;%NWL%test . inDelta ( ease . easeElasticIn ( 0 . 9 ) ,  - 0 . 250000 ) ;%NWL%test . inDelta ( ease . easeElasticIn ( 1 . 0 ) ,  1 . 000000 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeElasticIn ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeElasticIn ( " . 9 " ) , ease . easeElasticIn ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeElasticIn ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeElasticIn ( " . 9 " ) , ease . easeElasticIn ( 0 . 9 ) ) ;%NWL%test . strictEqual ( ease . easeElasticIn ( { valueOf: function ( )  { return 0 . 9; } } ) , ease . easeElasticIn ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeElasticIn ( t ) is the same as elasticIn . amplitude ( 1 ) . period ( 0 . 3 ) ( t ) " , function ( test )  {%NWL%test . equal ( ease . easeElasticIn ( 0 . 1 ) , ease . easeElasticIn . amplitude ( 1 ) . period ( 0 . 3 ) ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easeElasticIn ( 0 . 2 ) , ease . easeElasticIn . amplitude ( 1 ) . period ( 0 . 3 ) ( 0 . 2 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " easeElasticIn ( t ) is the same as elasticIn . amplitude ( 1 ) . period ( 0 . 3 ) ( t ) " , function ( test )  {%NWL%test . equal ( ease . easeElasticIn ( 0 . 1 ) , ease . easeElasticIn . amplitude ( 1 ) . period ( 0 . 3 ) ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easeElasticIn ( 0 . 2 ) , ease . easeElasticIn . amplitude ( 1 ) . period ( 0 . 3 ) ( 0 . 2 ) ) ;%NWL%test . equal ( ease . easeElasticIn ( 0 . 3 ) , ease . easeElasticIn . amplitude ( 1 ) . period ( 0 . 3 ) ( 0 . 3 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeElasticIn . amplitude ( a ) ( t ) is the same as elasticIn ( t ) if a <= 1 " , function ( test )  {%NWL%test . equal ( ease . easeElasticIn . amplitude ( - 1 . 0 ) ( 0 . 1 ) , ease . easeElasticIn ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easeElasticIn . amplitude ( + 0 . 4 ) ( 0 . 2 ) , ease . easeElasticIn ( 0 . 2 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeElasticIn . amplitude ( a ) ( t ) is the same as elasticIn ( t ) if a <= 1 " , function ( test )  {%NWL%test . equal ( ease . easeElasticIn . amplitude ( - 1 . 0 ) ( 0 . 1 ) , ease . easeElasticIn ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easeElasticIn . amplitude ( + 0 . 4 ) ( 0 . 2 ) , ease . easeElasticIn ( 0 . 2 ) ) ;%NWL%test . equal ( ease . easeElasticIn . amplitude ( + 0 . 8 ) ( 0 . 3 ) , ease . easeElasticIn ( 0 . 3 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeElasticIn . amplitude ( a ) . period ( p ) ( t ) coerces t , a and p to numbers " , function ( test )  {%NWL%test . strictEqual ( ease . easeElasticIn . amplitude ( " 1 . 3 " ) . period ( " 0 . 2 " ) ( " . 9 " ) , ease . easeElasticIn . amplitude ( 1 . 3 ) . period ( 0 . 2 ) ( . 9 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . inDelta ( ease . easeElasticOut ( 0 . 5 ) , elasticOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeElasticOut ( 0 . 6 ) , elasticOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeElasticOut ( 0 . 7 ) , elasticOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeElasticOut ( 0 . 8 ) , elasticOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeElasticOut ( 0 . 9 ) , elasticOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeElasticOut ( 1 . 0 ) , elasticOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeElasticOut . amplitude ( a ) . period ( p ) ( t ) coerces t , a and p to numbers " , function ( test )  {%NWL%test . strictEqual ( ease . easeElasticOut . amplitude ( " 1 . 3 " ) . period ( " 0 . 2 " ) ( " . 9 " ) , ease . easeElasticOut . amplitude ( 1 . 3 ) . period ( 0 . 2 ) ( . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeElasticInOut ( 0 . 5 ) , elasticInOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeElasticInOut ( 0 . 6 ) , elasticInOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeElasticInOut ( 0 . 7 ) , elasticInOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeElasticInOut ( 0 . 8 ) , elasticInOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeElasticInOut ( 0 . 9 ) , elasticInOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeElasticInOut ( 1 . 0 ) , elasticInOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeElasticInOut . amplitude ( a ) . period ( p ) ( t ) coerces t , a and p to numbers " , function ( test )  {%NWL%test . strictEqual ( ease . easeElasticInOut . amplitude ( " 1 . 3 " ) . period ( " 0 . 2 " ) ( " . 9 " ) , ease . easeElasticInOut . amplitude ( 1 . 3 ) . period ( 0 . 2 ) ( . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeExpIn ( 0 . 5 ) , 0 . 031250 ) ;%NWL%test . inDelta ( ease . easeExpIn ( 0 . 6 ) , 0 . 062500 ) ;%NWL%test . inDelta ( ease . easeExpIn ( 0 . 7 ) , 0 . 125000 ) ;%NWL%test . inDelta ( ease . easeExpIn ( 0 . 8 ) , 0 . 250000 ) ;%NWL%test . inDelta ( ease . easeExpIn ( 0 . 9 ) , 0 . 500000 ) ;%NWL%test . inDelta ( ease . easeExpIn ( 1 . 0 ) , 1 . 000000 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeExpIn ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeExpIn ( " . 9 " ) , ease . easeExpIn ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeExpOut ( 0 . 5 ) , expOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeExpOut ( 0 . 6 ) , expOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeExpOut ( 0 . 7 ) , expOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeExpOut ( 0 . 8 ) , expOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeExpOut ( 0 . 9 ) , expOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeExpOut ( 1 . 0 ) , expOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeExpOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeExpOut ( " . 9 " ) , ease . easeExpOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeExpInOut ( 0 . 5 ) , expInOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeExpInOut ( 0 . 6 ) , expInOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeExpInOut ( 0 . 7 ) , expInOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeExpInOut ( 0 . 8 ) , expInOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeExpInOut ( 0 . 9 ) , expInOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeExpInOut ( 1 . 0 ) , expInOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeExpInOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeExpInOut ( " . 9 " ) , ease . easeExpInOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeLinear ( 0 . 5 ) , 0 . 5 ) ;%NWL%test . inDelta ( ease . easeLinear ( 0 . 6 ) , 0 . 6 ) ;%NWL%test . inDelta ( ease . easeLinear ( 0 . 7 ) , 0 . 7 ) ;%NWL%test . inDelta ( ease . easeLinear ( 0 . 8 ) , 0 . 8 ) ;%NWL%test . inDelta ( ease . easeLinear ( 0 . 9 ) , 0 . 9 ) ;%NWL%test . inDelta ( ease . easeLinear ( 1 . 0 ) , 1 . 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeLinear ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeLinear ( " . 9 " ) , ease . easeLinear ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easePolyIn ( 0 . 5 ) , 0 . 125 ) ;%NWL%test . inDelta ( ease . easePolyIn ( 0 . 6 ) , 0 . 216 ) ;%NWL%test . inDelta ( ease . easePolyIn ( 0 . 7 ) , 0 . 343 ) ;%NWL%test . inDelta ( ease . easePolyIn ( 0 . 8 ) , 0 . 512 ) ;%NWL%test . inDelta ( ease . easePolyIn ( 0 . 9 ) , 0 . 729 ) ;%NWL%test . inDelta ( ease . easePolyIn ( 1 . 0 ) , 1 . 000 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyIn ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easePolyIn ( " . 9 " ) , ease . easePolyIn ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyIn ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easePolyIn ( " . 9 " ) , ease . easePolyIn ( 0 . 9 ) ) ;%NWL%test . strictEqual ( ease . easePolyIn ( { valueOf: function ( )  { return 0 . 9; } } ) , ease . easePolyIn ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyIn ( t ) is the same as polyIn . exponent ( 3 ) ( t ) " , function ( test )  {%NWL%test . equal ( ease . easePolyIn ( 0 . 1 ) , ease . easePolyIn . exponent ( 3 ) ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easePolyIn ( 0 . 2 ) , ease . easePolyIn . exponent ( 3 ) ( 0 . 2 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyIn ( t ) is the same as polyIn . exponent ( 3 ) ( t ) " , function ( test )  {%NWL%test . equal ( ease . easePolyIn ( 0 . 1 ) , ease . easePolyIn . exponent ( 3 ) ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easePolyIn ( 0 . 2 ) , ease . easePolyIn . exponent ( 3 ) ( 0 . 2 ) ) ;%NWL%test . equal ( ease . easePolyIn ( 0 . 3 ) , ease . easePolyIn . exponent ( 3 ) ( 0 . 3 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyIn . exponent ( e ) ( t ) coerces t and e to numbers " , function ( test )  {%NWL%test . equal ( ease . easePolyIn . exponent ( " 1 . 3 " ) ( " . 9 " ) , ease . easePolyIn . exponent ( 1 . 3 ) ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . inDelta ( ease . easePolyIn . exponent ( 2 . 5 ) ( 0 . 5 ) , 0 . 176777 ) ;%NWL%test . inDelta ( ease . easePolyIn . exponent ( 2 . 5 ) ( 0 . 6 ) , 0 . 278855 ) ;%NWL%test . inDelta ( ease . easePolyIn . exponent ( 2 . 5 ) ( 0 . 7 ) , 0 . 409963 ) ;%NWL%test . inDelta ( ease . easePolyIn . exponent ( 2 . 5 ) ( 0 . 8 ) , 0 . 572433 ) ;%NWL%test . inDelta ( ease . easePolyIn . exponent ( 2 . 5 ) ( 0 . 9 ) , 0 . 768433 ) ;%NWL%test . inDelta ( ease . easePolyIn . exponent ( 2 . 5 ) ( 1 . 0 ) , 1 . 000000 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyOut . exponent ( e ) ( t ) coerces t and e to numbers " , function ( test )  {%NWL%test . equal ( ease . easePolyOut . exponent ( " 1 . 3 " ) ( " . 9 " ) , ease . easePolyOut . exponent ( 1 . 3 ) ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyOut . exponent ( e ) ( t ) coerces t and e to numbers " , function ( test )  {%NWL%test . equal ( ease . easePolyOut . exponent ( " 1 . 3 " ) ( " . 9 " ) , ease . easePolyOut . exponent ( 1 . 3 ) ( 0 . 9 ) ) ;%NWL%test . equal ( ease . easePolyOut . exponent ( { valueOf: function ( )  { return 1 . 3; } } ) ( { valueOf: function ( )  { return 0 . 9; } } ) , ease . easePolyOut . exponent ( 1 . 3 ) ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyOut ( t ) is the same as polyOut . exponent ( 3 ) ( t ) " , function ( test )  {%NWL%test . equal ( ease . easePolyOut ( 0 . 1 ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easePolyOut ( 0 . 2 ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 2 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " easePolyOut ( t ) is the same as polyOut . exponent ( 3 ) ( t ) " , function ( test )  {%NWL%test . equal ( ease . easePolyOut ( 0 . 1 ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easePolyOut ( 0 . 2 ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 2 ) ) ;%NWL%test . equal ( ease . easePolyOut ( 0 . 3 ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 3 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyOut ( t , null ) is the same as polyOut . exponent ( 3 ) ( t ) " , function ( test )  {%NWL%test . equal ( ease . easePolyOut ( 0 . 1 , null ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easePolyOut ( 0 . 2 , null ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 2 ) ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " easePolyOut ( t , null ) is the same as polyOut . exponent ( 3 ) ( t ) " , function ( test )  {%NWL%test . equal ( ease . easePolyOut ( 0 . 1 , null ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easePolyOut ( 0 . 2 , null ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 2 ) ) ;%NWL%test . equal ( ease . easePolyOut ( 0 . 3 , null ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 3 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyOut ( t , undefined ) is the same as polyOut . exponent ( 3 ) ( t ) " , function ( test )  {%NWL%test . equal ( ease . easePolyOut ( 0 . 1 , undefined ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easePolyOut ( 0 . 2 , undefined ) , ease . easePolyOut . exponent ( 3 ) ( 0 . 2 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . inDelta ( ease . easePolyOut . exponent ( 2 . 5 ) ( 0 . 5 ) , polyOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easePolyOut . exponent ( 2 . 5 ) ( 0 . 6 ) , polyOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easePolyOut . exponent ( 2 . 5 ) ( 0 . 7 ) , polyOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easePolyOut . exponent ( 2 . 5 ) ( 0 . 8 ) , polyOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easePolyOut . exponent ( 2 . 5 ) ( 0 . 9 ) , polyOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easePolyOut . exponent ( 2 . 5 ) ( 1 . 0 ) , polyOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyInOut . exponent ( e ) ( t ) coerces t and e to numbers " , function ( test )  {%NWL%test . equal ( ease . easePolyInOut . exponent ( " 1 . 3 " ) ( " . 9 " ) , ease . easePolyInOut . exponent ( 1 . 3 ) ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyInOut . exponent ( e ) ( t ) coerces t and e to numbers " , function ( test )  {%NWL%test . equal ( ease . easePolyInOut . exponent ( " 1 . 3 " ) ( " . 9 " ) , ease . easePolyInOut . exponent ( 1 . 3 ) ( 0 . 9 ) ) ;%NWL%test . equal ( ease . easePolyInOut . exponent ( { valueOf: function ( )  { return 1 . 3; } } ) ( { valueOf: function ( )  { return 0 . 9; } } ) , ease . easePolyInOut . exponent ( 1 . 3 ) ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easePolyInOut ( t ) is the same as polyInOut . exponent ( 3 ) ( t ) " , function ( test )  {%NWL%test . equal ( ease . easePolyInOut ( 0 . 1 ) , ease . easePolyInOut . exponent ( 3 ) ( 0 . 1 ) ) ;%NWL%test . equal ( ease . easePolyInOut ( 0 . 2 ) , ease . easePolyInOut . exponent ( 3 ) ( 0 . 2 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . inDelta ( ease . easeQuadIn ( 0 . 5 ) , 0 . 25 ) ;%NWL%test . inDelta ( ease . easeQuadIn ( 0 . 6 ) , 0 . 36 ) ;%NWL%test . inDelta ( ease . easeQuadIn ( 0 . 7 ) , 0 . 49 ) ;%NWL%test . inDelta ( ease . easeQuadIn ( 0 . 8 ) , 0 . 64 ) ;%NWL%test . inDelta ( ease . easeQuadIn ( 0 . 9 ) , 0 . 81 ) ;%NWL%test . inDelta ( ease . easeQuadIn ( 1 . 0 ) , 1 . 00 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeQuadIn ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeQuadIn ( " . 9 " ) , ease . easeQuadIn ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeQuadOut ( 0 . 5 ) , quadOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeQuadOut ( 0 . 6 ) , quadOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeQuadOut ( 0 . 7 ) , quadOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeQuadOut ( 0 . 8 ) , quadOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeQuadOut ( 0 . 9 ) , quadOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeQuadOut ( 1 . 0 ) , quadOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeQuadOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeQuadOut ( " . 9 " ) , ease . easeQuadOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeQuadInOut ( 0 . 5 ) , quadInOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeQuadInOut ( 0 . 6 ) , quadInOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeQuadInOut ( 0 . 7 ) , quadInOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeQuadInOut ( 0 . 8 ) , quadInOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeQuadInOut ( 0 . 9 ) , quadInOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeQuadInOut ( 1 . 0 ) , quadInOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeQuadInOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeQuadInOut ( " . 9 " ) , ease . easeQuadInOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeSinIn ( 0 . 5 ) , 0 . 292893 ) ;%NWL%test . inDelta ( ease . easeSinIn ( 0 . 6 ) , 0 . 412215 ) ;%NWL%test . inDelta ( ease . easeSinIn ( 0 . 7 ) , 0 . 546010 ) ;%NWL%test . inDelta ( ease . easeSinIn ( 0 . 8 ) , 0 . 690983 ) ;%NWL%test . inDelta ( ease . easeSinIn ( 0 . 9 ) , 0 . 843566 ) ;%NWL%test . inDelta ( ease . easeSinIn ( 1 . 0 ) , 1 . 000000 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeSinIn ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeSinIn ( " . 9 " ) , ease . easeSinIn ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeSinOut ( 0 . 5 ) , sinOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeSinOut ( 0 . 6 ) , sinOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeSinOut ( 0 . 7 ) , sinOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeSinOut ( 0 . 8 ) , sinOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeSinOut ( 0 . 9 ) , sinOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeSinOut ( 1 . 0 ) , sinOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeSinOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeSinOut ( " . 9 " ) , ease . easeSinOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( ease . easeSinInOut ( 0 . 5 ) , sinInOut ( 0 . 5 ) ) ;%NWL%test . inDelta ( ease . easeSinInOut ( 0 . 6 ) , sinInOut ( 0 . 6 ) ) ;%NWL%test . inDelta ( ease . easeSinInOut ( 0 . 7 ) , sinInOut ( 0 . 7 ) ) ;%NWL%test . inDelta ( ease . easeSinInOut ( 0 . 8 ) , sinInOut ( 0 . 8 ) ) ;%NWL%test . inDelta ( ease . easeSinInOut ( 0 . 9 ) , sinInOut ( 0 . 9 ) ) ;%NWL%test . inDelta ( ease . easeSinInOut ( 1 . 0 ) , sinInOut ( 1 . 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " easeSinInOut ( t ) coerces t to a number " , function ( test )  {%NWL%test . strictEqual ( ease . easeSinInOut ( " . 9 " ) , ease . easeSinInOut ( 0 . 9 ) ) ;%NWL%test . end ( ) ;%NWL%6
node = nodes [ i ] ;%NWL%ri = radii [ node . index ] , ri2 = ri * ri;%NWL%xi = node . x + node . vx;%NWL%yi = node . y + node . vy;%NWL%tree . visit ( apply ) ;%NWL%}%NWL%}%NWL%function apply ( quad , x0 , y0 , x1 , y1 )  {%NWL%var data = quad . data , rj = quad . r , r = ri + rj;%NWL%if ( data )  {%NWL%var x = xi - data . x - data . vx ,%NWL%8
var tape = require ( " tape " ) ,%NWL%format = require ( " . . / " ) ;%NWL%tape ( " format ( specifier ) ( number ) returns a string " , function ( test )  {%NWL%test . equal ( typeof format . format ( " d " ) ( 0 ) ,  " string " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( specifier ) . toString ( ) returns the normalized specifier " , function ( test )  {%NWL%test . end ( ) ;%NWL%4
test . equal ( typeof format . format ( " d " ) ( 0 ) ,  " string " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( specifier ) . toString ( ) returns the normalized specifier " , function ( test )  {%NWL%test . equal ( format . format ( " d " )  +  " " ,  " > - d " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( specifier ) throws an error for invalid formats " , function ( test )  {%NWL%test . throws ( function ( )  { format . format ( " foo " ) ; } ,  / invalid format: foo / ) ;%NWL%test . throws ( function ( )  { format . format ( " . - 2s " ) ; } ,  / invalid format: \ . - 2s / ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( specifier ) throws an error for invalid formats " , function ( test )  {%NWL%test . throws ( function ( )  { format . format ( " foo " ) ; } ,  / invalid format: foo / ) ;%NWL%test . throws ( function ( )  { format . format ( " . - 2s " ) ; } ,  / invalid format: \ . - 2s / ) ;%NWL%test . throws ( function ( )  { format . format ( " . f " ) ; } ,  / invalid format: \ . f / ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , . \ " ) unreasonable precision values are clamped to reasonable values " , function ( test )  {%NWL%test . equal ( format . format ( " . 30f " ) ( 0 ) ,  " 0 . 00000000000000000000 " ) ;%NWL%test . end ( ) ;%NWL%0
test . throws ( function ( )  { format . format ( " . f " ) ; } ,  / invalid format: \ . f / ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , . \ " ) unreasonable precision values are clamped to reasonable values " , function ( test )  {%NWL%test . equal ( format . format ( " . 30f " ) ( 0 ) ,  " 0 . 00000000000000000000 " ) ;%NWL%test . equal ( format . format ( " . 0g " ) ( 1 ) ,  " 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " s\ " ) handles very small and very large values " , function ( test )  {%NWL%test . equal ( format . format ( " s " ) ( Number . MIN_VALUE ) ,  " 0 . 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005y " ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( f ( 4 . 2 ) ,  " 420% " ) ;%NWL%test . equal ( f ( - . 042 ) ,  " - 4% " ) ;%NWL%test . equal ( f ( - . 42 ) ,  " - 42% " ) ;%NWL%test . equal ( f ( - 4 . 2 ) ,  " - 420% " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " . %\ " ) can output a percentage with precision " , function ( test )  {%NWL%var f = format . format ( " . 1% " ) ;%NWL%test . equal ( f ( . 234 ) ,  " 23 . 4% " ) ;%NWL%var f = format . format ( " . 2% " ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " format ( \ " . %\ " ) can output a percentage with precision " , function ( test )  {%NWL%var f = format . format ( " . 1% " ) ;%NWL%test . equal ( f ( . 234 ) ,  " 23 . 4% " ) ;%NWL%var f = format . format ( " . 2% " ) ;%NWL%test . equal ( f ( . 234 ) ,  " 23 . 40% " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " %\ " ) fill respects suffix " , function ( test )  {%NWL%test . equal ( format . format ( " 020 . 0% " ) ( 42 ) ,  " 0000000000000004200% " ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " %\ " ) fill respects suffix " , function ( test )  {%NWL%test . equal ( format . format ( " 020 . 0% " ) ( 42 ) ,  " 0000000000000004200% " ) ;%NWL%test . equal ( format . format ( " 20 . 0% " ) ( 42 ) ,  "        4200% " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " ^%\ " ) align center puts suffix adjacent to number " , function ( test )  {%NWL%test . equal ( format . format ( " ^21 . 0% " ) ( . 42 ) ,   "     42%     " ) ;%NWL%test . equal ( format . format ( " ^21 , . 0% " ) ( 422 ) ,   "    42 , 200%    " ) ;%NWL%test . end ( ) ;%NWL%0
var tape = require ( " tape " ) ,%NWL%format = require ( " . . / " ) ;%NWL%tape ( " format ( \ " b\ " ) binary " , function ( test )  {%NWL%test . equal ( format . format ( " b " ) ( 10 ) ,  " 1010 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " #b\ " ) binary with prefix " , function ( test )  {%NWL%test . end ( ) ;%NWL%4
test . equal ( f ( - 4 ) ,  " - 0 , 000 , 004 " ) ;%NWL%test . equal ( f ( - 42 ) ,  " - 0 , 000 , 042 " ) ;%NWL%test . equal ( f ( - 4200000 ) ,  " - 4 , 200 , 000 " ) ;%NWL%test . equal ( f ( - 42000000 ) ,  " - 42 , 000 , 000 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " d\ " ) always uses zero precision " , function ( test )  {%NWL%var f = format . format ( " . 2d " ) ;%NWL%test . equal ( f ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( f ( 42 ) ,  " 42 " ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " format ( \ " d\ " ) always uses zero precision " , function ( test )  {%NWL%var f = format . format ( " . 2d " ) ;%NWL%test . equal ( f ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( f ( 42 ) ,  " 42 " ) ;%NWL%test . equal ( f ( - 4 . 2 ) ,  " - 4 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " d\ " ) rounds non - integers " , function ( test )  {%NWL%var f = format . format ( " d " ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( format . format ( " 015 , d " ) ( 1e21 ) ,  " 000 , 000 , 001e + 21 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " 0 , d\ " ) can group thousands and zero fill with overflow " , function ( test )  {%NWL%test . equal ( format . format ( " 01 , d " ) ( 1 ) ,  " 1 " ) ;%NWL%test . equal ( format . format ( " 01 , d " ) ( 1 ) ,  " 1 " ) ;%NWL%test . equal ( format . format ( " 02 , d " ) ( 12 ) ,  " 12 " ) ;%NWL%test . equal ( format . format ( " 03 , d " ) ( 123 ) ,  " 123 " ) ;%NWL%test . equal ( format . format ( " 05 , d " ) ( 12345 ) ,  " 12 , 345 " ) ;%NWL%test . equal ( format . format ( " 08 , d " ) ( 12345678 ) ,  " 12 , 345 , 678 " ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , d\ " ) can group thousands and space fill " , function ( test )  {%NWL%test . equal ( format . format ( " 1 , d " ) ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " 1 , d " ) ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " 2 , d " ) ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " 3 , d " ) ( 0 ) ,  "  0 " ) ;%NWL%test . equal ( format . format ( " 5 , d " ) ( 0 ) ,  "   0 " ) ;%NWL%test . equal ( format . format ( " 8 , d " ) ( 0 ) ,  "    0 " ) ;%NWL%test . equal ( format . format ( " 13 , d " ) ( 0 ) ,  "       0 " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( format . format ( " 21 , d " ) ( 0 ) ,  "           0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , d\ " ) can group thousands and space fill with overflow " , function ( test )  {%NWL%test . equal ( format . format ( " 1 , d " ) ( 1 ) ,  " 1 " ) ;%NWL%test . equal ( format . format ( " 1 , d " ) ( 1 ) ,  " 1 " ) ;%NWL%test . equal ( format . format ( " 2 , d " ) ( 12 ) ,  " 12 " ) ;%NWL%test . equal ( format . format ( " 3 , d " ) ( 123 ) ,  " 123 " ) ;%NWL%test . equal ( format . format ( " 5 , d " ) ( 12345 ) ,  " 12 , 345 " ) ;%NWL%test . equal ( format . format ( " 8 , d " ) ( 12345678 ) ,  " 12 , 345 , 678 " ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " <d\ " ) align left " , function ( test )  {%NWL%test . equal ( format . format ( " <1 , d " ) ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " <1 , d " ) ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " <2 , d " ) ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " <3 , d " ) ( 0 ) ,  " 0  " ) ;%NWL%test . equal ( format . format ( " <5 , d " ) ( 0 ) ,  " 0   " ) ;%NWL%test . equal ( format . format ( " <8 , d " ) ( 0 ) ,  " 0    " ) ;%NWL%test . equal ( format . format ( " <13 , d " ) ( 0 ) ,  " 0       " ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " - , d\ " ) explicitly only use a sign for negative numbers " , function ( test )  {%NWL%test . equal ( format . format ( " - 1 , d " ) ( - 1 ) ,  " - 1 " ) ;%NWL%test . equal ( format . format ( " - 1 , d " ) ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " - 2 , d " ) ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " - 3 , d " ) ( 0 ) ,  "  0 " ) ;%NWL%test . equal ( format . format ( " - 5 , d " ) ( 0 ) ,  "   0 " ) ;%NWL%test . equal ( format . format ( " - 8 , d " ) ( 0 ) ,  "    0 " ) ;%NWL%test . equal ( format . format ( " - 13 , d " ) ( 0 ) ,  "       0 " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( format . format ( " - 2 , d " ) ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " - 3 , d " ) ( 0 ) ,  "  0 " ) ;%NWL%test . equal ( format . format ( " - 5 , d " ) ( 0 ) ,  "   0 " ) ;%NWL%test . equal ( format . format ( " - 8 , d " ) ( 0 ) ,  "    0 " ) ;%NWL%test . equal ( format . format ( " - 13 , d " ) ( 0 ) ,  "       0 " ) ;%NWL%test . equal ( format . format ( " - 21 , d " ) ( 0 ) ,  "           0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " d\ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " 1d " ) ( - 0 ) ,  " 0 " ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( f ( - 4 ) ,  " - 4 . 000000e + 0 " ) ;%NWL%test . equal ( f ( - 42 ) ,  " - 4 . 200000e + 1 " ) ;%NWL%test . equal ( f ( - 4200000 ) ,  " - 4 . 200000e + 6 " ) ;%NWL%test . equal ( f ( - 42000000 ) ,  " - 4 . 200000e + 7 " ) ;%NWL%test . equal ( format . format ( " . 0e " ) ( 42 ) ,  " 4e + 1 " )%NWL%test . equal ( format . format ( " . 3e " ) ( 42 ) ,  " 4 . 200e + 1 " )%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " e\ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " 1e " ) ( - 0 ) ,  " 0 . 000000e + 0 " ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( format . format ( " . 0e " ) ( 42 ) ,  " 4e + 1 " )%NWL%test . equal ( format . format ( " . 3e " ) ( 42 ) ,  " 4 . 200e + 1 " )%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " e\ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " 1e " ) ( - 0 ) ,  " 0 . 000000e + 0 " ) ;%NWL%test . equal ( format . format ( " 1e " ) ( - 1e - 12 ) ,  " - 1 . 000000e - 12 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , e\ " ) does not group Infinity " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . equal ( format . format ( " . 3f " ) ( 100 ) ,  " 100 . 000 " ) ;%NWL%test . equal ( format . format ( " . 5f " ) ( 100 ) ,  " 100 . 00000 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " + $ , f\ " ) can output a currency with comma - grouping and sign " , function ( test )  {%NWL%var f = format . format ( " + $ , . 2f " ) ;%NWL%test . equal ( f ( 0 ) ,  " + $0 . 00 " ) ;%NWL%test . equal ( f ( 0 . 429 ) ,  " + $0 . 43 " ) ;%NWL%test . equal ( f ( - 0 . 429 ) ,  " - $0 . 43 " ) ;%NWL%test . equal ( f ( - 1 ) ,  " - $1 . 00 " ) ;%NWL%test . end ( ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , . f\ " ) can group thousands , space fill , and round to significant digits " , function ( test )  {%NWL%test . equal ( format . format ( " 10 , . 1f " ) ( 123456 . 49 ) ,  " 123 , 456 . 5 " ) ;%NWL%test . equal ( format . format ( " 10 , . 2f " ) ( 1234567 . 449 ) ,  " 1 , 234 , 567 . 45 " ) ;%NWL%test . equal ( format . format ( " 10 , . 3f " ) ( 12345678 . 4449 ) ,  " 12 , 345 , 678 . 445 " ) ;%NWL%test . equal ( format . format ( " 10 , . 5f " ) ( 123456789 . 444449 ) ,  " 123 , 456 , 789 . 44445 " ) ;%NWL%test . equal ( format . format ( " 10 , . 1f " ) ( 123456 ) ,  " 123 , 456 . 0 " ) ;%NWL%test . equal ( format . format ( " 10 , . 2f " ) ( 1234567 ) ,  " 1 , 234 , 567 . 00 " ) ;%NWL%test . equal ( format . format ( " 10 , . 3f " ) ( 12345678 ) ,  " 12 , 345 , 678 . 000 " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( format . format ( " 10 , . 2f " ) ( 1234567 . 449 ) ,  " 1 , 234 , 567 . 45 " ) ;%NWL%test . equal ( format . format ( " 10 , . 3f " ) ( 12345678 . 4449 ) ,  " 12 , 345 , 678 . 445 " ) ;%NWL%test . equal ( format . format ( " 10 , . 5f " ) ( 123456789 . 444449 ) ,  " 123 , 456 , 789 . 44445 " ) ;%NWL%test . equal ( format . format ( " 10 , . 1f " ) ( 123456 ) ,  " 123 , 456 . 0 " ) ;%NWL%test . equal ( format . format ( " 10 , . 2f " ) ( 1234567 ) ,  " 1 , 234 , 567 . 00 " ) ;%NWL%test . equal ( format . format ( " 10 , . 3f " ) ( 12345678 ) ,  " 12 , 345 , 678 . 000 " ) ;%NWL%test . equal ( format . format ( " 10 , . 5f " ) ( 123456789 ) ,  " 123 , 456 , 789 . 00000 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " f\ " ) can display integers in fixed - point notation " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . equal ( format . format ( " 10 , . 3f " ) ( 12345678 ) ,  " 12 , 345 , 678 . 000 " ) ;%NWL%test . equal ( format . format ( " 10 , . 5f " ) ( 123456789 ) ,  " 123 , 456 , 789 . 00000 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " f\ " ) can display integers in fixed - point notation " , function ( test )  {%NWL%test . equal ( format . format ( " f " ) ( 42 ) ,  " 42 . 000000 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " f\ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " f " ) ( - 0 ) ,  " 0 . 000000 " ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " format ( \ " f\ " ) can display integers in fixed - point notation " , function ( test )  {%NWL%test . equal ( format . format ( " f " ) ( 42 ) ,  " 42 . 000000 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " f\ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " f " ) ( - 0 ) ,  " 0 . 000000 " ) ;%NWL%test . equal ( format . format ( " f " ) ( - 1e - 12 ) ,  " 0 . 000000 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " f\ " ) can format negative infinity " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " format ( \ " f\ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " f " ) ( - 0 ) ,  " 0 . 000000 " ) ;%NWL%test . equal ( format . format ( " f " ) ( - 1e - 12 ) ,  " 0 . 000000 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " f\ " ) can format negative infinity " , function ( test )  {%NWL%test . equal ( format . format ( " f " ) ( - Infinity ) ,  " - Infinity " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , f\ " ) does not group Infinity " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " n\ " ) uses zero padding " , function ( test )  {%NWL%test . equal ( format . format ( " 01 . 0n " ) ( 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " 02 . 0n " ) ( 0 ) ,  " 00 " ) ;%NWL%test . equal ( format . format ( " 03 . 0n " ) ( 0 ) ,  " 000 " ) ;%NWL%test . equal ( format . format ( " 05 . 0n " ) ( 0 ) ,  " 0 , 000 " ) ;%NWL%test . equal ( format . format ( " 08 . 0n " ) ( 0 ) ,  " 0 , 000 , 000 " ) ;%NWL%test . equal ( format . format ( " 013 . 0n " ) ( 0 ) ,  " 0 , 000 , 000 , 000 " ) ;%NWL%test . equal ( format . format ( " 021 . 0n " ) ( 0 ) ,  " 0 , 000 , 000 , 000 , 000 , 000 " ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " . [ precision ] \ " ) does not trim significant zeros " , function ( test )  {%NWL%test . equal ( format . format ( " . 5 " ) ( 10 ) ,  " 10 " ) ;%NWL%test . equal ( format . format ( " . 5 " ) ( 100 ) ,  " 100 " ) ;%NWL%test . equal ( format . format ( " . 5 " ) ( 1000 ) ,  " 1000 " ) ;%NWL%test . equal ( format . format ( " . 5 " ) ( 21010 ) ,  " 21010 " ) ;%NWL%test . equal ( format . format ( " . 5 " ) ( 1 . 10001 ) ,  " 1 . 1 " ) ;%NWL%test . equal ( format . format ( " . 5 " ) ( 1 . 10001e6 ) ,  " 1 . 1e + 6 " ) ;%NWL%test . equal ( format . format ( " . 6 " ) ( 1 . 10001 ) ,  " 1 . 10001 " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( format . format ( " . 5 " ) ( 1 . 10001 ) ,  " 1 . 1 " ) ;%NWL%test . equal ( format . format ( " . 5 " ) ( 1 . 10001e6 ) ,  " 1 . 1e + 6 " ) ;%NWL%test . equal ( format . format ( " . 6 " ) ( 1 . 10001 ) ,  " 1 . 10001 " ) ;%NWL%test . equal ( format . format ( " . 6 " ) ( 1 . 10001e6 ) ,  " 1 . 10001e + 6 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " . [ precision ] \ " ) also trims the decimal point if there are only insignificant zeros " , function ( test )  {%NWL%test . equal ( format . format ( " . 5 " ) ( 1 . 00001 ) ,  " 1 " ) ;%NWL%test . equal ( format . format ( " . 5 " ) ( 1 . 00001e6 ) ,  " 1e + 6 " ) ;%NWL%test . equal ( format . format ( " . 6 " ) ( 1 . 00001 ) ,  " 1 . 00001 " ) ;%NWL%test . end ( ) ;%NWL%4
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " $\ " ) can output a currency " , function ( test )  {%NWL%var f = format . format ( " $ " ) ;%NWL%test . equal ( f ( 0 ) ,  " $0 " ) ;%NWL%test . equal ( f ( . 042 ) ,  " $0 . 042 " ) ;%NWL%test . equal ( f ( . 42 ) ,  " $0 . 42 " ) ;%NWL%test . equal ( f ( 4 . 2 ) ,  " $4 . 2 " ) ;%NWL%test . equal ( f ( - . 042 ) ,  " - $0 . 042 " ) ;%NWL%test . equal ( f ( - . 42 ) ,  " - $0 . 42 " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( f ( 0 ) ,  " $0 " ) ;%NWL%test . equal ( f ( . 042 ) ,  " $0 . 042 " ) ;%NWL%test . equal ( f ( . 42 ) ,  " $0 . 42 " ) ;%NWL%test . equal ( f ( 4 . 2 ) ,  " $4 . 2 " ) ;%NWL%test . equal ( f ( - . 042 ) ,  " - $0 . 042 " ) ;%NWL%test . equal ( f ( - . 42 ) ,  " - $0 . 42 " ) ;%NWL%test . equal ( f ( - 4 . 2 ) ,  " - $4 . 2 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " ( $\ " ) can output a currency with parentheses for negative values " , function ( test )  {%NWL%test . equal ( f ( 0 ) ,  " $0 " ) ;%NWL%0
test . equal ( f ( . 042 ) ,  " $0 . 042 " ) ;%NWL%test . equal ( f ( . 42 ) ,  " $0 . 42 " ) ;%NWL%test . equal ( f ( 4 . 2 ) ,  " $4 . 2 " ) ;%NWL%test . equal ( f ( - . 042 ) ,  " - $0 . 042 " ) ;%NWL%test . equal ( f ( - . 42 ) ,  " - $0 . 42 " ) ;%NWL%test . equal ( f ( - 4 . 2 ) ,  " - $4 . 2 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " ( $\ " ) can output a currency with parentheses for negative values " , function ( test )  {%NWL%var f = format . format ( " ( $ " ) ;%NWL%test . equal ( f ( . 042 ) ,  " $0 . 042 " ) ;%NWL%0
test . equal ( f ( . 42 ) ,  " $0 . 42 " ) ;%NWL%test . equal ( f ( 4 . 2 ) ,  " $4 . 2 " ) ;%NWL%test . equal ( f ( - . 042 ) ,  " - $0 . 042 " ) ;%NWL%test . equal ( f ( - . 42 ) ,  " - $0 . 42 " ) ;%NWL%test . equal ( f ( - 4 . 2 ) ,  " - $4 . 2 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " ( $\ " ) can output a currency with parentheses for negative values " , function ( test )  {%NWL%var f = format . format ( " ( $ " ) ;%NWL%test . equal ( f ( 0 ) ,  " $0 " ) ;%NWL%test . equal ( f ( . 42 ) ,  " $0 . 42 " ) ;%NWL%0
test . equal ( f ( 4 . 2 ) ,  " $4 . 2 " ) ;%NWL%test . equal ( f ( - . 042 ) ,  " - $0 . 042 " ) ;%NWL%test . equal ( f ( - . 42 ) ,  " - $0 . 42 " ) ;%NWL%test . equal ( f ( - 4 . 2 ) ,  " - $4 . 2 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " ( $\ " ) can output a currency with parentheses for negative values " , function ( test )  {%NWL%var f = format . format ( " ( $ " ) ;%NWL%test . equal ( f ( 0 ) ,  " $0 " ) ;%NWL%test . equal ( f ( . 042 ) ,  " $0 . 042 " ) ;%NWL%test . equal ( f ( 4 . 2 ) ,  " $4 . 2 " ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " ( $\ " ) can output a currency with parentheses for negative values " , function ( test )  {%NWL%var f = format . format ( " ( $ " ) ;%NWL%test . equal ( f ( 0 ) ,  " $0 " ) ;%NWL%test . equal ( f ( . 042 ) ,  " $0 . 042 " ) ;%NWL%test . equal ( f ( . 42 ) ,  " $0 . 42 " ) ;%NWL%test . equal ( f ( 4 . 2 ) ,  " $4 . 2 " ) ;%NWL%test . equal ( f ( - . 042 ) ,  " ( $0 . 042 ) " ) ;%NWL%test . equal ( f ( - . 42 ) ,  " ( $0 . 42 ) " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( f ( 0 ) ,  " $0 " ) ;%NWL%test . equal ( f ( . 042 ) ,  " $0 . 042 " ) ;%NWL%test . equal ( f ( . 42 ) ,  " $0 . 42 " ) ;%NWL%test . equal ( f ( 4 . 2 ) ,  " $4 . 2 " ) ;%NWL%test . equal ( f ( - . 042 ) ,  " ( $0 . 042 ) " ) ;%NWL%test . equal ( f ( - . 42 ) ,  " ( $0 . 42 ) " ) ;%NWL%test . equal ( f ( - 4 . 2 ) ,  " ( $4 . 2 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " \ " ) can format negative zero as zero " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . equal ( f ( - . 042 ) ,  " ( $0 . 042 ) " ) ;%NWL%test . equal ( f ( - . 42 ) ,  " ( $0 . 42 ) " ) ;%NWL%test . equal ( f ( - 4 . 2 ) ,  " ( $4 . 2 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " \ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " " ) ( - 0 ) ,  " 0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " \ " ) can format negative infinity " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
var tape = require ( " tape " ) ,%NWL%format = require ( " . . / " ) ;%NWL%tape ( " format ( \ " o\ " ) octal " , function ( test )  {%NWL%test . equal ( format . format ( " o " ) ( 10 ) ,  " 12 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " #o\ " ) octal with prefix " , function ( test )  {%NWL%test . end ( ) ;%NWL%4
test . equal ( format . format ( " . 2r " ) ( . 0000000129 ) ,  " 0 . 000000013 " ) ;%NWL%test . equal ( format . format ( " . 2r " ) ( . 00000000129 ) ,  " 0 . 0000000013 " ) ;%NWL%test . equal ( format . format ( " . 3r " ) ( . 00000000129 ) ,  " 0 . 00000000129 " ) ;%NWL%test . equal ( format . format ( " . 4r " ) ( . 00000000129 ) ,  " 0 . 000000001290 " ) ;%NWL%test . equal ( format . format ( " . 10r " ) ( . 9999999999 ) ,  " 0 . 9999999999 " ) ;%NWL%test . equal ( format . format ( " . 15r " ) ( . 999999999999999 ) ,  " 0 . 999999999999999 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " r\ " ) can round very small numbers " , function ( test )  {%NWL%var f = format . format ( " . 2r " ) ;%NWL%test . end ( ) ;%NWL%6
var tape = require ( " tape " ) ,%NWL%format = require ( " . . / " ) ;%NWL%tape ( " format ( \ " s\ " ) outputs SI - prefix notation with default precision 6 " , function ( test )  {%NWL%var f = format . format ( " s " ) ;%NWL%test . equal ( f ( 0 ) ,  " 0 . 00000 " ) ;%NWL%test . equal ( f ( 1 ) ,  " 1 . 00000 " ) ;%NWL%test . equal ( f ( 10 ) ,  " 10 . 0000 " ) ;%NWL%test . equal ( f ( 100 ) ,  " 100 . 000 " ) ;%NWL%test . equal ( f ( 999 . 5 ) ,  " 999 . 500 " ) ;%NWL%test . equal ( f ( 999500 ) ,  " 999 . 500k " ) ;%NWL%test . equal ( f ( 100 ) ,  " 100 . 000 " ) ;%NWL%7
test . equal ( f ( 1e + 1 ) ,  " 10 . 00 " ) ;%NWL%test . equal ( f ( 1e + 2 ) ,  " 100 . 0 " ) ;%NWL%test . equal ( f ( 1e + 3 ) ,  " 1 . 000k " ) ;%NWL%test . equal ( f ( 1e + 4 ) ,  " 10 . 00k " ) ;%NWL%test . equal ( f ( 1e + 5 ) ,  " 100 . 0k " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " 0 [ width ] , s\ " ) will group thousands due to zero fill " , function ( test )  {%NWL%var f = format . format ( " 020 , s " ) ;%NWL%test . equal ( f ( 42 ) ,   " 000 , 000 , 000 , 042 . 0000 " ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " 0 [ width ] , s\ " ) will group thousands due to zero fill " , function ( test )  {%NWL%var f = format . format ( " 020 , s " ) ;%NWL%test . equal ( f ( 42 ) ,   " 000 , 000 , 000 , 042 . 0000 " ) ;%NWL%test . equal ( f ( 42e12 ) ,  " 00 , 000 , 000 , 042 . 0000T " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , s\ " ) will group thousands for very large numbers " , function ( test )  {%NWL%var f = format . format ( " , s " ) ;%NWL%test . end ( ) ;%NWL%0
var tape = require ( " tape " ) ,%NWL%format = require ( " . . / " ) ;%NWL%tape ( " format ( \ " x\ " ) returns the expected hexadecimal ( lowercase ) string " , function ( test )  {%NWL%test . equal ( format . format ( " x " ) ( 0xdeadbeef ) ,  " deadbeef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " #x\ " ) returns the expected hexadecimal ( lowercase ) string with prefix " , function ( test )  {%NWL%test . end ( ) ;%NWL%4
format = require ( " . . / " ) ;%NWL%tape ( " format ( \ " x\ " ) returns the expected hexadecimal ( lowercase ) string " , function ( test )  {%NWL%test . equal ( format . format ( " x " ) ( 0xdeadbeef ) ,  " deadbeef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " #x\ " ) returns the expected hexadecimal ( lowercase ) string with prefix " , function ( test )  {%NWL%test . equal ( format . format ( " #x " ) ( 0xdeadbeef ) ,  " 0xdeadbeef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , x\ " ) groups thousands " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " #x\ " ) returns the expected hexadecimal ( lowercase ) string with prefix " , function ( test )  {%NWL%test . equal ( format . format ( " #x " ) ( 0xdeadbeef ) ,  " 0xdeadbeef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , x\ " ) groups thousands " , function ( test )  {%NWL%test . equal ( format . format ( " , x " ) ( 0xdeadbeef ) ,  " de , adb , eef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%test . equal ( format . format ( " , x " ) ( 0xdeadbeef ) ,  " de , adb , eef " ) ;%NWL%7
} ) ;%NWL%tape ( " format ( \ " #x\ " ) returns the expected hexadecimal ( lowercase ) string with prefix " , function ( test )  {%NWL%test . equal ( format . format ( " #x " ) ( 0xdeadbeef ) ,  " 0xdeadbeef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , x\ " ) groups thousands " , function ( test )  {%NWL%test . equal ( format . format ( " , x " ) ( 0xdeadbeef ) ,  " de , adb , eef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , x\ " ) groups thousands " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " format ( \ " , x\ " ) groups thousands " , function ( test )  {%NWL%test . equal ( format . format ( " , x " ) ( 0xdeadbeef ) ,  " de , adb , eef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " , x\ " ) groups thousands " , function ( test )  {%NWL%test . equal ( format . format ( " , x " ) ( 0xdeadbeef ) ,  " de , adb , eef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " # , x\ " ) does not group the prefix " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " # , x\ " ) does not group the prefix " , function ( test )  {%NWL%test . equal ( format . format ( " # , x " ) ( 0xadeadbeef ) ,  " 0xade , adb , eef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " + #x\ " ) puts the sign before the prefix " , function ( test )  {%NWL%test . equal ( format . format ( " + #x " ) ( 0xdeadbeef ) ,  " + 0xdeadbeef " ) ;%NWL%test . equal ( format . format ( " + #x " ) ( - 0xdeadbeef ) ,  " - 0xdeadbeef " ) ;%NWL%test . equal ( format . format ( " #x " ) ( 0xdeadbeef ) ,  " 0xdeadbeef " ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " + #x\ " ) puts the sign before the prefix " , function ( test )  {%NWL%test . equal ( format . format ( " + #x " ) ( 0xdeadbeef ) ,  " + 0xdeadbeef " ) ;%NWL%test . equal ( format . format ( " + #x " ) ( - 0xdeadbeef ) ,  " - 0xdeadbeef " ) ;%NWL%test . equal ( format . format ( " #x " ) ( 0xdeadbeef ) ,  " 0xdeadbeef " ) ;%NWL%test . equal ( format . format ( " #x " ) ( - 0xdeadbeef ) ,  " - 0xdeadbeef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " $ , x\ " ) formats hexadecimal currency " , function ( test )  {%NWL%test . end ( ) ;%NWL%0
test . equal ( format . format ( " #x " ) ( 0xdeadbeef ) ,  " 0xdeadbeef " ) ;%NWL%test . equal ( format . format ( " #x " ) ( - 0xdeadbeef ) ,  " - 0xdeadbeef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " $ , x\ " ) formats hexadecimal currency " , function ( test )  {%NWL%test . equal ( format . format ( " $ , x " ) ( 0xdeadbeef ) ,  " $de , adb , eef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " [ . precision ] x\ " ) always has precision zero " , function ( test )  {%NWL%test . equal ( format . format ( " . 2x " ) ( 0xdeadbeef ) ,  " deadbeef " ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " format ( \ " $ , x\ " ) formats hexadecimal currency " , function ( test )  {%NWL%test . equal ( format . format ( " $ , x " ) ( 0xdeadbeef ) ,  " $de , adb , eef " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " [ . precision ] x\ " ) always has precision zero " , function ( test )  {%NWL%test . equal ( format . format ( " . 2x " ) ( 0xdeadbeef ) ,  " deadbeef " ) ;%NWL%test . equal ( format . format ( " . 2x " ) ( - 4 . 2 ) ,  " - 4 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " x\ " ) rounds non - integers " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . equal ( format . format ( " . 2x " ) ( 0xdeadbeef ) ,  " deadbeef " ) ;%NWL%test . equal ( format . format ( " . 2x " ) ( - 4 . 2 ) ,  " - 4 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " x\ " ) rounds non - integers " , function ( test )  {%NWL%test . equal ( format . format ( " x " ) ( 2 . 4 ) ,  " 2 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " x\ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " x " ) ( - 0 ) ,  " 0 " ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " format ( \ " x\ " ) rounds non - integers " , function ( test )  {%NWL%test . equal ( format . format ( " x " ) ( 2 . 4 ) ,  " 2 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " x\ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " x " ) ( - 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " x " ) ( - 1e - 12 ) ,  " 0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " x\ " ) does not consider - 0xeee to be positive " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " format ( \ " x\ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " x " ) ( - 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " x " ) ( - 1e - 12 ) ,  " 0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " x\ " ) does not consider - 0xeee to be positive " , function ( test )  {%NWL%test . equal ( format . format ( " x " ) ( - 0xeee ) ,  " - eee " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " X\ " ) returns the expected hexadecimal ( uppercase ) string " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " format ( \ " x\ " ) does not consider - 0xeee to be positive " , function ( test )  {%NWL%test . equal ( format . format ( " x " ) ( - 0xeee ) ,  " - eee " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " X\ " ) returns the expected hexadecimal ( uppercase ) string " , function ( test )  {%NWL%test . equal ( format . format ( " X " ) ( 0xdeadbeef ) ,  " DEADBEEF " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " #X\ " ) returns the expected hexadecimal ( uppercase ) string with prefix " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " format ( \ " X\ " ) returns the expected hexadecimal ( uppercase ) string " , function ( test )  {%NWL%test . equal ( format . format ( " X " ) ( 0xdeadbeef ) ,  " DEADBEEF " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " #X\ " ) returns the expected hexadecimal ( uppercase ) string with prefix " , function ( test )  {%NWL%test . equal ( format . format ( " #X " ) ( 0xdeadbeef ) ,  " 0xDEADBEEF " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " X\ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " X " ) ( - 0 ) ,  " 0 " ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " format ( \ " #X\ " ) returns the expected hexadecimal ( uppercase ) string with prefix " , function ( test )  {%NWL%test . equal ( format . format ( " #X " ) ( 0xdeadbeef ) ,  " 0xDEADBEEF " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " X\ " ) can format negative zero as zero " , function ( test )  {%NWL%test . equal ( format . format ( " X " ) ( - 0 ) ,  " 0 " ) ;%NWL%test . equal ( format . format ( " X " ) ( - 1e - 12 ) ,  " 0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " X\ " ) does not consider - 0xeee to be positive " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " X\ " ) does not consider - 0xeee to be positive " , function ( test )  {%NWL%test . equal ( format . format ( " X " ) ( - 0xeee ) ,  " - EEE " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " format ( \ " # [ width ] x\ " ) considers the prefix " , function ( test )  {%NWL%test . equal ( format . format ( " 20x " ) ( 0xdeadbeef ) ,   "       deadbeef " ) ;%NWL%test . equal ( format . format ( " #20x " ) ( 0xdeadbeef ) ,  "      0xdeadbeef " ) ;%NWL%test . equal ( format . format ( " 020x " ) ( 0xdeadbeef ) ,  " 000000000000deadbeef " ) ;%NWL%test . end ( ) ;%NWL%0
var tape = require ( " tape " ) ,%NWL%format = require ( " . . / " ) ;%NWL%tape ( " formatPrefix ( \ " s\ " , value ) ( number ) formats with the SI prefix appropriate to the specified value " , function ( test )  {%NWL%test . equal ( format . formatPrefix ( " , . 0s " , 1e - 6 ) ( . 00042 ) ,  " 420µ " ) ;%NWL%test . equal ( format . formatPrefix ( " , . 0s " , 1e - 6 ) ( . 0042 ) ,  " 4 , 200µ " ) ;%NWL%test . equal ( format . formatPrefix ( " , . 3s " , 1e - 3 ) ( . 00042 ) ,  " 0 . 420m " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatPrefix ( \ " s\ " , value ) ( number ) uses yocto for very small reference values " , function ( test )  {%NWL%test . end ( ) ;%NWL%6
test . equal ( format . formatPrefix ( " , . 0s " , 1e - 6 ) ( . 00042 ) ,  " 420µ " ) ;%NWL%test . equal ( format . formatPrefix ( " , . 0s " , 1e - 6 ) ( . 0042 ) ,  " 4 , 200µ " ) ;%NWL%test . equal ( format . formatPrefix ( " , . 3s " , 1e - 3 ) ( . 00042 ) ,  " 0 . 420m " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatPrefix ( \ " s\ " , value ) ( number ) uses yocto for very small reference values " , function ( test )  {%NWL%test . equal ( format . formatPrefix ( " , . 0s " , 1e - 27 ) ( 1e - 24 ) ,  " 1y " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatPrefix ( \ " s\ " , value ) ( number ) uses yotta for very small reference values " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . equal ( format . formatPrefix ( " , . 0s " , 1e - 27 ) ( 1e - 24 ) ,  " 1y " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatPrefix ( \ " s\ " , value ) ( number ) uses yotta for very small reference values " , function ( test )  {%NWL%test . equal ( format . formatPrefix ( " , . 0s " , 1e27 ) ( 1e24 ) ,  " 1Y " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatPrefix ( \ " $ , s\ " , value ) ( number ) formats with the specified SI prefix " , function ( test )  {%NWL%var f = format . formatPrefix ( " $12 , . 1s " , 1e6 ) ;%NWL%test . equal ( f ( - 42e6 ) ,  "    - $42 . 0M " ) ;%NWL%test . end ( ) ;%NWL%1
var tape = require ( " tape " ) ,%NWL%format = require ( " . . / " ) ;%NWL%tape ( " formatSpecifier ( specifier ) throws an error for invalid formats " , function ( test )  {%NWL%test . throws ( function ( )  { format . formatSpecifier ( " foo " ) ; } ,  / invalid format: foo / ) ;%NWL%test . throws ( function ( )  { format . formatSpecifier ( " . - 2s " ) ; } ,  / invalid format: \ . - 2s / ) ;%NWL%test . throws ( function ( )  { format . formatSpecifier ( " . f " ) ; } ,  / invalid format: \ . f / ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatSpecifier ( specifier ) returns an instanceof formatSpecifier " , function ( test )  {%NWL%var s = format . formatSpecifier ( " " ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( s . symbol ,  " " ) ;%NWL%test . equal ( s . zero , false ) ;%NWL%test . equal ( s . width , undefined ) ;%NWL%test . equal ( s . comma , false ) ;%NWL%test . equal ( s . precision , undefined ) ;%NWL%test . equal ( s . type ,  " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatSpecifier ( specifier ) uses the none type for unknown types " , function ( test )  {%NWL%test . equal ( format . formatSpecifier ( " q " ) . type ,  " " ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatSpecifier ( specifier ) uses the none type for unknown types " , function ( test )  {%NWL%test . equal ( format . formatSpecifier ( " q " ) . type ,  " " ) ;%NWL%test . equal ( format . formatSpecifier ( " S " ) . type ,  " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatSpecifier ( \ " n\ " ) is an alias for \ " , g\ " " , function ( test )  {%NWL%var s = format . formatSpecifier ( " n " )%NWL%test . equal ( s . comma , true ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " formatSpecifier ( \ " n\ " ) is an alias for \ " , g\ " " , function ( test )  {%NWL%var s = format . formatSpecifier ( " n " )%NWL%test . equal ( s . comma , true ) ;%NWL%test . equal ( s . type ,  " g " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatSpecifier ( \ " 0\ " ) is an alias for \ " 0=\ " " , function ( test )  {%NWL%var s = format . formatSpecifier ( " 0 " )%NWL%test . equal ( s . zero , true ) ;%NWL%test . equal ( s . fill ,  " 0 " ) ;%NWL%test . end ( ) ;%NWL%4
test . equal ( ( s . zero = true , s )  +  " " ,  " _^ + $0 " ) ;%NWL%test . equal ( ( s . width = 12 , s )  +  " " ,  " _^ + $012 " ) ;%NWL%test . equal ( ( s . comma = true , s )  +  " " ,  " _^ + $012 , " ) ;%NWL%test . equal ( ( s . precision = 2 , s )  +  " " ,  " _^ + $012 , . 2 " ) ;%NWL%test . equal ( ( s . type = " f " , s )  +  " " ,  " _^ + $012 , . 2f " ) ;%NWL%test . equal ( format . format ( s ) ( 42 ) ,  " + $0 , 000 , 042 . 00 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatSpecifier ( specifier ) . toString ( ) clamps precision to zero " , function ( test )  {%NWL%var s = format . formatSpecifier ( " " ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( format . format ( s ) ( 42 ) ,  " + $0 , 000 , 042 . 00 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatSpecifier ( specifier ) . toString ( ) clamps precision to zero " , function ( test )  {%NWL%var s = format . formatSpecifier ( " " ) ;%NWL%test . equal ( ( s . precision = - 1 , s )  +  " " ,  " > - . 0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " formatSpecifier ( specifier ) . toString ( ) clamps width to one " , function ( test )  {%NWL%var s = format . formatSpecifier ( " " ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( format . precisionPrefix ( + ( " 1e "  + i ) ,  + ( " 1e "  + j ) ) , 0 ) ;%NWL%}%NWL%}%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " precisionPrefix ( step , value ) returns greater than zero if fractional digits are needed " , function ( test )  {%NWL%for ( var i = - 24; i <= 24; i + = 3 )  {%NWL%for ( var j = i - 4; j < i; + + j )  {%NWL%test . equal ( format . precisionPrefix ( + ( " 1e "  + j ) ,  + ( " 1e "  + i ) ) , i - j ) ;%NWL%}%NWL%test . end ( ) ;%NWL%3
test . equal ( format . precisionPrefix ( + ( " 1e "  + j ) ,  + ( " 1e "  + i ) ) , i - j ) ;%NWL%}%NWL%}%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " precisionPrefix ( step , value ) returns the expected precision when value is less than one yocto " , function ( test )  {%NWL%test . equal ( format . precisionPrefix ( 1e - 24 , 1e - 24 ) , 0 ) ; / / 1y%NWL%test . equal ( format . precisionPrefix ( 1e - 25 , 1e - 25 ) , 1 ) ; / / 0 . 1y%NWL%test . equal ( format . precisionPrefix ( 1e - 26 , 1e - 26 ) , 2 ) ; / / 0 . 01y%NWL%test . equal ( format . precisionPrefix ( 1e - 27 , 1e - 27 ) , 3 ) ; / / 0 . 001y%NWL%test . end ( ) ;%NWL%3
test . equal ( format . precisionPrefix ( 1e - 26 , 1e - 26 ) , 2 ) ; / / 0 . 01y%NWL%test . equal ( format . precisionPrefix ( 1e - 27 , 1e - 27 ) , 3 ) ; / / 0 . 001y%NWL%test . equal ( format . precisionPrefix ( 1e - 28 , 1e - 28 ) , 4 ) ; / / 0 . 0001y%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " precisionPrefix ( step , value ) returns the expected precision when value is greater than than one yotta " , function ( test )  {%NWL%test . equal ( format . precisionPrefix ( 1e24 , 1e24 ) , 0 ) ; / / 1Y%NWL%test . equal ( format . precisionPrefix ( 1e24 , 1e25 ) , 0 ) ; / / 10Y%NWL%test . equal ( format . precisionPrefix ( 1e24 , 1e26 ) , 0 ) ; / / 100Y%NWL%test . equal ( format . precisionPrefix ( 1e24 , 1e27 ) , 0 ) ; / / 1000Y%NWL%test . end ( ) ;%NWL%3
point: boundsPoint ,%NWL%lineStart: boundsLineStart ,%NWL%lineEnd: boundsLineEnd ,%NWL%polygonStart: function ( )  {%NWL%boundsStream . point = boundsRingPoint;%NWL%boundsStream . lineStart = boundsRingStart;%NWL%boundsStream . lineEnd = boundsRingEnd;%NWL%deltaSum . reset ( ) ;%NWL%areaStream . polygonStart ( ) ;%NWL%} ,%NWL%areaStream . polygonEnd ( ) ;%NWL%8
} else {%NWL%lambda00 = lambda , phi00 = phi;%NWL%}%NWL%areaStream . point ( lambda , phi ) ;%NWL%linePoint ( lambda , phi ) ;%NWL%}%NWL%function boundsRingStart ( )  {%NWL%areaStream . lineStart ( ) ;%NWL%}%NWL%function boundsRingEnd ( )  {%NWL%areaStream . lineEnd ( ) ;%NWL%7
mean = 0;%NWL%var input_pos_match = _ . range ( 1 , 10 ) ;%NWL%var input_neg_match = _ . range ( - 1 ,  - 10 ,  - 1 ) ;%NWL%var input_no_match = _ . range ( - 4 , 5 ) ;%NWL%tape ( ' rule_2 matches on the positive side of the mean ' , function ( test )  {%NWL%var result = rule_2 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_2 matches on the negative side of the mean ' , function ( test )  {%NWL%test . ok ( result ) ;%NWL%6
var input_pos_match = _ . range ( 1 , 10 ) ;%NWL%var input_neg_match = _ . range ( - 1 ,  - 10 ,  - 1 ) ;%NWL%var input_no_match = _ . range ( - 4 , 5 ) ;%NWL%tape ( ' rule_2 matches on the positive side of the mean ' , function ( test )  {%NWL%var result = rule_2 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_2 matches on the negative side of the mean ' , function ( test )  {%NWL%var result = rule_2 ( input_neg_match , mean , std ) ;%NWL%test . end ( ) ;%NWL%6
var result = rule_2 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_2 matches on the negative side of the mean ' , function ( test )  {%NWL%var result = rule_2 ( input_neg_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_2 does not match if a sequence crosses the mean ' , function ( test )  {%NWL%test . notOk ( result ) ;%NWL%1
test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_2 matches on the negative side of the mean ' , function ( test )  {%NWL%var result = rule_2 ( input_neg_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_2 does not match if a sequence crosses the mean ' , function ( test )  {%NWL%var result = rule_2 ( input_no_match , mean , std ) ;%NWL%test . end ( ) ;%NWL%1
return containsPoint ( object . coordinates , point ) ;%NWL%} ,%NWL%MultiPoint: function ( object , point )  {%NWL%var coordinates = object . coordinates , i = - 1 , n = coordinates . length;%NWL%while ( + + i < n ) if ( containsPoint ( coordinates [ i ] , point ) ) return true;%NWL%return false;%NWL%} ,%NWL%LineString: function ( object , point )  {%NWL%return containsLine ( object . coordinates , point ) ;%NWL%} ,%NWL%var coordinates = object . coordinates , i = - 1 , n = coordinates . length;%NWL%3
return containsLine ( object . coordinates , point ) ;%NWL%} ,%NWL%MultiLineString: function ( object , point )  {%NWL%var coordinates = object . coordinates , i = - 1 , n = coordinates . length;%NWL%while ( + + i < n ) if ( containsLine ( coordinates [ i ] , point ) ) return true;%NWL%return false;%NWL%} ,%NWL%Polygon: function ( object , point )  {%NWL%return containsPolygon ( object . coordinates , point ) ;%NWL%} ,%NWL%var coordinates = object . coordinates , i = - 1 , n = coordinates . length;%NWL%3
return false;%NWL%} ,%NWL%Polygon: function ( object , point )  {%NWL%return containsPolygon ( object . coordinates , point ) ;%NWL%} ,%NWL%MultiPolygon: function ( object , point )  {%NWL%var coordinates = object . coordinates , i = - 1 , n = coordinates . length;%NWL%while ( + + i < n ) if ( containsPolygon ( coordinates [ i ] , point ) ) return true;%NWL%return false;%NWL%} ,%NWL%var geometries = object . geometries , i = - 1 , n = geometries . length;%NWL%6
object = object . coordinates;%NWL%stream . point ( object [ 0 ] , object [ 1 ] , object [ 2 ] ) ;%NWL%} ,%NWL%MultiPoint: function ( object , stream )  {%NWL%var coordinates = object . coordinates , i = - 1 , n = coordinates . length;%NWL%while ( + + i < n ) object = coordinates [ i ] , stream . point ( object [ 0 ] , object [ 1 ] , object [ 2 ] ) ;%NWL%} ,%NWL%LineString: function ( object , stream )  {%NWL%streamLine ( object . coordinates , stream , 0 ) ;%NWL%} ,%NWL%var coordinates = object . coordinates , i = - 1 , n = coordinates . length;%NWL%4
LineString: function ( object , stream )  {%NWL%streamLine ( object . coordinates , stream , 0 ) ;%NWL%} ,%NWL%MultiLineString: function ( object , stream )  {%NWL%var coordinates = object . coordinates , i = - 1 , n = coordinates . length;%NWL%while ( + + i < n ) streamLine ( coordinates [ i ] , stream , 0 ) ;%NWL%} ,%NWL%Polygon: function ( object , stream )  {%NWL%streamPolygon ( object . coordinates , stream ) ;%NWL%} ,%NWL%var coordinates = object . coordinates , i = - 1 , n = coordinates . length;%NWL%4
var coordinates = object . coordinates , i = - 1 , n = coordinates . length;%NWL%while ( + + i < n ) streamLine ( coordinates [ i ] , stream , 0 ) ;%NWL%} ,%NWL%Polygon: function ( object , stream )  {%NWL%streamPolygon ( object . coordinates , stream ) ;%NWL%} ,%NWL%MultiPolygon: function ( object , stream )  {%NWL%var coordinates = object . coordinates , i = - 1 , n = coordinates . length;%NWL%while ( + + i < n ) streamPolygon ( coordinates [ i ] , stream ) ;%NWL%} ,%NWL%var geometries = object . geometries , i = - 1 , n = geometries . length;%NWL%0
while ( + + i < n ) streamPolygon ( coordinates [ i ] , stream ) ;%NWL%} ,%NWL%GeometryCollection: function ( object , stream )  {%NWL%var geometries = object . geometries , i = - 1 , n = geometries . length;%NWL%while ( + + i < n ) streamGeometry ( geometries [ i ] , stream ) ;%NWL%}%NWL%} ;%NWL%function streamLine ( coordinates , stream , closed )  {%NWL%var i = - 1 , n = coordinates . length - closed , coordinate;%NWL%stream . lineStart ( ) ;%NWL%stream . lineEnd ( ) ;%NWL%9
while ( + + i < n ) streamGeometry ( geometries [ i ] , stream ) ;%NWL%}%NWL%} ;%NWL%function streamLine ( coordinates , stream , closed )  {%NWL%var i = - 1 , n = coordinates . length - closed , coordinate;%NWL%stream . lineStart ( ) ;%NWL%while ( + + i < n ) coordinate = coordinates [ i ] , stream . point ( coordinate [ 0 ] , coordinate [ 1 ] , coordinate [ 2 ] ) ;%NWL%stream . lineEnd ( ) ;%NWL%}%NWL%function streamPolygon ( coordinates , stream )  {%NWL%stream . polygonStart ( ) ;%NWL%5
} ;%NWL%function streamLine ( coordinates , stream , closed )  {%NWL%var i = - 1 , n = coordinates . length - closed , coordinate;%NWL%stream . lineStart ( ) ;%NWL%while ( + + i < n ) coordinate = coordinates [ i ] , stream . point ( coordinate [ 0 ] , coordinate [ 1 ] , coordinate [ 2 ] ) ;%NWL%stream . lineEnd ( ) ;%NWL%}%NWL%function streamPolygon ( coordinates , stream )  {%NWL%var i = - 1 , n = coordinates . length;%NWL%stream . polygonStart ( ) ;%NWL%stream . polygonEnd ( ) ;%NWL%3
return {%NWL%lineStart: function ( )  {%NWL%stream . lineStart ( ) ;%NWL%clean = 1;%NWL%} ,%NWL%point: function ( lambda1 , phi1 )  {%NWL%var sign1 = lambda1 > 0 ? pi : - pi ,%NWL%delta = abs ( lambda1 - lambda0 ) ;%NWL%if ( abs ( delta - pi ) < epsilon )  {  / / line crosses a pole%NWL%stream . point ( lambda0 , phi0 = ( phi0 + phi1 )  / 2 > 0 ? halfPi : - halfPi ) ;%NWL%stream . lineEnd ( ) ;%NWL%2
lineStart: function ( )  {%NWL%stream . lineStart ( ) ;%NWL%clean = 1;%NWL%} ,%NWL%point: function ( lambda1 , phi1 )  {%NWL%var sign1 = lambda1 > 0 ? pi : - pi ,%NWL%delta = abs ( lambda1 - lambda0 ) ;%NWL%if ( abs ( delta - pi ) < epsilon )  {  / / line crosses a pole%NWL%stream . point ( lambda0 , phi0 = ( phi0 + phi1 )  / 2 > 0 ? halfPi : - halfPi ) ;%NWL%stream . point ( sign0 , phi0 ) ;%NWL%stream . lineStart ( ) ;%NWL%1
stream . point ( lambda0 , phi0 = ( phi0 + phi1 )  / 2 > 0 ? halfPi : - halfPi ) ;%NWL%stream . point ( sign0 , phi0 ) ;%NWL%stream . lineEnd ( ) ;%NWL%stream . lineStart ( ) ;%NWL%stream . point ( sign1 , phi0 ) ;%NWL%stream . point ( lambda1 , phi0 ) ;%NWL%clean = 0;%NWL%} else if ( sign0 !== sign1 && delta >= pi )  {  / / line crosses antimeridian%NWL%if ( abs ( lambda0 - sign0 ) < epsilon ) lambda0 - = sign0 * epsilon; / / handle degeneracies%NWL%if ( abs ( lambda1 - sign1 ) < epsilon ) lambda1 - = sign1 * epsilon;%NWL%stream . point ( sign0 , phi0 ) ;%NWL%1
stream . point ( sign0 , phi0 ) ;%NWL%stream . lineEnd ( ) ;%NWL%stream . lineStart ( ) ;%NWL%stream . point ( sign1 , phi0 ) ;%NWL%stream . point ( lambda1 , phi0 ) ;%NWL%clean = 0;%NWL%} else if ( sign0 !== sign1 && delta >= pi )  {  / / line crosses antimeridian%NWL%if ( abs ( lambda0 - sign0 ) < epsilon ) lambda0 - = sign0 * epsilon; / / handle degeneracies%NWL%if ( abs ( lambda1 - sign1 ) < epsilon ) lambda1 - = sign1 * epsilon;%NWL%phi0 = clipAntimeridianIntersect ( lambda0 , phi0 , lambda1 , phi1 ) ;%NWL%stream . lineEnd ( ) ;%NWL%1
stream . lineEnd ( ) ;%NWL%stream . lineStart ( ) ;%NWL%stream . point ( sign1 , phi0 ) ;%NWL%stream . point ( lambda1 , phi0 ) ;%NWL%clean = 0;%NWL%} else if ( sign0 !== sign1 && delta >= pi )  {  / / line crosses antimeridian%NWL%if ( abs ( lambda0 - sign0 ) < epsilon ) lambda0 - = sign0 * epsilon; / / handle degeneracies%NWL%if ( abs ( lambda1 - sign1 ) < epsilon ) lambda1 - = sign1 * epsilon;%NWL%phi0 = clipAntimeridianIntersect ( lambda0 , phi0 , lambda1 , phi1 ) ;%NWL%stream . point ( sign0 , phi0 ) ;%NWL%stream . lineStart ( ) ;%NWL%0
stream . lineStart ( ) ;%NWL%stream . point ( sign1 , phi0 ) ;%NWL%stream . point ( lambda1 , phi0 ) ;%NWL%clean = 0;%NWL%} else if ( sign0 !== sign1 && delta >= pi )  {  / / line crosses antimeridian%NWL%if ( abs ( lambda0 - sign0 ) < epsilon ) lambda0 - = sign0 * epsilon; / / handle degeneracies%NWL%if ( abs ( lambda1 - sign1 ) < epsilon ) lambda1 - = sign1 * epsilon;%NWL%phi0 = clipAntimeridianIntersect ( lambda0 , phi0 , lambda1 , phi1 ) ;%NWL%stream . point ( sign0 , phi0 ) ;%NWL%stream . lineEnd ( ) ;%NWL%stream . point ( sign1 , phi0 ) ;%NWL%1
phi0 = clipAntimeridianIntersect ( lambda0 , phi0 , lambda1 , phi1 ) ;%NWL%stream . point ( sign0 , phi0 ) ;%NWL%stream . lineEnd ( ) ;%NWL%stream . lineStart ( ) ;%NWL%stream . point ( sign1 , phi0 ) ;%NWL%clean = 0;%NWL%}%NWL%stream . point ( lambda0 = lambda1 , phi0 = phi1 ) ;%NWL%sign0 = sign1;%NWL%} ,%NWL%stream . lineEnd ( ) ;%NWL%2
var phi;%NWL%if ( from == null )  {%NWL%phi = direction * halfPi;%NWL%stream . point ( - pi , phi ) ;%NWL%stream . point ( 0 , phi ) ;%NWL%stream . point ( pi , phi ) ;%NWL%stream . point ( pi , 0 ) ;%NWL%stream . point ( pi ,  - phi ) ;%NWL%stream . point ( 0 ,  - phi ) ;%NWL%stream . point ( - pi ,  - phi ) ;%NWL%stream . point ( - pi , phi ) ;%NWL%3
} else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " ,  " operator " , stream . current ( ) ) ;%NWL%}%NWL%} else if ( ch == " ` " )  {%NWL%state . tokenize = tokenQuasi;%NWL%return tokenQuasi ( stream , state ) ;%NWL%} else if ( ch == " # " )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " error " ,  " error " ) ;%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%1
if ( inList ( state . globalVars ) ) return;%NWL%if ( parserConfig . globalVars )%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%cx . state . localVars = cx . state . context . vars;%NWL%7
if ( parserConfig . globalVars )%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%function popcontext ( )  {%NWL%cx . state . context = cx . state . context . prev;%NWL%6
var state = cx . state , indent = state . indented;%NWL%if ( state . lexical . type == " stat " ) indent = state . lexical . indented;%NWL%state . lexical = new JSLexical ( indent , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%state . indented = state . lexical . indented;%NWL%2
if ( state . lexical . type == " stat " ) indent = state . lexical . indented;%NWL%state . lexical = new JSLexical ( indent , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%if ( state . lexical . type == " ) " )%NWL%state . lexical = state . lexical . prev;%NWL%1
clip . lineStart = lineStart;%NWL%clip . lineEnd = lineEnd;%NWL%segments = merge ( segments ) ;%NWL%var startInside = polygonContains ( polygon , rotatedStart ) ;%NWL%if ( segments . length )  {%NWL%if ( !polygonStarted ) sink . polygonStart ( ) , polygonStarted = true;%NWL%clipPolygon ( segments , compareIntersection , startInside , interpolate , sink ) ;%NWL%} else if ( startInside )  {%NWL%if ( !polygonStarted ) sink . polygonStart ( ) , polygonStarted = true;%NWL%sink . lineStart ( ) ;%NWL%sink . lineEnd ( ) ;%NWL%9
clipPolygon ( segments , compareIntersection , startInside , interpolate , sink ) ;%NWL%} else if ( startInside )  {%NWL%if ( !polygonStarted ) sink . polygonStart ( ) , polygonStarted = true;%NWL%sink . lineStart ( ) ;%NWL%interpolate ( null , null , 1 , sink ) ;%NWL%sink . lineEnd ( ) ;%NWL%}%NWL%if ( polygonStarted ) sink . polygonEnd ( ) , polygonStarted = false;%NWL%segments = polygon = null;%NWL%} ,%NWL%sink . polygonStart ( ) ;%NWL%3
} else if ( startInside )  {%NWL%if ( !polygonStarted ) sink . polygonStart ( ) , polygonStarted = true;%NWL%sink . lineStart ( ) ;%NWL%interpolate ( null , null , 1 , sink ) ;%NWL%sink . lineEnd ( ) ;%NWL%}%NWL%if ( polygonStarted ) sink . polygonEnd ( ) , polygonStarted = false;%NWL%segments = polygon = null;%NWL%} ,%NWL%sphere: function ( )  {%NWL%sink . lineStart ( ) ;%NWL%2
sink . lineStart ( ) ;%NWL%interpolate ( null , null , 1 , sink ) ;%NWL%sink . lineEnd ( ) ;%NWL%}%NWL%if ( polygonStarted ) sink . polygonEnd ( ) , polygonStarted = false;%NWL%segments = polygon = null;%NWL%} ,%NWL%sphere: function ( )  {%NWL%sink . polygonStart ( ) ;%NWL%sink . lineStart ( ) ;%NWL%sink . lineEnd ( ) ;%NWL%0
interpolate ( null , null , 1 , sink ) ;%NWL%sink . lineEnd ( ) ;%NWL%}%NWL%if ( polygonStarted ) sink . polygonEnd ( ) , polygonStarted = false;%NWL%segments = polygon = null;%NWL%} ,%NWL%sphere: function ( )  {%NWL%sink . polygonStart ( ) ;%NWL%sink . lineStart ( ) ;%NWL%interpolate ( null , null , 1 , sink ) ;%NWL%sink . polygonEnd ( ) ;%NWL%1
}%NWL%function pointLine ( lambda , phi )  {%NWL%var point = rotate ( lambda , phi ) ;%NWL%line . point ( point [ 0 ] , point [ 1 ] ) ;%NWL%}%NWL%function lineStart ( )  {%NWL%clip . point = pointLine;%NWL%line . lineStart ( ) ;%NWL%}%NWL%function lineEnd ( )  {%NWL%line . lineEnd ( ) ;%NWL%7
function pointRing ( lambda , phi )  {%NWL%ring . push ( [ lambda , phi ] ) ;%NWL%var point = rotate ( lambda , phi ) ;%NWL%ringSink . point ( point [ 0 ] , point [ 1 ] ) ;%NWL%}%NWL%function ringStart ( )  {%NWL%ringSink . lineStart ( ) ;%NWL%ring = [ ] ;%NWL%}%NWL%function ringEnd ( )  {%NWL%ringSink . lineEnd ( ) ;%NWL%6
point;%NWL%ring . pop ( ) ;%NWL%polygon . push ( ring ) ;%NWL%ring = null;%NWL%if ( !n ) return;%NWL%if ( clean & 1 )  {%NWL%segment = ringSegments [ 0 ] ;%NWL%if ( ( m = segment . length - 1 ) > 0 )  {%NWL%if ( !polygonStarted ) sink . polygonStart ( ) , polygonStarted = true;%NWL%sink . lineStart ( ) ;%NWL%sink . lineEnd ( ) ;%NWL%9
export default function ( segments , compareIntersection , startInside , interpolate , stream )  {%NWL%var subject = [ ] ,%NWL%clip = [ ] ,%NWL%i ,%NWL%n;%NWL%segments . forEach ( function ( segment )  {%NWL%if ( ( n = segment . length - 1 ) <= 0 ) return;%NWL%var n , p0 = segment [ 0 ] , p1 = segment [ n ] , x;%NWL%if ( pointEqual ( p0 , p1 ) )  {%NWL%stream . lineStart ( ) ;%NWL%stream . lineEnd ( ) ;%NWL%9
import { abs , asin , atan2 , cos , epsilon , sign , sin , sqrt } from " . . / math " ;%NWL%import { conicProjection } from " . / conic " ;%NWL%import { cylindricalEqualAreaRaw } from " . / cylindricalEqualArea " ;%NWL%export function conicEqualAreaRaw ( y0 , y1 )  {%NWL%var sy0 = sin ( y0 ) , n = ( sy0 + sin ( y1 ) )  / 2;%NWL%var c = 1 + sy0 *  ( 2 * n - sy0 ) , r0 = sqrt ( c )  / n;%NWL%4
d3 . text ( href . replace ( ' . html ' , ' . js ' ) , function ( fragment )  {%NWL%cleanup ( )%NWL%document . querySelector ( ' body ' ) . scrollTop = document . querySelector ( ' . right ' ) . offsetTop%NWL%var script = document . createElement ( ' script ' )%NWL%script . textContent = fragment%NWL%document . head . appendChild ( script )%NWL%} )%NWL%}%NWL%function loadDocs ( href )  {%NWL%d3 . text ( href . replace ( ' . html ' ,  ' . md ' ) , function ( fragment )  {%NWL%document . querySelector ( ' body ' ) . scrollTop = document . querySelector ( ' . right ' ) . offsetTop%NWL%2
cleanup ( )%NWL%document . querySelector ( ' body ' ) . scrollTop = document . querySelector ( ' . right ' ) . offsetTop%NWL%var script = document . createElement ( ' script ' )%NWL%script . textContent = fragment%NWL%document . head . appendChild ( script )%NWL%} )%NWL%}%NWL%function loadDocs ( href )  {%NWL%d3 . text ( href . replace ( ' . html ' ,  ' . md ' ) , function ( fragment )  {%NWL%cleanup ( )%NWL%document . querySelector ( ' . blurb ' ) . textContent = ( fragment )%NWL%1
x0 = NaN;%NWL%resampleStream . point = linePoint;%NWL%stream . lineStart ( ) ;%NWL%}%NWL%function linePoint ( lambda , phi )  {%NWL%var c = cartesian ( [ lambda , phi ] ) , p = project ( lambda , phi ) ;%NWL%resampleLineTo ( x0 , y0 , lambda0 , a0 , b0 , c0 , x0 = p [ 0 ] , y0 = p [ 1 ] , lambda0 = lambda , a0 = c [ 0 ] , b0 = c [ 1 ] , c0 = c [ 2 ] , maxDepth , stream ) ;%NWL%stream . point ( x0 , y0 ) ;%NWL%}%NWL%function lineEnd ( )  {%NWL%stream . lineEnd ( ) ;%NWL%2
function getScreenBBox ( )  {%NWL%var targetel  = target || d3 . event . target ,%NWL%bbox    = { } ,%NWL%matrix   = targetel . getScreenCTM ( ) ,%NWL%tbbox   = targetel . getBBox ( ) ,%NWL%width   = tbbox . width ,%NWL%height   = tbbox . height ,%NWL%x     = tbbox . x ,%NWL%y     = tbbox . y%NWL%point . x = x%NWL%bbox . nw = point . matrixTransform ( matrix )%NWL%2
bbox    = { } ,%NWL%matrix   = targetel . getScreenCTM ( ) ,%NWL%tbbox   = targetel . getBBox ( ) ,%NWL%width   = tbbox . width ,%NWL%height   = tbbox . height ,%NWL%x     = tbbox . x ,%NWL%y     = tbbox . y%NWL%point . x = x%NWL%point . y = y%NWL%bbox . nw = point . matrixTransform ( matrix )%NWL%bbox . ne = point . matrixTransform ( matrix )%NWL%0
var stripe = array . range ( - 180 , 180 , 0 . 1 ) . map ( function ( x )  { return [ x , d ] ; } ) ;%NWL%stripe . push ( stripe [ 0 ] ) ;%NWL%return i ? stripe . reverse ( ) : stripe;%NWL%} ) } ;%NWL%}%NWL%tape ( " area: Point " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " Point " , coordinates: [ 0 , 0 ] } ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: MultiPoint " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
}%NWL%tape ( " area: Point " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " Point " , coordinates: [ 0 , 0 ] } ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: MultiPoint " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " MultiPoint " , coordinates: [ [ 0 , 1 ] ,  [ 2 , 3 ] ] } ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: LineString " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: MultiPoint " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " MultiPoint " , coordinates: [ [ 0 , 1 ] ,  [ 2 , 3 ] ] } ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: LineString " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " LineString " , coordinates: [ [ 0 , 1 ] ,  [ 2 , 3 ] ] } ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: MultiLineString " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " area: MultiLineString " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " MultiLineString " , coordinates: [ [ [ 0 , 1 ] ,  [ 2 , 3 ] ] ,  [ [ 4 , 5 ] ,  [ 6 , 7 ] ] ] } ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - tiny " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [%NWL%[ - 64 . 66070178517852 , 18 . 33986913231323 ] ,%NWL%[ - 64 . 66079715091509 , 18 . 33994007490749 ] ,%NWL%[ - 64 . 66074946804680 , 18 . 33994007490749 ] ,%NWL%[ - 64 . 66070178517852 , 18 . 33986913231323 ]%NWL%test . end ( ) ;%NWL%2
[ 96 . 79142432523281 , 5 . 262704519048153 ] ,%NWL%[ 96 . 81065389253769 , 5 . 272455576551362 ] ,%NWL%[ 96 . 82988345984256 , 5 . 272455576551362 ] ,%NWL%[ 96 . 81065389253769 , 5 . 272455576551362 ] ,%NWL%[ 96 . 79142432523281 , 5 . 262704519048153 ]%NWL%] ]%NWL%} ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - semilune " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
[ 96 . 79142432523281 , 5 . 262704519048153 ]%NWL%] ]%NWL%} ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - semilune " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ 0 , 90 ] ,  [ 90 , 0 ] ,  [ 0 , 0 ] ] ] } ) , Math . PI / 2 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - lune " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - semilune " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ 0 , 90 ] ,  [ 90 , 0 ] ,  [ 0 , 0 ] ] ] } ) , Math . PI / 2 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - lune " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ 0 , 90 ] ,  [ 90 , 0 ] ,  [ 0 ,  - 90 ] ,  [ 0 , 0 ] ] ] } ) , Math . PI , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - hemispheres North " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - lune " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ 0 , 90 ] ,  [ 90 , 0 ] ,  [ 0 ,  - 90 ] ,  [ 0 , 0 ] ] ] } ) , Math . PI , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - hemispheres North " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ - 90 , 0 ] ,  [ 180 , 0 ] ,  [ 90 , 0 ] ,  [ 0 , 0 ] ] ] } ) , 2 * Math . PI , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - hemispheres South " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - hemispheres North " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ - 90 , 0 ] ,  [ 180 , 0 ] ,  [ 90 , 0 ] ,  [ 0 , 0 ] ] ] } ) , 2 * Math . PI , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - hemispheres South " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ 90 , 0 ] ,  [ 180 , 0 ] ,  [ - 90 , 0 ] ,  [ 0 , 0 ] ] ] } ) , 2 * Math . PI , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - hemispheres East " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - hemispheres South " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ 90 , 0 ] ,  [ 180 , 0 ] ,  [ - 90 , 0 ] ,  [ 0 , 0 ] ] ] } ) , 2 * Math . PI , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - hemispheres East " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ 0 , 90 ] ,  [ 180 , 0 ] ,  [ 0 ,  - 90 ] ,  [ 0 , 0 ] ] ] } ) , 2 * Math . PI , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - hemispheres West " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - hemispheres East " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ 0 , 90 ] ,  [ 180 , 0 ] ,  [ 0 ,  - 90 ] ,  [ 0 , 0 ] ] ] } ) , 2 * Math . PI , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - hemispheres West " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ 0 ,  - 90 ] ,  [ 180 , 0 ] ,  [ 0 , 90 ] ,  [ 0 , 0 ] ] ] } ) , 2 * Math . PI , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - graticule outline sphere " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - hemispheres West " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( { type: " Polygon " , coordinates: [ [ [ 0 , 0 ] ,  [ 0 ,  - 90 ] ,  [ 180 , 0 ] ,  [ 0 , 90 ] ,  [ 0 , 0 ] ] ] } ) , 2 * Math . PI , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - graticule outline sphere " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoGraticule ( ) . extent ( [ [ - 180 ,  - 90 ] ,  [ 180 , 90 ] ] ) . outline ( ) ) , 4 * Math . PI , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - graticule outline hemisphere " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - graticule outline sphere " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoGraticule ( ) . extent ( [ [ - 180 ,  - 90 ] ,  [ 180 , 90 ] ] ) . outline ( ) ) , 4 * Math . PI , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - graticule outline hemisphere " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoGraticule ( ) . extent ( [ [ - 180 , 0 ] ,  [ 180 , 90 ] ] ) . outline ( ) ) , 2 * Math . PI , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - graticule outline semilune " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - graticule outline hemisphere " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoGraticule ( ) . extent ( [ [ - 180 , 0 ] ,  [ 180 , 90 ] ] ) . outline ( ) ) , 2 * Math . PI , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - graticule outline semilune " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoGraticule ( ) . extent ( [ [ 0 , 0 ] ,  [ 90 , 90 ] ] ) . outline ( ) ) , Math . PI / 2 , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles hemisphere " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - graticule outline semilune " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoGraticule ( ) . extent ( [ [ 0 , 0 ] ,  [ 90 , 90 ] ] ) . outline ( ) ) , Math . PI / 2 , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles hemisphere " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 90 ) ( ) ) , 2 * Math . PI , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 60° " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - circles hemisphere " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 90 ) ( ) ) , 2 * Math . PI , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 60° " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 60 ) . precision ( 0 . 1 ) ( ) ) , Math . PI , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 60° North " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - circles 60° " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 60 ) . precision ( 0 . 1 ) ( ) ) , Math . PI , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 60° North " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 60 ) . precision ( 0 . 1 ) . center ( [ 0 , 90 ] ) ( ) ) , Math . PI , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 45° " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - circles 60° North " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 60 ) . precision ( 0 . 1 ) . center ( [ 0 , 90 ] ) ( ) ) , Math . PI , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 45° " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 45 ) . precision ( 0 . 1 ) ( ) ) , Math . PI *  ( 2 - Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 45° North " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - circles 45° " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 45 ) . precision ( 0 . 1 ) ( ) ) , Math . PI *  ( 2 - Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 45° North " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 45 ) . precision ( 0 . 1 ) . center ( [ 0 , 90 ] ) ( ) ) , Math . PI *  ( 2 - Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 45° South " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - circles 45° North " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 45 ) . precision ( 0 . 1 ) . center ( [ 0 , 90 ] ) ( ) ) , Math . PI *  ( 2 - Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 45° South " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 45 ) . precision ( 0 . 1 ) . center ( [ 0 ,  - 90 ] ) ( ) ) , Math . PI *  ( 2 - Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 135° " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - circles 45° South " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 45 ) . precision ( 0 . 1 ) . center ( [ 0 ,  - 90 ] ) ( ) ) , Math . PI *  ( 2 - Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 135° " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 135 ) . precision ( 0 . 1 ) ( ) ) , Math . PI *  ( 2 + Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 135° North " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - circles 135° " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 135 ) . precision ( 0 . 1 ) ( ) ) , Math . PI *  ( 2 + Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 135° North " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 135 ) . precision ( 0 . 1 ) . center ( [ 0 , 90 ] ) ( ) ) , Math . PI *  ( 2 + Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 135° South " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - circles 135° North " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 135 ) . precision ( 0 . 1 ) . center ( [ 0 , 90 ] ) ( ) ) , Math . PI *  ( 2 + Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 135° South " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 135 ) . precision ( 0 . 1 ) . center ( [ 0 ,  - 90 ] ) ( ) ) , Math . PI *  ( 2 + Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles tiny " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - circles 135° South " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 135 ) . precision ( 0 . 1 ) . center ( [ 0 ,  - 90 ] ) ( ) ) , Math . PI *  ( 2 + Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles tiny " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( d3 . geoCircle ( ) . radius ( 1e - 6 ) . precision ( 0 . 1 ) ( ) ) , 0 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles huge " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 60° with 45° hole " , function ( test )  {%NWL%var circle = d3 . geoCircle ( ) . precision ( 0 . 1 ) ;%NWL%test . inDelta ( d3 . geoArea ( {%NWL%type: " Polygon " ,%NWL%coordinates: [%NWL%circle . radius ( 60 ) ( ) . coordinates [ 0 ] ,%NWL%circle . radius ( 45 ) ( ) . coordinates [ 0 ] . reverse ( )%NWL%]%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 45° holes at [ 0° , 0° ] and [ 0° , 90° ] " , function ( test )  {%NWL%var circle = d3 . geoCircle ( ) . precision ( 0 . 1 ) . radius ( 45 ) ;%NWL%test . inDelta ( d3 . geoArea ( {%NWL%type: " Polygon " ,%NWL%coordinates: [%NWL%circle . center ( [ 0 , 0 ] ) ( ) . coordinates [ 0 ] . reverse ( ) ,%NWL%circle . center ( [ 0 , 90 ] ) ( ) . coordinates [ 0 ] . reverse ( )%NWL%]%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - circles 45° holes at [ 0° , 90° ] and [ 0° , 0° ] " , function ( test )  {%NWL%var circle = d3 . geoCircle ( ) . precision ( 0 . 1 ) . radius ( 45 ) ;%NWL%test . inDelta ( d3 . geoArea ( {%NWL%type: " Polygon " ,%NWL%coordinates: [%NWL%circle . center ( [ 0 , 90 ] ) ( ) . coordinates [ 0 ] . reverse ( ) ,%NWL%circle . center ( [ 0 , 0 ] ) ( ) . coordinates [ 0 ] . reverse ( )%NWL%]%NWL%test . end ( ) ;%NWL%0
test . inDelta ( d3 . geoArea ( {%NWL%type: " Polygon " ,%NWL%coordinates: [%NWL%circle . center ( [ 0 , 90 ] ) ( ) . coordinates [ 0 ] . reverse ( ) ,%NWL%circle . center ( [ 0 , 0 ] ) ( ) . coordinates [ 0 ] . reverse ( )%NWL%]%NWL%} ) , Math . PI * 2 * Math . SQRT2 , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - stripes 45° ,  - 45° " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
circle . center ( [ 0 , 0 ] ) ( ) . coordinates [ 0 ] . reverse ( )%NWL%]%NWL%} ) , Math . PI * 2 * Math . SQRT2 , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - stripes 45° ,  - 45° " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( stripes ( 45 ,  - 45 ) ) , Math . PI * 2 * Math . SQRT2 , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - stripes - 45° , 45° " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Polygon - stripes 45° ,  - 45° " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( stripes ( 45 ,  - 45 ) ) , Math . PI * 2 * Math . SQRT2 , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - stripes - 45° , 45° " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( stripes ( - 45 , 45 ) ) , Math . PI * 2 *  ( 2 - Math . SQRT2 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - stripes 45° , 30° " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Polygon - stripes 45° , 30° " , function ( test )  {%NWL%test . inDelta ( d3 . geoArea ( stripes ( 45 , 30 ) ) , Math . PI *  ( Math . SQRT2 - 1 ) , 1e - 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: MultiPolygon two hemispheres " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " MultiPolygon " , coordinates: [%NWL%[ [ [ 0 , 0 ] ,  [ - 90 , 0 ] ,  [ 180 , 0 ] ,  [ 90 , 0 ] ,  [ 0 , 0 ] ] ] ,%NWL%[ [ [ 0 , 0 ] ,  [ 90 , 0 ] ,  [ 180 , 0 ] ,  [ - 90 , 0 ] ,  [ 0 , 0 ] ] ]%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: MultiPolygon two hemispheres " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " MultiPolygon " , coordinates: [%NWL%[ [ [ 0 , 0 ] ,  [ - 90 , 0 ] ,  [ 180 , 0 ] ,  [ 90 , 0 ] ,  [ 0 , 0 ] ] ] ,%NWL%[ [ [ 0 , 0 ] ,  [ 90 , 0 ] ,  [ 180 , 0 ] ,  [ - 90 , 0 ] ,  [ 0 , 0 ] ] ]%NWL%] } ) , 4 * Math . PI ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Sphere " , function ( test )  {%NWL%test . end ( ) ;%NWL%0
[ [ [ 0 , 0 ] ,  [ - 90 , 0 ] ,  [ 180 , 0 ] ,  [ 90 , 0 ] ,  [ 0 , 0 ] ] ] ,%NWL%[ [ [ 0 , 0 ] ,  [ 90 , 0 ] ,  [ 180 , 0 ] ,  [ - 90 , 0 ] ,  [ 0 , 0 ] ] ]%NWL%] } ) , 4 * Math . PI ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Sphere " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " Sphere " } ) , 4 * Math . PI ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: GeometryCollection " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: Sphere " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " Sphere " } ) , 4 * Math . PI ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: GeometryCollection " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " GeometryCollection " , geometries: [ { type: " Sphere " } ] } ) , 4 * Math . PI ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: FeatureCollection " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " area: GeometryCollection " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " GeometryCollection " , geometries: [ { type: " Sphere " } ] } ) , 4 * Math . PI ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: FeatureCollection " , function ( test )  {%NWL%test . equal ( d3 . geoArea ( { type: " FeatureCollection " , features: [ { type: " Feature " , geometry: { type: " Sphere " } } ] } ) , 4 * Math . PI ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area: Feature " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
coordinates: [ - 122 , 38 ]%NWL%}%NWL%]%NWL%} ) ,  [ [ - 123 , 38 ] ,  [ - 122 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: LineString - simple " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 123 , 39 ] ,  [ - 122 , 38 ] ]%NWL%test . end ( ) ;%NWL%4
} ) ,  [ [ - 123 , 38 ] ,  [ - 122 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: LineString - symmetry " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 30 ,  - 20 ] ,  [ 130 , 40 ] ]%NWL%} ) , d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 30 ,  - 20 ] ,  [ 130 , 40 ] ] . reverse ( )%NWL%test . end ( ) ;%NWL%1
} ) , d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 30 ,  - 20 ] ,  [ 130 , 40 ] ] . reverse ( )%NWL%} ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: LineString - containing coincident points " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 123 , 39 ] ,  [ - 122 , 38 ] ,  [ - 122 , 38 ] ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 123 , 39 ] ,  [ - 122 , 38 ] ,  [ - 122 , 38 ] ]%NWL%} ) ,  [ [ - 123 , 38 ] ,  [ - 122 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: LineString - meridian " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 0 , 60 ] ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 0 , 60 ] ]%NWL%} ) ,  [ [ 0 , 0 ] ,  [ 0 , 60 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: LineString - equator " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 60 , 0 ] ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 60 , 0 ] ]%NWL%} ) ,  [ [ 0 , 0 ] ,  [ 60 , 0 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: LineString - containing an inflection point in the Northern hemisphere " , function ( test )  {%NWL%test . inDelta ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 45 , 60 ] ,  [ 45 , 60 ] ]%NWL%test . end ( ) ;%NWL%4
test . inDelta ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 45 , 60 ] ,  [ 45 , 60 ] ]%NWL%} ) ,  [ [ - 45 , 60 ] ,  [ 45 , 67 . 792345 ] ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: LineString - containing an inflection point in the Southern hemisphere " , function ( test )  {%NWL%test . inDelta ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 45 ,  - 60 ] ,  [ 45 ,  - 60 ] ]%NWL%test . end ( ) ;%NWL%4
test . inDelta ( d3 . geoBounds ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 45 ,  - 60 ] ,  [ 45 ,  - 60 ] ]%NWL%} ) ,  [ [ - 45 ,  - 67 . 792345 ] ,  [ 45 ,  - 60 ] ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: MultiLineString " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiLineString " ,%NWL%coordinates: [ [ [ - 123 , 39 ] ,  [ - 122 , 38 ] ] ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiLineString " ,%NWL%coordinates: [ [ [ - 123 , 39 ] ,  [ - 122 , 38 ] ] ]%NWL%} ) ,  [ [ - 123 , 38 ] ,  [ - 122 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: MultiPoint - simple " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 123 , 39 ] ,  [ - 122 , 38 ] ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 123 , 39 ] ,  [ - 122 , 38 ] ]%NWL%} ) ,  [ [ - 123 , 38 ] ,  [ - 122 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: MultiPoint - two points near antimeridian " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 179 , 39 ] ,  [ 179 , 38 ] ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 179 , 39 ] ,  [ 179 , 38 ] ]%NWL%} ) ,  [ [ 179 , 38 ] ,  [ - 179 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: MultiPoint - two points near antimeridian , two points near primary meridian " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 179 , 39 ] ,  [ 179 , 38 ] ,  [ - 1 , 0 ] ,  [ 1 , 0 ] ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 179 , 39 ] ,  [ 179 , 38 ] ,  [ - 1 , 0 ] ,  [ 1 , 0 ] ]%NWL%} ) ,  [ [ - 1 , 0 ] ,  [ - 179 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: MultiPoint - two points near primary meridian , two points near antimeridian " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 1 , 0 ] ,  [ 1 , 0 ] ,  [ - 179 , 39 ] ,  [ 179 , 38 ] ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 1 , 0 ] ,  [ 1 , 0 ] ,  [ - 179 , 39 ] ,  [ 179 , 38 ] ]%NWL%} ) ,  [ [ - 1 , 0 ] ,  [ - 179 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: MultiPoint - four mixed points near primary meridian and antimeridian " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 1 , 0 ] ,  [ - 179 , 39 ] ,  [ 1 , 0 ] ,  [ 179 , 38 ] ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 1 , 0 ] ,  [ - 179 , 39 ] ,  [ 1 , 0 ] ,  [ 179 , 38 ] ]%NWL%} ) ,  [ [ - 1 , 0 ] ,  [ - 179 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: MultiPoint - three points near antimeridian " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ 178 , 38 ] ,  [ 179 , 39 ] ,  [ - 179 , 37 ] ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ 178 , 38 ] ,  [ 179 , 39 ] ,  [ - 179 , 37 ] ]%NWL%} ) ,  [ [ 178 , 37 ] ,  [ - 179 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: MultiPoint - various points near antimeridian " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 179 , 39 ] ,  [ - 179 , 38 ] ,  [ 178 , 39 ] ,  [ - 178 , 38 ] ]%NWL%test . end ( ) ;%NWL%4
} ) ,  [ [ 178 , 38 ] ,  [ - 178 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: MultiPolygon " , function ( test )  {%NWL%test . inDelta ( d3 . geoBounds ( {%NWL%type: " MultiPolygon " ,%NWL%coordinates: [%NWL%[ [ [ - 123 , 39 ] ,  [ - 122 , 39 ] ,  [ - 122 , 38 ] ,  [ - 123 , 39 ] ] ,%NWL%[ [ 10 , 20 ] ,  [ 20 , 20 ] ,  [ 20 , 10 ] ,  [ 10 , 10 ] ,  [ 10 , 20 ] ] ]%NWL%]%NWL%test . end ( ) ;%NWL%1
[ [ [ - 123 , 39 ] ,  [ - 122 , 39 ] ,  [ - 122 , 38 ] ,  [ - 123 , 39 ] ] ,%NWL%[ [ 10 , 20 ] ,  [ 20 , 20 ] ,  [ 20 , 10 ] ,  [ 10 , 10 ] ,  [ 10 , 20 ] ] ]%NWL%]%NWL%} ) ,  [ [ - 123 , 10 ] ,  [ 20 , 39 . 001067 ] ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: Point " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " Point " ,%NWL%coordinates: [ - 123 , 39 ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " Point " ,%NWL%coordinates: [ - 123 , 39 ]%NWL%} ) ,  [ [ - 123 , 39 ] ,  [ - 123 , 39 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: Polygon - simple " , function ( test )  {%NWL%test . inDelta ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ - 123 , 39 ] ,  [ - 122 , 39 ] ,  [ - 122 , 38 ] ,  [ - 123 , 39 ] ] ]%NWL%test . end ( ) ;%NWL%4
test . inDelta ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ - 123 , 39 ] ,  [ - 122 , 39 ] ,  [ - 122 , 38 ] ,  [ - 123 , 39 ] ] ]%NWL%} ) ,  [ [ - 123 , 38 ] ,  [ - 122 , 39 . 001067 ] ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: Polygon - larger than a hemisphere , small , counter - clockwise " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ 0 , 0 ] ,  [ 10 , 0 ] ,  [ 10 , 10 ] ,  [ 0 , 10 ] ,  [ 0 , 0 ] ] ]%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ 0 , 0 ] ,  [ 10 , 0 ] ,  [ 10 , 10 ] ,  [ 0 , 10 ] ,  [ 0 , 0 ] ] ]%NWL%} ) ,  [ [ - 180 ,  - 90 ] ,  [ 180 , 90 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: Polygon - larger than a hemisphere , large lat - lon rectangle " , function ( test )  {%NWL%test . inDelta ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ - 170 , 80 ] ,  [ 0 , 80 ] ,  [ 170 , 80 ] ,  [ 170 ,  - 80 ] ,  [ 0 ,  - 80 ] ,  [ - 170 ,  - 80 ] ,  [ - 170 , 80 ] ] ]%NWL%test . end ( ) ;%NWL%4
test . inDelta ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ - 170 , 80 ] ,  [ 0 , 80 ] ,  [ 170 , 80 ] ,  [ 170 ,  - 80 ] ,  [ 0 ,  - 80 ] ,  [ - 170 ,  - 80 ] ,  [ - 170 , 80 ] ] ]%NWL%} ) ,  [ [ - 170 ,  - 89 . 119552 ] ,  [ 170 , 89 . 119552 ] ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: Polygon - larger than a hemisphere , South pole " , function ( test )  {%NWL%test . inDelta ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ 10 , 80 ] ,  [ 170 , 80 ] ,  [ - 170 , 80 ] ,  [ - 10 , 80 ] ,  [ 10 , 80 ] ] ]%NWL%test . end ( ) ;%NWL%4
test . inDelta ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ 10 , 80 ] ,  [ 170 , 80 ] ,  [ - 170 , 80 ] ,  [ - 10 , 80 ] ,  [ 10 , 80 ] ] ]%NWL%} ) ,  [ [ - 180 ,  - 90 ] ,  [ 180 , 88 . 246216 ] ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: Polygon - larger than a hemisphere , excluding both poles " , function ( test )  {%NWL%test . inDelta ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ 10 , 80 ] ,  [ 170 , 80 ] ,  [ - 170 , 80 ] ,  [ - 10 , 80 ] ,  [ - 10 , 0 ] ,  [ - 10 ,  - 80 ] ,  [ - 170 ,  - 80 ] ,  [ 170 ,  - 80 ] ,  [ 10 ,  - 80 ] ,  [ 10 , 0 ] ,  [ 10 , 80 ] ] ]%NWL%test . end ( ) ;%NWL%4
test . inDelta ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ 10 , 80 ] ,  [ 170 , 80 ] ,  [ - 170 , 80 ] ,  [ - 10 , 80 ] ,  [ - 10 , 0 ] ,  [ - 10 ,  - 80 ] ,  [ - 170 ,  - 80 ] ,  [ 170 ,  - 80 ] ,  [ 10 ,  - 80 ] ,  [ 10 , 0 ] ,  [ 10 , 80 ] ] ]%NWL%} ) ,  [ [ 10 ,  - 88 . 246216 ] ,  [ - 10 , 88 . 246216 ] ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: Polygon - South pole " , function ( test )  {%NWL%test . deepEqual ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ - 60 ,  - 80 ] ,  [ 60 ,  - 80 ] ,  [ 180 ,  - 80 ] ,  [ - 60 ,  - 80 ] ] ]%NWL%test . end ( ) ;%NWL%4
} ) ,  [ [ - 180 ,  - 90 ] ,  [ 180 ,  - 80 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: Polygon - ring " , function ( test )  {%NWL%test . inDelta ( d3 . geoBounds ( {%NWL%type: " Polygon " ,%NWL%coordinates: [%NWL%[ [ - 60 ,  - 80 ] ,  [ 60 ,  - 80 ] ,  [ 180 ,  - 80 ] ,  [ - 60 ,  - 80 ] ] ,%NWL%[ [ - 60 ,  - 89 ] ,  [ 180 ,  - 89 ] ,  [ 60 ,  - 89 ] ,  [ - 60 ,  - 89 ] ]%NWL%]%NWL%test . end ( ) ;%NWL%1
}%NWL%]%NWL%} ) ,  [ [ - 120 , 46 ] ,  [ - 119 , 47 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - Feature " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " Feature " , geometry: null } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " bounds: null geometries - Feature " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " Feature " , geometry: null } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiPoint " , function ( test )  {%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%3
tape ( " bounds: null geometries - Feature " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " Feature " , geometry: null } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiPoint " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiPoint " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%3
var b = d3 . geoBounds ( { type: " Feature " , geometry: null } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiPoint " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiPoint " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%3
test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiPoint " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiPoint " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%3
test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiPoint " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiPoint " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " bounds: null geometries - MultiPoint " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiPoint " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiLineString " , function ( test )  {%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%3
tape ( " bounds: null geometries - MultiPoint " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiPoint " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiLineString " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiLineString " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%3
var b = d3 . geoBounds ( { type: " MultiPoint " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiLineString " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiLineString " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%3
test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiLineString " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiLineString " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%3
test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiLineString " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiLineString " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " bounds: null geometries - MultiLineString " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiLineString " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiPolygon " , function ( test )  {%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%3
tape ( " bounds: null geometries - MultiLineString " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiLineString " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiPolygon " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiPolygon " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%3
var b = d3 . geoBounds ( { type: " MultiLineString " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiPolygon " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiPolygon " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%3
test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiPolygon " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiPolygon " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%3
test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 1 ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " bounds: null geometries - MultiPolygon " , function ( test )  {%NWL%var b = d3 . geoBounds ( { type: " MultiPolygon " , coordinates: [ ] } ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 0 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 0 ] [ 1 ] ) ) ;%NWL%test . assert ( isNaN ( b [ 1 ] [ 0 ] ) ) ;%NWL%test . end ( ) ;%NWL%3
tape ( " the centroid of a point is itself " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Point " , coordinates: [ 0 , 0 ] } ) ,  [ 0 , 0 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Point " , coordinates: [ 1 , 1 ] } ) ,  [ 1 , 1 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Point " , coordinates: [ 2 , 3 ] } ) ,  [ 2 , 3 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Point " , coordinates: [ - 4 ,  - 5 ] } ) ,  [ - 4 ,  - 5 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a set of points is the ( spherical ) average of its constituent members " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [ { type: " Point " , coordinates: [ 0 , 0 ] } ,  { type: " Point " , coordinates: [ 1 , 2 ] } ] } ) ,  [ 0 . 499847 , 1 . 000038 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } ) ,  [ 0 . 499847 , 1 . 000038 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " the centroid of a set of points is the ( spherical ) average of its constituent members " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [ { type: " Point " , coordinates: [ 0 , 0 ] } ,  { type: " Point " , coordinates: [ 1 , 2 ] } ] } ) ,  [ 0 . 499847 , 1 . 000038 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } ) ,  [ 0 . 499847 , 1 . 000038 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " MultiPoint " , coordinates: [ [ 179 , 0 ] ,  [ - 179 , 0 ] ] } ) ,  [ 180 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a set of points and their antipodes is ambiguous " , function ( test )  {%NWL%test . ok ( d3 . geoCentroid ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 180 , 0 ] ] } ) . every ( isNaN ) ) ;%NWL%test . ok ( d3 . geoCentroid ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 90 , 0 ] ,  [ 180 , 0 ] ,  [ - 90 , 0 ] ] } ) . every ( isNaN ) ) ;%NWL%test . end ( ) ;%NWL%5
test . inDelta ( d3 . geoCentroid ( { type: " MultiPoint " , coordinates: [ [ 179 , 0 ] ,  [ - 179 , 0 ] ] } ) ,  [ 180 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a set of points and their antipodes is ambiguous " , function ( test )  {%NWL%test . ok ( d3 . geoCentroid ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 180 , 0 ] ] } ) . every ( isNaN ) ) ;%NWL%test . ok ( d3 . geoCentroid ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 90 , 0 ] ,  [ 180 , 0 ] ,  [ - 90 , 0 ] ] } ) . every ( isNaN ) ) ;%NWL%test . ok ( d3 . geoCentroid ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 0 , 90 ] ,  [ 180 , 0 ] ,  [ 0 ,  - 90 ] ] } ) . every ( isNaN ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of the empty set of points is ambiguous " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a line string is the ( spherical ) average of its constituent great arc segments " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 0 ] ] } ) ,  [ 0 . 5 , 0 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 0 , 90 ] ] } ) ,  [ 0 , 45 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 0 , 45 ] ,  [ 0 , 90 ] ] } ) ,  [ 0 , 45 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ - 1 ,  - 1 ] ,  [ 1 , 1 ] ] } ) ,  [ 0 , 0 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ - 60 ,  - 1 ] ,  [ 60 , 1 ] ] } ) ,  [ 0 , 0 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 179 ,  - 1 ] ,  [ - 179 , 1 ] ] } ) ,  [ 180 , 0 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ - 179 , 0 ] ,  [ 0 , 0 ] ,  [ 179 , 0 ] ] } ) ,  [ 0 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%0
test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 0 , 45 ] ,  [ 0 , 90 ] ] } ) ,  [ 0 , 45 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ - 1 ,  - 1 ] ,  [ 1 , 1 ] ] } ) ,  [ 0 , 0 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ - 60 ,  - 1 ] ,  [ 60 , 1 ] ] } ) ,  [ 0 , 0 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 179 ,  - 1 ] ,  [ - 179 , 1 ] ] } ) ,  [ 180 , 0 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ - 179 , 0 ] ,  [ 0 , 0 ] ,  [ 179 , 0 ] ] } ) ,  [ 0 , 0 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ - 180 ,  - 90 ] ,  [ 0 , 0 ] ,  [ 0 , 90 ] ] } ) ,  [ 0 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a great arc from a point to its antipode is ambiguous " , function ( test )  {%NWL%test . ok ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 180 , 0 ] ,  [ 0 , 0 ] ] } ) . every ( isNaN ) ) ;%NWL%test . end ( ) ;%NWL%6
test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ - 179 , 0 ] ,  [ 0 , 0 ] ,  [ 179 , 0 ] ] } ) ,  [ 0 , 0 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ - 180 ,  - 90 ] ,  [ 0 , 0 ] ,  [ 0 , 90 ] ] } ) ,  [ 0 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a great arc from a point to its antipode is ambiguous " , function ( test )  {%NWL%test . ok ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 180 , 0 ] ,  [ 0 , 0 ] ] } ) . every ( isNaN ) ) ;%NWL%test . ok ( d3 . geoCentroid ( { type: " MultiLineString " , coordinates: [ [ [ 0 ,  - 90 ] ,  [ 0 , 90 ] ] ] } ) . every ( isNaN ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a set of line strings is the ( spherical ) average of its constituent great arc segments " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . ok ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 180 , 0 ] ,  [ 0 , 0 ] ] } ) . every ( isNaN ) ) ;%NWL%test . ok ( d3 . geoCentroid ( { type: " MultiLineString " , coordinates: [ [ [ 0 ,  - 90 ] ,  [ 0 , 90 ] ] ] } ) . every ( isNaN ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a set of line strings is the ( spherical ) average of its constituent great arc segments " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " MultiLineString " , coordinates: [ [ [ 0 , 0 ] ,  [ 0 , 2 ] ] ] } ) ,  [ 0 , 1 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a line of zero length is treated as points " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 1 , 1 ] ,  [ 1 , 1 ] ] } ) ,  [ 1 , 1 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%2
test . inDelta ( d3 . geoCentroid ( { type: " MultiLineString " , coordinates: [ [ [ 0 , 0 ] ,  [ 0 , 2 ] ] ] } ) ,  [ 0 , 1 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a line of zero length is treated as points " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 1 , 1 ] ,  [ 1 , 1 ] ] } ) ,  [ 1 , 1 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [ { type: " Point " , coordinates: [ 0 , 0 ] } ,  { type: " LineString " , coordinates: [ [ 1 , 2 ] ,  [ 1 , 2 ] ] } ] } ) ,  [ 0 . 666534 , 1 . 333408 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " an empty polygon with non - zero extent is treated as a line " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 1 , 1 ] ,  [ 2 , 1 ] ,  [ 3 , 1 ] ,  [ 2 , 1 ] ,  [ 1 , 1 ] ] ] } ) ,  [ 2 , 1 . 000076 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%1
test . inDelta ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [ { type: " Point " , coordinates: [ 0 , 0 ] } ,  { type: " LineString " , coordinates: [ [ 1 , 2 ] ,  [ 1 , 2 ] ] } ] } ) ,  [ 0 . 666534 , 1 . 333408 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " an empty polygon with non - zero extent is treated as a line " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 1 , 1 ] ,  [ 2 , 1 ] ,  [ 3 , 1 ] ,  [ 2 , 1 ] ,  [ 1 , 1 ] ] ] } ) ,  [ 2 , 1 . 000076 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [ { type: " Point " , coordinates: [ 0 , 0 ] } ,  { type: " Polygon " , coordinates: [ [ [ 1 , 2 ] ,  [ 1 , 2 ] ,  [ 1 , 2 ] ,  [ 1 , 2 ] ] ] } ] } ) ,  [ 0 . 799907 , 1 . 600077 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " an empty polygon with zero extent is treated as a point " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 1 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 1 ] ] ] } ) ,  [ 1 , 1 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%1
test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 1 , 1 ] ,  [ 2 , 1 ] ,  [ 3 , 1 ] ,  [ 2 , 1 ] ,  [ 1 , 1 ] ] ] } ) ,  [ 2 , 1 . 000076 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [ { type: " Point " , coordinates: [ 0 , 0 ] } ,  { type: " Polygon " , coordinates: [ [ [ 1 , 2 ] ,  [ 1 , 2 ] ,  [ 1 , 2 ] ,  [ 1 , 2 ] ] ] } ] } ) ,  [ 0 . 799907 , 1 . 600077 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " an empty polygon with zero extent is treated as a point " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 1 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 1 ] ] ] } ) ,  [ 1 , 1 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [ { type: " Point " , coordinates: [ 0 , 0 ] } ,  { type: " Polygon " , coordinates: [ [ [ 1 , 2 ] ,  [ 1 , 2 ] ,  [ 1 , 2 ] ,  [ 1 , 2 ] ] ] } ] } ) ,  [ 0 . 799907 , 1 . 600077 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of the equator is ambiguous " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . inDelta ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [ { type: " Point " , coordinates: [ 0 , 0 ] } ,  { type: " Polygon " , coordinates: [ [ [ 1 , 2 ] ,  [ 1 , 2 ] ,  [ 1 , 2 ] ,  [ 1 , 2 ] ] ] } ] } ) ,  [ 0 . 799907 , 1 . 600077 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of the equator is ambiguous " , function ( test )  {%NWL%test . ok ( d3 . geoCentroid ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 120 , 0 ] ,  [ - 120 , 0 ] ,  [ 0 , 0 ] ] } ) . every ( isNaN ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a polygon is the ( spherical ) average of its surface " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 0 ,  - 90 ] ,  [ 0 , 0 ] ,  [ 0 , 90 ] ,  [ 1 , 0 ] ,  [ 0 ,  - 90 ] ] ] } ) ,  [ 0 . 5 , 0 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ array . range ( - 180 , 180 + 1 / 2 , 1 ) . map ( function ( x )  { return [ x ,  - 60 ] ; } ) ] } ) [ 1 ] ,  - 90 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a set of polygons is the ( spherical ) average of its surface " , function ( test )  {%NWL%var circle = d3 . geoCircle ( ) ;%NWL%test . inDelta ( d3 . geoCentroid ( {%NWL%type: " MultiPolygon " ,%NWL%coordinates: [%NWL%circle . radius ( 45 ) . center ( [ 90 , 0 ] ) ( ) . coordinates ,%NWL%circle . radius ( 60 ) . center ( [ - 90 , 0 ] ) ( ) . coordinates%NWL%]%NWL%test . end ( ) ;%NWL%0
test . inDelta ( d3 . geoCentroid ( {%NWL%type: " MultiPolygon " ,%NWL%coordinates: [%NWL%circle . radius ( 45 ) . center ( [ 90 , 0 ] ) ( ) . coordinates ,%NWL%circle . radius ( 60 ) . center ( [ - 90 , 0 ] ) ( ) . coordinates%NWL%]%NWL%} ) ,  [ - 90 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a lune is the ( spherical ) average of its surface " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
circle . radius ( 60 ) . center ( [ - 90 , 0 ] ) ( ) . coordinates%NWL%]%NWL%} ) ,  [ - 90 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a lune is the ( spherical ) average of its surface " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 0 ,  - 90 ] ,  [ 0 , 0 ] ,  [ 0 , 90 ] ,  [ 1 , 0 ] ,  [ 0 ,  - 90 ] ] ] } ) ,  [ 0 . 5 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: 5° " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " the centroid of a lune is the ( spherical ) average of its surface " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 0 ,  - 90 ] ,  [ 0 , 0 ] ,  [ 0 , 90 ] ,  [ 1 , 0 ] ,  [ 0 ,  - 90 ] ] ] } ) ,  [ 0 . 5 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: 5° " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( d3 . geoCircle ( ) . radius ( 5 ) . center ( [ 30 , 45 ] ) ( ) ) ,  [ 30 , 45 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: 135° " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " the centroid of a small circle is its center: 5° " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( d3 . geoCircle ( ) . radius ( 5 ) . center ( [ 30 , 45 ] ) ( ) ) ,  [ 30 , 45 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: 135° " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( d3 . geoCircle ( ) . radius ( 135 ) . center ( [ 30 , 45 ] ) ( ) ) ,  [ 30 , 45 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: South Pole " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " the centroid of a small circle is its center: 135° " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( d3 . geoCircle ( ) . radius ( 135 ) . center ( [ 30 , 45 ] ) ( ) ) ,  [ 30 , 45 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: South Pole " , function ( test )  {%NWL%test . equal ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ array . range ( - 180 , 180 + 1 / 2 , 1 ) . map ( function ( x )  { return [ x ,  - 60 ] ; } ) ] } ) [ 1 ] ,  - 90 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: equator " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " the centroid of a small circle is its center: South Pole " , function ( test )  {%NWL%test . equal ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ array . range ( - 180 , 180 + 1 / 2 , 1 ) . map ( function ( x )  { return [ x ,  - 60 ] ; } ) ] } ) [ 1 ] ,  - 90 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: equator " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 0 ,  - 10 ] ,  [ 0 , 10 ] ,  [ 10 , 10 ] ,  [ 10 ,  - 10 ] ,  [ 0 ,  - 10 ] ] ] } ) ,  [ 5 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: equator with coincident points " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " the centroid of a small circle is its center: equator " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 0 ,  - 10 ] ,  [ 0 , 10 ] ,  [ 10 , 10 ] ,  [ 10 ,  - 10 ] ,  [ 0 ,  - 10 ] ] ] } ) ,  [ 5 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: equator with coincident points " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 0 ,  - 10 ] ,  [ 0 , 10 ] ,  [ 0 , 10 ] ,  [ 10 , 10 ] ,  [ 10 ,  - 10 ] ,  [ 0 ,  - 10 ] ] ] } ) ,  [ 5 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: other " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: other " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ - 180 , 0 ] ,  [ - 180 , 10 ] ,  [ - 179 , 10 ] ,  [ - 179 , 0 ] ,  [ - 180 , 0 ] ] ] } ) ,  [ - 179 . 5 , 4 . 987448 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: concentric rings " , function ( test )  {%NWL%var circle = d3 . geoCircle ( ) . center ( [ 0 , 45 ] ) ,%NWL%coordinates = circle . radius ( 60 ) ( ) . coordinates;%NWL%coordinates . push ( circle . radius ( 45 ) ( ) . coordinates [ 0 ] . reverse ( ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a small circle is its center: concentric rings " , function ( test )  {%NWL%var circle = d3 . geoCircle ( ) . center ( [ 0 , 45 ] ) ,%NWL%coordinates = circle . radius ( 60 ) ( ) . coordinates;%NWL%coordinates . push ( circle . radius ( 45 ) ( ) . coordinates [ 0 ] . reverse ( ) ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: coordinates } ) ,  [ 0 , 45 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a spherical square on the equator " , function ( test )  {%NWL%test . end ( ) ;%NWL%0
coordinates = circle . radius ( 60 ) ( ) . coordinates;%NWL%coordinates . push ( circle . radius ( 45 ) ( ) . coordinates [ 0 ] . reverse ( ) ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: coordinates } ) ,  [ 0 , 45 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a spherical square on the equator " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ 0 ,  - 10 ] ,  [ 0 , 10 ] ,  [ 10 , 10 ] ,  [ 10 ,  - 10 ] ,  [ 0 ,  - 10 ] ] ] } ) ,  [ 5 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a spherical square touching the antimeridian " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a spherical square touching the antimeridian " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: [ [ [ - 180 , 0 ] ,  [ - 180 , 10 ] ,  [ - 179 , 10 ] ,  [ - 179 , 0 ] ,  [ - 180 , 0 ] ] ] } ) ,  [ - 179 . 5 , 4 . 987448 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " concentric rings " , function ( test )  {%NWL%var circle = d3 . geoCircle ( ) . center ( [ 0 , 45 ] ) ,%NWL%coordinates = circle . radius ( 60 ) ( ) . coordinates;%NWL%coordinates . push ( circle . radius ( 45 ) ( ) . coordinates [ 0 ] . reverse ( ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " concentric rings " , function ( test )  {%NWL%var circle = d3 . geoCircle ( ) . center ( [ 0 , 45 ] ) ,%NWL%coordinates = circle . radius ( 60 ) ( ) . coordinates;%NWL%coordinates . push ( circle . radius ( 45 ) ( ) . coordinates [ 0 ] . reverse ( ) ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: coordinates } ) ,  [ 0 , 45 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a sphere is ambiguous " , function ( test )  {%NWL%test . end ( ) ;%NWL%0
test . inDelta ( d3 . geoCentroid ( { type: " Polygon " , coordinates: coordinates } ) ,  [ 0 , 45 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a sphere is ambiguous " , function ( test )  {%NWL%test . ok ( d3 . geoCentroid ( { type: " Sphere " } ) . every ( isNaN ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a feature is the centroid of its constituent geometry " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Feature " , geometry: { type: " LineString " , coordinates: [ [ 1 , 1 ] ,  [ 1 , 1 ] ] } } ) ,  [ 1 , 1 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Feature " , geometry: { type: " Point " , coordinates: [ 1 , 1 ] } } ) ,  [ 1 , 1 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%1
tape ( " the centroid of a feature is the centroid of its constituent geometry " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Feature " , geometry: { type: " LineString " , coordinates: [ [ 1 , 1 ] ,  [ 1 , 1 ] ] } } ) ,  [ 1 , 1 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Feature " , geometry: { type: " Point " , coordinates: [ 1 , 1 ] } } ) ,  [ 1 , 1 ] , 1e - 6 ) ;%NWL%test . inDelta ( d3 . geoCentroid ( { type: " Feature " , geometry: { type: " Polygon " , coordinates: [ [ [ 0 ,  - 90 ] ,  [ 0 , 0 ] ,  [ 0 , 90 ] ,  [ 1 , 0 ] ,  [ 0 ,  - 90 ] ] ] } } ) ,  [ 0 . 5 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a feature collection is the centroid of its constituent geometry " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " FeatureCollection " , features: [%NWL%{ type: " Feature " , geometry: { type: " LineString " , coordinates: [ [ 179 , 0 ] ,  [ 180 , 0 ] ] } } ,%NWL%{ type: " Feature " , geometry: { type: " Point " , coordinates: [ 0 , 0 ] } }%NWL%test . end ( ) ;%NWL%4
test . inDelta ( d3 . geoCentroid ( { type: " FeatureCollection " , features: [%NWL%{ type: " Feature " , geometry: { type: " LineString " , coordinates: [ [ 179 , 0 ] ,  [ 180 , 0 ] ] } } ,%NWL%{ type: " Feature " , geometry: { type: " Point " , coordinates: [ 0 , 0 ] } }%NWL%] } ) ,  [ 179 . 5 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a non - empty line string and a point only considers the line string " , function ( test )  {%NWL%test . inDelta ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [%NWL%{ type: " LineString " , coordinates: [ [ 179 , 0 ] ,  [ 180 , 0 ] ] } ,%NWL%{ type: " Point " , coordinates: [ 0 , 0 ] }%NWL%test . end ( ) ;%NWL%4
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of the sphere and a point is the point " , function ( test )  {%NWL%test . deepEqual ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [%NWL%{ type: " Sphere " } ,%NWL%{ type: " Point " , coordinates: [ 0 , 0 ] }%NWL%] } ) ,  [ 0 , 0 ] ) ;%NWL%test . deepEqual ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [%NWL%{ type: " Point " , coordinates: [ 0 , 0 ] } ,%NWL%{ type: " Sphere " }%NWL%test . end ( ) ;%NWL%0
{ type: " Point " , coordinates: [ 0 , 0 ] }%NWL%] } ) ,  [ 0 , 0 ] ) ;%NWL%test . deepEqual ( d3 . geoCentroid ( { type: " GeometryCollection " , geometries: [%NWL%{ type: " Point " , coordinates: [ 0 , 0 ] } ,%NWL%{ type: " Sphere " }%NWL%] } ) ,  [ 0 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " the centroid of a detailed feature is correct " , function ( test )  {%NWL%var ny = require ( " . / data / ny . json " ) ;%NWL%test . end ( ) ;%NWL%6
array = require ( " d3 - array " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%tape ( " a sphere contains any point " , function ( test )  {%NWL%test . equal ( d3 . geoContains ( { type: " Sphere " } ,  [ 0 , 0 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a point contains itself ( and not some other point ) " , function ( test )  {%NWL%test . equal ( d3 . geoContains ( { type: " Point " , coordinates: [ 0 , 0 ] } ,  [ 0 , 0 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " Point " , coordinates: [ 1 , 2 ] } ,  [ 1 , 2 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " Point " , coordinates: [ 0 , 0 ] } ,  [ 0 , 1 ] ) , false ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " a point contains itself ( and not some other point ) " , function ( test )  {%NWL%test . equal ( d3 . geoContains ( { type: " Point " , coordinates: [ 0 , 0 ] } ,  [ 0 , 0 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " Point " , coordinates: [ 1 , 2 ] } ,  [ 1 , 2 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " Point " , coordinates: [ 0 , 0 ] } ,  [ 0 , 1 ] ) , false ) ;%NWL%test . equal ( d3 . geoContains ( { type: " Point " , coordinates: [ 1 , 1 ] } ,  [ 1 , 0 ] ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a MultiPoint contains any of its points " , function ( test )  {%NWL%test . equal ( d3 . geoContains ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } ,  [ 0 , 0 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } ,  [ 1 , 2 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%5
test . equal ( d3 . geoContains ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } ,  [ 0 , 0 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } ,  [ 1 , 2 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " MultiPoint " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } ,  [ 1 , 3 ] ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a LineString contains any point on the Great Circle path " , function ( test )  {%NWL%test . equal ( d3 . geoContains ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } ,  [ 0 , 0 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } ,  [ 1 , 2 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } , d3 . geoInterpolate ( [ 0 , 0 ] ,  [ 1 , 2 ] ) ( 0 . 3 ) ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } , d3 . geoInterpolate ( [ 0 , 0 ] ,  [ 1 , 2 ] ) ( 1 . 3 ) ) , false ) ;%NWL%test . end ( ) ;%NWL%3
tape ( " a LineString contains any point on the Great Circle path " , function ( test )  {%NWL%test . equal ( d3 . geoContains ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } ,  [ 0 , 0 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } ,  [ 1 , 2 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } , d3 . geoInterpolate ( [ 0 , 0 ] ,  [ 1 , 2 ] ) ( 0 . 3 ) ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } , d3 . geoInterpolate ( [ 0 , 0 ] ,  [ 1 , 2 ] ) ( 1 . 3 ) ) , false ) ;%NWL%test . equal ( d3 . geoContains ( { type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 1 , 2 ] ] } , d3 . geoInterpolate ( [ 0 , 0 ] ,  [ 1 , 2 ] ) ( - 0 . 3 ) ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a MultiLineString contains any point on one of its components " , function ( test )  {%NWL%test . equal ( d3 . geoContains ( { type: " MultiLineString " , coordinates: [ [ [ 0 , 0 ] ,  [ 1 , 2 ] ] ,  [ [ 2 , 3 ] ,  [ 4 , 5 ] ] ] } ,  [ 2 , 3 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a MultiLineString contains any point on one of its components " , function ( test )  {%NWL%test . equal ( d3 . geoContains ( { type: " MultiLineString " , coordinates: [ [ [ 0 , 0 ] ,  [ 1 , 2 ] ] ,  [ [ 2 , 3 ] ,  [ 4 , 5 ] ] ] } ,  [ 2 , 3 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( { type: " MultiLineString " , coordinates: [ [ [ 0 , 0 ] ,  [ 1 , 2 ] ] ,  [ [ 2 , 3 ] ,  [ 4 , 5 ] ] ] } ,  [ 5 , 6 ] ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a Polygon contains a point " , function ( test )  {%NWL%var polygon = d3 . geoCircle ( ) . radius ( 60 ) ( ) ;%NWL%test . equal ( d3 . geoContains ( polygon ,  [ 1 , 1 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( d3 . geoContains ( polygon ,  [ 1 , 1 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( polygon ,  [ - 180 , 0 ] ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a Polygon with a hole doesn ' t contain a point " , function ( test )  {%NWL%var outer = d3 . geoCircle ( ) . radius ( 60 ) ( ) . coordinates [ 0 ] ,%NWL%inner = d3 . geoCircle ( ) . radius ( 3 ) ( ) . coordinates [ 0 ] ,%NWL%polygon = { type: " Polygon " , coordinates: [ outer , inner ] } ;%NWL%test . equal ( d3 . geoContains ( polygon ,  [ 1 , 1 ] ) , false ) ;%NWL%test . equal ( d3 . geoContains ( polygon ,  [ 5 , 0 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( d3 . geoContains ( polygon ,  [ 5 , 0 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( polygon ,  [ 65 , 0 ] ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a MultiPolygon contains a point " , function ( test )  {%NWL%var p1 = d3 . geoCircle ( ) . radius ( 6 ) ( ) . coordinates ,%NWL%p2 = d3 . geoCircle ( ) . radius ( 6 ) . center ( [ 90 , 0 ] ) ( ) . coordinates ,%NWL%polygon = { type: " MultiPolygon " , coordinates: [ p1 , p2 ] } ;%NWL%test . equal ( d3 . geoContains ( polygon ,  [ 1 , 0 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( polygon ,  [ 90 , 1 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( d3 . geoContains ( collection ,  [ 12 , 25 ] ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a Feature contains a point " , function ( test )  {%NWL%var feature = {%NWL%type: " Feature " , geometry: {%NWL%type: " LineString " , coordinates: [ [ 0 , 0 ] ,  [ 45 , 0 ] ]%NWL%}%NWL%} ;%NWL%test . equal ( d3 . geoContains ( feature ,  [ 45 , 0 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%1
featureCollection = {%NWL%type: " FeatureCollection " ,%NWL%features: [ feature1 , feature2 ]%NWL%} ;%NWL%test . equal ( d3 . geoContains ( featureCollection ,  [ 45 , 0 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( featureCollection ,  [ - 45 , 0 ] ) , true ) ;%NWL%test . equal ( d3 . geoContains ( featureCollection ,  [ 12 , 25 ] ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " null contains nothing " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%require ( " . / inDelta " ) ;%NWL%tape ( " geoDistance ( a , b ) computes the great - arc distance in radians between the two points a and b " , function ( test )  {%NWL%test . equal ( d3 . geoDistance ( [ 0 , 0 ] ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . inDelta ( d3 . geoDistance ( [ 118 + 24 / 60 , 33 + 57 / 60 ] ,  [ 73 + 47 / 60 , 40 + 38 / 60 ] ) , 3973 / 6371 , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoDistance ( a , b ) correctly computes small distances " , function ( test )  {%NWL%test . end ( ) ;%NWL%6
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%require ( " . / inDelta " ) ;%NWL%tape ( " geoInterpolate ( a , a ) returns a " , function ( test )  {%NWL%test . deepEqual ( d3 . geoInterpolate ( [ 140 . 63289 ,  - 29 . 95101 ] ,  [ 140 . 63289 ,  - 29 . 95101 ] ) ( 0 . 5 ) ,  [ 140 . 63289 ,  - 29 . 95101 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoInterpolate ( a , b ) returns the expected values when a and b lie on the equator " , function ( test )  {%NWL%test . end ( ) ;%NWL%5
require ( " . / inDelta " ) ;%NWL%tape ( " geoInterpolate ( a , a ) returns a " , function ( test )  {%NWL%test . deepEqual ( d3 . geoInterpolate ( [ 140 . 63289 ,  - 29 . 95101 ] ,  [ 140 . 63289 ,  - 29 . 95101 ] ) ( 0 . 5 ) ,  [ 140 . 63289 ,  - 29 . 95101 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoInterpolate ( a , b ) returns the expected values when a and b lie on the equator " , function ( test )  {%NWL%test . inDelta ( d3 . geoInterpolate ( [ 10 , 0 ] ,  [ 20 , 0 ] ) ( 0 . 5 ) ,  [ 15 , 0 ] , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoInterpolate ( a , b ) returns the expected values when a and b lie on a meridian " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
function polygonContains ( polygon , point )  {%NWL%return contains ( polygon . map ( ringRadians ) , pointRadians ( point ) ) ;%NWL%}%NWL%tape ( " geoPolygonContains ( empty , point ) returns false " , function ( test )  {%NWL%test . equal ( polygonContains ( [ ] ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( simple , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 . 1 , 2 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " geoPolygonContains ( simple , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 . 1 , 2 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 . 1 , 0 . 1 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( smallCircle , point ) returns the expected value " , function ( test )  {%NWL%var polygon = d3_geo . geoCircle ( ) . radius ( 60 ) ( ) . coordinates;%NWL%test . equal ( polygonContains ( polygon ,  [ - 180 , 0 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " geoPolygonContains ( smallCircle , point ) returns the expected value " , function ( test )  {%NWL%var polygon = d3_geo . geoCircle ( ) . radius ( 60 ) ( ) . coordinates;%NWL%test . equal ( polygonContains ( polygon ,  [ - 180 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 1 , 1 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( southPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 60 ,  - 80 ] ,  [ 60 ,  - 80 ] ,  [ 180 ,  - 80 ] ,  [ - 60 ,  - 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%5
test . equal ( polygonContains ( polygon ,  [ 1 , 1 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( southPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 60 ,  - 80 ] ,  [ 60 ,  - 80 ] ,  [ 180 ,  - 80 ] ,  [ - 60 ,  - 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 85 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( northPole , point ) returns the expected value " , function ( test )  {%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%5
} ) ;%NWL%tape ( " geoPolygonContains ( southPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 60 ,  - 80 ] ,  [ 60 ,  - 80 ] ,  [ 180 ,  - 80 ] ,  [ - 60 ,  - 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 85 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( northPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 60 , 80 ] ,  [ - 60 , 80 ] ,  [ - 180 , 80 ] ,  [ 60 , 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " geoPolygonContains ( northPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 60 , 80 ] ,  [ - 60 , 80 ] ,  [ - 180 , 80 ] ,  [ 60 , 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 85 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( largeNearOrigin , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 . 1 , 0 . 1 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " geoPolygonContains ( largeNearOrigin , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 . 1 , 0 . 1 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 2 , 0 . 1 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( largeNearSouthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 60 , 80 ] ,  [ 60 , 80 ] ,  [ 180 , 80 ] ,  [ - 60 , 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 85 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( largeNearSouthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 60 , 80 ] ,  [ 60 , 80 ] ,  [ 180 , 80 ] ,  [ - 60 , 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 85 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( largeNearNorthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 60 ,  - 80 ] ,  [ - 60 ,  - 80 ] ,  [ - 180 ,  - 80 ] ,  [ 60 ,  - 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%5
} ) ;%NWL%tape ( " geoPolygonContains ( largeNearSouthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 60 , 80 ] ,  [ 60 , 80 ] ,  [ 180 , 80 ] ,  [ - 60 , 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 85 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( largeNearNorthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 60 ,  - 80 ] ,  [ - 60 ,  - 80 ] ,  [ - 180 ,  - 80 ] ,  [ 60 ,  - 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 85 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " geoPolygonContains ( largeNearNorthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 60 ,  - 80 ] ,  [ - 60 ,  - 80 ] ,  [ - 180 ,  - 80 ] ,  [ 60 ,  - 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 85 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( largeCircle , point ) returns the expected value " , function ( test )  {%NWL%var polygon = d3_geo . geoCircle ( ) . radius ( 120 ) ( ) . coordinates;%NWL%test . equal ( polygonContains ( polygon ,  [ - 180 , 0 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " geoPolygonContains ( largeCircle , point ) returns the expected value " , function ( test )  {%NWL%var polygon = d3_geo . geoCircle ( ) . radius ( 120 ) ( ) . coordinates;%NWL%test . equal ( polygonContains ( polygon ,  [ - 180 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 90 , 0 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( largeNarrowStripHole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 170 ,  - 1 ] ,  [ 0 ,  - 1 ] ,  [ 170 ,  - 1 ] ,  [ 170 , 1 ] ,  [ 0 , 1 ] ,  [ - 170 , 1 ] ,  [ - 170 ,  - 1 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " geoPolygonContains ( largeNarrowStripHole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 170 ,  - 1 ] ,  [ 0 ,  - 1 ] ,  [ 170 ,  - 1 ] ,  [ 170 , 1 ] ,  [ 0 , 1 ] ,  [ - 170 , 1 ] ,  [ - 170 ,  - 1 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 20 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( largeNarrowEquatorialHole , point ) returns the expected value " , function ( test )  {%NWL%var circle = d3_geo . geoCircle ( ) . center ( [ 0 ,  - 90 ] ) ,%NWL%ring0 = circle . radius ( 90 - 0 . 01 ) ( ) . coordinates [ 0 ] ,%NWL%ring1 = circle . radius ( 90 + 0 . 01 ) ( ) . coordinates [ 0 ] . reverse ( ) ,%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%2
test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 20 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( largeNarrowEquatorialHole , point ) returns the expected value " , function ( test )  {%NWL%var circle = d3_geo . geoCircle ( ) . center ( [ 0 ,  - 90 ] ) ,%NWL%ring0 = circle . radius ( 90 - 0 . 01 ) ( ) . coordinates [ 0 ] ,%NWL%ring1 = circle . radius ( 90 + 0 . 01 ) ( ) . coordinates [ 0 ] . reverse ( ) ,%NWL%polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 90 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( largeNarrowEquatorialStrip , point ) returns the expected value " , function ( test )  {%NWL%var circle = d3_geo . geoCircle ( ) . center ( [ 0 ,  - 90 ] ) ,%NWL%ring0 = circle . radius ( 90 + 0 . 01 ) ( ) . coordinates [ 0 ] ,%NWL%ring1 = circle . radius ( 90 - 0 . 01 ) ( ) . coordinates [ 0 ] . reverse ( ) ,%NWL%polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 90 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%2
polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 90 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( ringNearOrigin , point ) returns the expected value " , function ( test )  {%NWL%var ring0 = [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ,%NWL%ring1 = [ [ 0 . 4 , 0 . 4 ] ,  [ 0 . 6 , 0 . 4 ] ,  [ 0 . 6 , 0 . 6 ] ,  [ 0 . 4 , 0 . 6 ] ,  [ 0 . 4 , 0 . 4 ] ] ,%NWL%polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 . 5 , 0 . 5 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%3
polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 . 5 , 0 . 5 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 . 1 , 0 . 5 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( ringEquatorial , point ) returns the expected value " , function ( test )  {%NWL%var ring0 = [ [ 0 ,  - 10 ] ,  [ - 120 ,  - 10 ] ,  [ 120 ,  - 10 ] ,  [ 0 ,  - 10 ] ] ,%NWL%ring1 = [ [ 0 , 10 ] ,  [ 120 , 10 ] ,  [ - 120 , 10 ] ,  [ 0 , 10 ] ] ,%NWL%polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 20 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%3
ring1 = [ [ 0 , 10 ] ,  [ 120 , 10 ] ,  [ - 120 , 10 ] ,  [ 0 , 10 ] ] ,%NWL%polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 20 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( ringExcludingBothPoles , point ) returns the expected value " , function ( test )  {%NWL%var ring0 = [ [ 10 , 10 ] ,  [ - 10 , 10 ] ,  [ - 10 ,  - 10 ] ,  [ 10 ,  - 10 ] ,  [ 10 , 10 ] ] . reverse ( ) ,%NWL%ring1 = [ [ 170 , 10 ] ,  [ 170 ,  - 10 ] ,  [ - 170 ,  - 10 ] ,  [ - 170 , 10 ] ,  [ 170 , 10 ] ] . reverse ( ) ,%NWL%polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%3
polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 20 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( ringExcludingBothPoles , point ) returns the expected value " , function ( test )  {%NWL%var ring0 = [ [ 10 , 10 ] ,  [ - 10 , 10 ] ,  [ - 10 ,  - 10 ] ,  [ 10 ,  - 10 ] ,  [ 10 , 10 ] ] . reverse ( ) ,%NWL%ring1 = [ [ 170 , 10 ] ,  [ 170 ,  - 10 ] ,  [ - 170 ,  - 10 ] ,  [ - 170 , 10 ] ,  [ 170 , 10 ] ] . reverse ( ) ,%NWL%polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 90 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%3
polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 90 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( ringContainingBothPoles , point ) returns the expected value " , function ( test )  {%NWL%var ring0 = [ [ 10 , 10 ] ,  [ - 10 , 10 ] ,  [ - 10 ,  - 10 ] ,  [ 10 ,  - 10 ] ,  [ 10 , 10 ] ] ,%NWL%ring1 = [ [ 170 , 10 ] ,  [ 170 ,  - 10 ] ,  [ - 170 ,  - 10 ] ,  [ - 170 , 10 ] ,  [ 170 , 10 ] ] ,%NWL%polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%3
polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 20 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( ringContainingSouthPole , point ) returns the expected value " , function ( test )  {%NWL%var ring0 = [ [ 10 , 10 ] ,  [ - 10 , 10 ] ,  [ - 10 ,  - 10 ] ,  [ 10 ,  - 10 ] ,  [ 10 , 10 ] ] ,%NWL%ring1 = [ [ 0 , 80 ] ,  [ 120 , 80 ] ,  [ - 120 , 80 ] ,  [ 0 , 80 ] ] ,%NWL%polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 90 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%3
polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 90 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 90 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( ringContainingNorthPole , point ) returns the expected value " , function ( test )  {%NWL%var ring0 = [ [ 10 , 10 ] ,  [ - 10 , 10 ] ,  [ - 10 ,  - 10 ] ,  [ 10 ,  - 10 ] ,  [ 10 , 10 ] ] . reverse ( ) ,%NWL%ring1 = [ [ 0 , 80 ] ,  [ 120 , 80 ] ,  [ - 120 , 80 ] ,  [ 0 , 80 ] ] . reverse ( ) ,%NWL%polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 90 ] ) , 0 ) ;%NWL%test . end ( ) ;%NWL%3
polygon = [ ring0 , ring1 ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 90 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 90 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( selfIntersectingNearOrigin , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 3 ] ,  [ 3 , 3 ] ,  [ 3 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 15 , 0 . 5 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 12 , 2 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 . 5 , 0 . 5 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%3
test . equal ( polygonContains ( polygon ,  [ 15 , 0 . 5 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 12 , 2 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 . 5 , 0 . 5 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 2 , 2 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( selfIntersectingNearSouthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 10 ,  - 80 ] ,  [ 120 ,  - 80 ] ,  [ - 120 ,  - 80 ] ,  [ 10 ,  - 85 ] ,  [ 10 ,  - 75 ] ,  [ - 10 ,  - 75 ] ,  [ - 10 ,  - 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 76 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%4
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( selfIntersectingNearSouthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 10 ,  - 80 ] ,  [ 120 ,  - 80 ] ,  [ - 120 ,  - 80 ] ,  [ 10 ,  - 85 ] ,  [ 10 ,  - 75 ] ,  [ - 10 ,  - 75 ] ,  [ - 10 ,  - 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 76 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 89 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( selfIntersectingNearNorthPole , point ) returns the expected value " , function ( test )  {%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%4
var polygon = [ [ [ - 10 ,  - 80 ] ,  [ 120 ,  - 80 ] ,  [ - 120 ,  - 80 ] ,  [ 10 ,  - 85 ] ,  [ 10 ,  - 75 ] ,  [ - 10 ,  - 75 ] ,  [ - 10 ,  - 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 76 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 89 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( selfIntersectingNearNorthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 10 , 80 ] ,  [ - 10 , 75 ] ,  [ 10 , 75 ] ,  [ 10 , 85 ] ,  [ - 120 , 80 ] ,  [ 120 , 80 ] ,  [ - 10 , 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 76 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " geoPolygonContains ( selfIntersectingNearNorthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 10 , 80 ] ,  [ - 10 , 75 ] ,  [ 10 , 75 ] ,  [ 10 , 85 ] ,  [ - 120 , 80 ] ,  [ 120 , 80 ] ,  [ - 10 , 80 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 76 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 89 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( hemisphereTouchingTheSouthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = d3_geo . geoCircle ( ) . radius ( 90 ) ( ) . coordinates;%NWL%test . end ( ) ;%NWL%6
tape ( " geoPolygonContains ( hemisphereTouchingTheSouthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = d3_geo . geoCircle ( ) . radius ( 90 ) ( ) . coordinates;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 180 ,  - 90 ] ,  [ - 45 , 0 ] ,  [ 45 , 0 ] ,  [ 180 ,  - 90 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 46 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 1 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 90 ,  - 80 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 180 ,  - 90 ] ,  [ - 45 , 0 ] ,  [ 45 , 0 ] ,  [ 180 ,  - 90 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 46 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 1 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 90 ,  - 80 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 44 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 30 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( polygonContains ( polygon ,  [ - 46 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 1 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 90 ,  - 80 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 44 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 30 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 30 ,  - 80 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole2 , point ) returns the expected value " , function ( test )  {%NWL%test . equal ( polygonContains ( polygon ,  [ - 46 , 0 ] ) , 0 ) ;%NWL%0
test . equal ( polygonContains ( polygon ,  [ 0 , 1 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 90 ,  - 80 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 44 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 30 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 30 ,  - 80 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole2 , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 45 , 0 ] ,  [ 45 , 0 ] ,  [ 180 ,  - 90 ] ,  [ - 45 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 1 ] ) , 0 ) ;%NWL%0
test . equal ( polygonContains ( polygon ,  [ - 90 ,  - 80 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 44 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 30 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 30 ,  - 80 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole2 , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 45 , 0 ] ,  [ 45 , 0 ] ,  [ 180 ,  - 90 ] ,  [ - 45 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 46 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 90 ,  - 80 ] ) , 0 ) ;%NWL%0
test . equal ( polygonContains ( polygon ,  [ - 44 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 30 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 30 ,  - 80 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole2 , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 45 , 0 ] ,  [ 45 , 0 ] ,  [ 180 ,  - 90 ] ,  [ - 45 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 46 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 1 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 44 , 0 ] ) , 1 ) ;%NWL%0
test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 30 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 30 ,  - 80 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole2 , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 45 , 0 ] ,  [ 45 , 0 ] ,  [ 180 ,  - 90 ] ,  [ - 45 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 46 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 1 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 90 ,  - 80 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%0
test . equal ( polygonContains ( polygon ,  [ 0 ,  - 30 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 30 ,  - 80 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole2 , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 45 , 0 ] ,  [ 45 , 0 ] ,  [ 180 ,  - 90 ] ,  [ - 45 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 46 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 1 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 90 ,  - 80 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 44 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 30 ] ) , 1 ) ;%NWL%0
test . equal ( polygonContains ( polygon ,  [ 30 ,  - 80 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole2 , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 45 , 0 ] ,  [ 45 , 0 ] ,  [ 180 ,  - 90 ] ,  [ - 45 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 46 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 1 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 90 ,  - 80 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 44 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 30 ,  - 80 ] ) , 1 ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole2 , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ - 45 , 0 ] ,  [ 45 , 0 ] ,  [ 180 ,  - 90 ] ,  [ - 45 , 0 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 46 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 1 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 90 ,  - 80 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ - 44 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 30 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 ,  - 30 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 30 ,  - 80 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole3 , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 180 ,  - 90 ] ,  [ - 135 , 0 ] ,  [ 135 , 0 ] ,  [ 180 ,  - 90 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 180 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 150 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 180 ,  - 30 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPolygonContains ( triangleTouchingTheSouthPole3 , point ) returns the expected value " , function ( test )  {%NWL%var polygon = [ [ [ 180 ,  - 90 ] ,  [ - 135 , 0 ] ,  [ 135 , 0 ] ,  [ 180 ,  - 90 ] ] ] ;%NWL%test . equal ( polygonContains ( polygon ,  [ 180 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 150 , 0 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 180 ,  - 30 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 150 ,  - 80 ] ) , 0 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 0 , 0 ] ) , 1 ) ;%NWL%test . equal ( polygonContains ( polygon ,  [ 180 , 1 ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%0
%NWL%require ( " . / inDelta " ) ;%NWL%tape ( " a rotation of [ + 90° , 0° ] only rotates longitude " , function ( test )  {%NWL%var rotation = d3 . geoRotation ( [ 90 , 0 ] ) ( [ 0 , 0 ] ) ;%NWL%test . inDelta ( rotation [ 0 ] , 90 , 1e - 6 ) ;%NWL%test . inDelta ( rotation [ 1 ] , 0 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a rotation of [ + 90° , 0° ] wraps around when crossing the antimeridian " , function ( test )  {%NWL%var rotation = d3 . geoRotation ( [ 90 , 0 ] ) ( [ 150 , 0 ] ) ;%NWL%test . inDelta ( rotation [ 1 ] , 0 , 1e - 6 ) ;%NWL%5
require ( " . / inDelta " ) ;%NWL%tape ( " a rotation of [ + 90° , 0° ] only rotates longitude " , function ( test )  {%NWL%var rotation = d3 . geoRotation ( [ 90 , 0 ] ) ( [ 0 , 0 ] ) ;%NWL%test . inDelta ( rotation [ 0 ] , 90 , 1e - 6 ) ;%NWL%test . inDelta ( rotation [ 1 ] , 0 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a rotation of [ + 90° , 0° ] wraps around when crossing the antimeridian " , function ( test )  {%NWL%var rotation = d3 . geoRotation ( [ 90 , 0 ] ) ( [ 150 , 0 ] ) ;%NWL%test . inDelta ( rotation [ 0 ] ,  - 120 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " a rotation of [ + 90° , 0° ] wraps around when crossing the antimeridian " , function ( test )  {%NWL%var rotation = d3 . geoRotation ( [ 90 , 0 ] ) ( [ 150 , 0 ] ) ;%NWL%test . inDelta ( rotation [ 0 ] ,  - 120 , 1e - 6 ) ;%NWL%test . inDelta ( rotation [ 1 ] , 0 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a rotation of [ - 45° ,  - 45° ] rotates longitude and latitude " , function ( test )  {%NWL%var rotation = d3 . geoRotation ( [ - 45 , 45 ] ) ( [ 0 , 0 ] ) ;%NWL%test . inDelta ( rotation [ 0 ] ,  - 54 . 73561 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " a rotation of [ - 45° ,  - 45° ] rotates longitude and latitude " , function ( test )  {%NWL%var rotation = d3 . geoRotation ( [ - 45 , 45 ] ) ( [ 0 , 0 ] ) ;%NWL%test . inDelta ( rotation [ 0 ] ,  - 54 . 73561 , 1e - 6 ) ;%NWL%test . inDelta ( rotation [ 1 ] , 30 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " a rotation of [ - 45° ,  - 45° ] inverse rotation of longitude and latitude " , function ( test )  {%NWL%var rotation = d3 . geoRotation ( [ - 45 , 45 ] ) . invert ( [ - 54 . 73561 , 30 ] ) ;%NWL%test . inDelta ( rotation [ 0 ] , 0 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%5
coordinates: [ - 63 , 18 ]%NWL%} ) ,  " M165 , 160m0 , 4 . 500000a4 . 500000 , 4 . 500000 0 1 , 1 0 , - 9a4 . 500000 , 4 . 500000 0 1 , 1 0 , 9z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPath . pointRadius ( radius ) ( Point ) renders a point of the given radius " , function ( test )  {%NWL%test . pathEqual ( d3_geo . geoPath ( )%NWL%. projection ( equirectangular )%NWL%. pointRadius ( 10 ) ( {%NWL%type: " Point " ,%NWL%coordinates: [ - 63 , 18 ]%NWL%test . end ( ) ;%NWL%2
. pointRadius ( 10 ) ( {%NWL%type: " Point " ,%NWL%coordinates: [ - 63 , 18 ]%NWL%} ) ,  " M165 , 160m0 , 10a10 , 10 0 1 , 1 0 , - 20a10 , 10 0 1 , 1 0 , 20z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPath ( MultiPoint ) renders a point " , function ( test )  {%NWL%test . pathEqual ( testPath ( equirectangular ,  {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 63 , 18 ] ,  [ - 62 , 18 ] ,  [ - 62 , 17 ] ]%NWL%test . end ( ) ;%NWL%4
test . pathEqual ( testPath ( equirectangular ,  {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ - 63 , 18 ] ,  [ - 62 , 18 ] ,  [ - 62 , 17 ] ]%NWL%} ) ,  " M165 , 160m0 , 4 . 500000a4 . 500000 , 4 . 500000 0 1 , 1 0 , - 9a4 . 500000 , 4 . 500000 0 1 , 1 0 , 9zM170 , 160m0 , 4 . 500000a4 . 500000 , 4 . 500000 0 1 , 1 0 , - 9a4 . 500000 , 4 . 500000 0 1 , 1 0 , 9zM170 , 165m0 , 4 . 500000a4 . 500000 , 4 . 500000 0 1 , 1 0 , - 9a4 . 500000 , 4 . 500000 0 1 , 1 0 , 9z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPath ( LineString ) renders a line string " , function ( test )  {%NWL%test . pathEqual ( testPath ( equirectangular ,  {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 63 , 18 ] ,  [ - 62 , 18 ] ,  [ - 62 , 17 ] ]%NWL%test . end ( ) ;%NWL%4
test . pathEqual ( testPath ( equirectangular ,  {%NWL%type: " LineString " ,%NWL%coordinates: [ [ - 63 , 18 ] ,  [ - 62 , 18 ] ,  [ - 62 , 17 ] ]%NWL%} ) ,  " M165 , 160L170 , 160L170 , 165 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPath ( Polygon ) renders a polygon " , function ( test )  {%NWL%test . pathEqual ( testPath ( equirectangular ,  {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ - 63 , 18 ] ,  [ - 62 , 18 ] ,  [ - 62 , 17 ] ,  [ - 63 , 18 ] ] ]%NWL%test . end ( ) ;%NWL%4
} ) ,  " M165 , 160L170 , 160L170 , 165Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPath ( GeometryCollection ) renders a geometry collection " , function ( test )  {%NWL%test . pathEqual ( testPath ( equirectangular ,  {%NWL%type: " GeometryCollection " ,%NWL%geometries: [ {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ - 63 , 18 ] ,  [ - 62 , 18 ] ,  [ - 62 , 17 ] ,  [ - 63 , 18 ] ] ]%NWL%} ]%NWL%test . end ( ) ;%NWL%1
} ) ,  " M165 , 160L170 , 160L170 , 165Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoPath ( Feature ) renders a feature " , function ( test )  {%NWL%test . pathEqual ( testPath ( equirectangular ,  {%NWL%type: " Feature " ,%NWL%geometry: {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ - 63 , 18 ] ,  [ - 62 , 18 ] ,  [ - 62 , 17 ] ,  [ - 63 , 18 ] ] ]%NWL%}%NWL%test . end ( ) ;%NWL%1
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / . . / " ) ;%NWL%require ( " . / projectionEqual " ) ;%NWL%[%NWL%d3 . geoAlbers ,%NWL%d3 . geoAzimuthalEquidistant ,%NWL%4
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / . . / " ) ;%NWL%require ( " . / projectionEqual " ) ;%NWL%[%NWL%d3 . geoAlbers ,%NWL%d3 . geoAzimuthalEqualArea ,%NWL%d3 . geoConicConformal ,%NWL%4
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / . . / " ) ;%NWL%require ( " . / projectionEqual " ) ;%NWL%[%NWL%d3 . geoAlbers ,%NWL%d3 . geoAzimuthalEqualArea ,%NWL%d3 . geoAzimuthalEquidistant ,%NWL%d3 . geoConicConformal ,%NWL%function conicConformal ( )  { return d3 . geoConicConformal ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicConformal ( )  { return d3 . geoConicConformal ( ) . parallels ( [ 30 , 30 ] ) ; } ,%NWL%d3 . geoConicEqualArea ,%NWL%4
d3 . geoAlbers ,%NWL%d3 . geoAzimuthalEqualArea ,%NWL%d3 . geoAzimuthalEquidistant ,%NWL%d3 . geoConicConformal ,%NWL%function conicConformal ( )  { return d3 . geoConicConformal ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicConformal ( )  { return d3 . geoConicConformal ( ) . parallels ( [ 30 , 30 ] ) ; } ,%NWL%function conicConformal ( )  { return d3 . geoConicConformal ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoConicEqualArea ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ - 30 , 30 ] ) ; } ,%NWL%d3 . geoConicEquidistant ,%NWL%0
function conicConformal ( )  { return d3 . geoConicConformal ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicConformal ( )  { return d3 . geoConicConformal ( ) . parallels ( [ 30 , 30 ] ) ; } ,%NWL%function conicConformal ( )  { return d3 . geoConicConformal ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoConicEqualArea ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ - 30 , 30 ] ) ; } ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoConicEquidistant ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ 30 , 30 ] ) ; } ,%NWL%d3 . geoEquirectangular ,%NWL%3
function conicConformal ( )  { return d3 . geoConicConformal ( ) . parallels ( [ 30 , 30 ] ) ; } ,%NWL%function conicConformal ( )  { return d3 . geoConicConformal ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoConicEqualArea ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ - 30 , 30 ] ) ; } ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoConicEquidistant ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ 30 , 30 ] ) ; } ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoGnomonic ,%NWL%2
function conicConformal ( )  { return d3 . geoConicConformal ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoConicEqualArea ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ - 30 , 30 ] ) ; } ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoConicEquidistant ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ 30 , 30 ] ) ; } ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoEquirectangular ,%NWL%d3 . geoMercator ,%NWL%1
d3 . geoConicEqualArea ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ - 30 , 30 ] ) ; } ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoConicEquidistant ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ 30 , 30 ] ) ; } ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoEquirectangular ,%NWL%d3 . geoGnomonic ,%NWL%d3 . geoOrthographic ,%NWL%0
function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ - 30 , 30 ] ) ; } ,%NWL%function conicEqualArea ( )  { return d3 . geoConicEqualArea ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoConicEquidistant ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ 20 , 30 ] ) ; } ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ 30 , 30 ] ) ; } ,%NWL%function conicEquidistant ( )  { return d3 . geoConicEquidistant ( ) . parallels ( [ - 35 ,  - 50 ] ) ; } ,%NWL%d3 . geoEquirectangular ,%NWL%d3 . geoGnomonic ,%NWL%d3 . geoMercator ,%NWL%d3 . geoStereographic ,%NWL%3
var name = factory . name , projection = factory ( ) ;%NWL%tape ( name +  " ( point ) and "  + name +  " . invert ( point ) are symmetric " , function ( test )  {%NWL%[ [ 0 , 0 ] ,  [ 30 . 3 , 24 . 1 ] ,  [ - 10 , 42 ] ,  [ - 2 ,  - 5 ] ] . forEach ( function ( point )  {%NWL%test . projectionEqual ( projection , point , projection ( point ) ) ;%NWL%} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " albersUsa ( point ) and albersUsa . invert ( point ) are symmetric " , function ( test )  {%NWL%var projection = d3 . geoAlbersUsa ( ) ;%NWL%test . projectionEqual ( projection , point , projection ( point ) ) ;%NWL%3
[ [ 0 , 0 ] ,  [ 30 . 3 , 24 . 1 ] ,  [ - 10 , 42 ] ,  [ - 2 ,  - 5 ] ] . forEach ( function ( point )  {%NWL%test . projectionEqual ( projection , point , projection ( point ) ) ;%NWL%} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " albersUsa ( point ) and albersUsa . invert ( point ) are symmetric " , function ( test )  {%NWL%var projection = d3 . geoAlbersUsa ( ) ;%NWL%[ [ - 122 . 4194 , 37 . 7749 ] ,  [ - 74 . 0059 , 40 . 7128 ] ,  [ - 149 . 9003 , 61 . 2181 ] ,  [ - 157 . 8583 , 21 . 3069 ] ] . forEach ( function ( point )  {%NWL%test . projectionEqual ( projection , point , projection ( point ) ) ;%NWL%test . end ( ) ;%NWL%3
var input_pos_match = _ . range ( 1 , 6 ) ;%NWL%var input_neg_match = _ . range ( - 1 ,  - 6 ,  - 1 ) ;%NWL%var input_no_match_noise = [ 0 , 1 , 0 , 1 , 0 , 1 ] ;%NWL%var input_no_match_flat = [ 0 , 0 , 0 , 0 , 0 , 0 ] ;%NWL%tape ( ' rule_3 marks increasing trends ' , function ( test )  {%NWL%var result = rule_3 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_3 marks decreasing trends ' , function ( test )  {%NWL%test . ok ( result ) ;%NWL%6
var input_neg_match = _ . range ( - 1 ,  - 6 ,  - 1 ) ;%NWL%var input_no_match_noise = [ 0 , 1 , 0 , 1 , 0 , 1 ] ;%NWL%var input_no_match_flat = [ 0 , 0 , 0 , 0 , 0 , 0 ] ;%NWL%tape ( ' rule_3 marks increasing trends ' , function ( test )  {%NWL%var result = rule_3 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_3 marks decreasing trends ' , function ( test )  {%NWL%var result = rule_3 ( input_neg_match , mean , std ) ;%NWL%test . end ( ) ;%NWL%6
} ) ;%NWL%tape ( ' rule_3 marks decreasing trends ' , function ( test )  {%NWL%var result = rule_3 ( input_neg_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_3 does not mark no trend ' , function ( test )  {%NWL%var resultNoise = rule_3 ( input_no_match_noise , mean , std ) ;%NWL%test . notOk ( resultNoise ,  ' noisy trend ' ) ;%NWL%var resultFlat = rule_3 ( input_no_match_flat , mean , std ) ;%NWL%test . end ( ) ;%NWL%4
import { geoProjection as projection } from " d3 - geo " ;%NWL%import { atan , cos , sqrtPi , tan } from " . / math " ;%NWL%export function foucautRaw ( lambda , phi )  {%NWL%var k = phi / 2 , cosk = cos ( k ) ;%NWL%return [ 2 * lambda / sqrtPi * cos ( phi )  * cosk * cosk , sqrtPi * tan ( k ) ] ;%NWL%}%NWL%var k = atan ( y / sqrtPi ) , cosk = cos ( k ) , phi = 2 * k;%NWL%3
return p;%NWL%} ;%NWL%p . stream = function ( stream )  {%NWL%stream = stream_ ( stream ) ;%NWL%stream . sphere = function ( )  {%NWL%stream . polygonStart ( ) ;%NWL%var epsilon = 1e - 2 ,%NWL%ring = circle . radius ( 90 - epsilon ) ( ) . coordinates [ 0 ] ,%NWL%n = ring . length - 1 ,%NWL%i = - 1 ,%NWL%stream . lineStart ( ) ;%NWL%5
p . stream = function ( stream )  {%NWL%stream = stream_ ( stream ) ;%NWL%stream . sphere = function ( )  {%NWL%stream . polygonStart ( ) ;%NWL%var epsilon = 1e - 2 ,%NWL%ring = circle . radius ( 90 - epsilon ) ( ) . coordinates [ 0 ] ,%NWL%n = ring . length - 1 ,%NWL%i = - 1 ,%NWL%p;%NWL%stream . lineStart ( ) ;%NWL%stream . lineEnd ( ) ;%NWL%3
stream . polygonStart ( ) ;%NWL%var epsilon = 1e - 2 ,%NWL%ring = circle . radius ( 90 - epsilon ) ( ) . coordinates [ 0 ] ,%NWL%n = ring . length - 1 ,%NWL%i = - 1 ,%NWL%p;%NWL%stream . lineStart ( ) ;%NWL%while ( + + i < n ) stream . point ( ( p = ring [ i ] ) [ 0 ] , p [ 1 ] ) ;%NWL%stream . lineEnd ( ) ;%NWL%ring = circle . radius ( 90 + epsilon ) ( ) . coordinates [ 0 ] ;%NWL%stream . lineStart ( ) ;%NWL%0
ring = circle . radius ( 90 - epsilon ) ( ) . coordinates [ 0 ] ,%NWL%n = ring . length - 1 ,%NWL%i = - 1 ,%NWL%p;%NWL%stream . lineStart ( ) ;%NWL%while ( + + i < n ) stream . point ( ( p = ring [ i ] ) [ 0 ] , p [ 1 ] ) ;%NWL%stream . lineEnd ( ) ;%NWL%ring = circle . radius ( 90 + epsilon ) ( ) . coordinates [ 0 ] ;%NWL%n = ring . length - 1;%NWL%stream . lineStart ( ) ;%NWL%stream . lineEnd ( ) ;%NWL%4
n = ring . length - 1 ,%NWL%i = - 1 ,%NWL%p;%NWL%stream . lineStart ( ) ;%NWL%while ( + + i < n ) stream . point ( ( p = ring [ i ] ) [ 0 ] , p [ 1 ] ) ;%NWL%stream . lineEnd ( ) ;%NWL%ring = circle . radius ( 90 + epsilon ) ( ) . coordinates [ 0 ] ;%NWL%n = ring . length - 1;%NWL%stream . lineStart ( ) ;%NWL%while ( - - i >= 0 ) stream . point ( ( p = ring [ i ] ) [ 0 ] , p [ 1 ] ) ;%NWL%stream . polygonEnd ( ) ;%NWL%3
import { abs , epsilon } from " . / math " ;%NWL%export function naturalEarthRaw ( lambda , phi )  {%NWL%var phi2 = phi * phi , phi4 = phi2 * phi2;%NWL%return [%NWL%lambda *  ( 0 . 8707 - 0 . 131979 * phi2 + phi4 *  ( - 0 . 013791 + phi4 *  ( 0 . 003971 * phi2 - 0 . 001529 * phi4 ) ) ) ,%NWL%phi *  ( 1 . 007226 + phi2 *  ( 0 . 015085 + phi4 *  ( - 0 . 044475 + 0 . 028874 * phi2 - 0 . 005916 * phi4 ) ) )%NWL%] ;%NWL%}%NWL%naturalEarthRaw . invert = function ( x , y )  {%NWL%var phi = y , i = 25 , delta;%NWL%var phi2 = phi * phi , phi4 = phi2 * phi2;%NWL%2
buffer . push ( origin [ 0 ] , origin [ 1 ] )%NWL%origin = pos = [ x , y ]%NWL%contours . push ( buffer = [ ] )%NWL%buffer . push ( pos [ 0 ] , pos [ 1 ] )%NWL%break%NWL%case ' l ' :%NWL%buffer . push ( x , y )%NWL%pos = [ x , y ]%NWL%break%NWL%case ' z ' :%NWL%buffer . push ( pos [ 0 ] , pos [ 1 ] )%NWL%3
}%NWL%Heap . prototype . add = function ( keyNew )  {%NWL%var now = + + this . size_ , f%NWL%if ( ( now * 2 ) > this . max_ )  {%NWL%this . max_ * = 2%NWL%this . ns_ = PQN . renew ( this . ns_ , this . max_ + 1 )%NWL%this . handles_ = PQHandleElem . renew ( this . handles_ , this . max_ + 1 )%NWL%}%NWL%if ( this . fList_ === 0 ) f = now%NWL%else {%NWL%this . fList_ = this . handles_ [ f ] . n%NWL%5
var now = + + this . size_ , f%NWL%if ( ( now * 2 ) > this . max_ )  {%NWL%this . max_ * = 2%NWL%this . ns_ = PQN . renew ( this . ns_ , this . max_ + 1 )%NWL%this . handles_ = PQHandleElem . renew ( this . handles_ , this . max_ + 1 )%NWL%}%NWL%if ( this . fList_ === 0 ) f = now%NWL%else {%NWL%f = this . fList_%NWL%this . fList_ = this . handles_ [ f ] . n%NWL%this . ns_ [ now ] . handle = f%NWL%3
if ( ( now * 2 ) > this . max_ )  {%NWL%this . max_ * = 2%NWL%this . ns_ = PQN . renew ( this . ns_ , this . max_ + 1 )%NWL%this . handles_ = PQHandleElem . renew ( this . handles_ , this . max_ + 1 )%NWL%}%NWL%if ( this . fList_ === 0 ) f = now%NWL%else {%NWL%f = this . fList_%NWL%this . fList_ = this . handles_ [ f ] . n%NWL%}%NWL%this . handles_ [ f ] . n = now%NWL%2
this . max_ * = 2%NWL%this . ns_ = PQN . renew ( this . ns_ , this . max_ + 1 )%NWL%this . handles_ = PQHandleElem . renew ( this . handles_ , this . max_ + 1 )%NWL%}%NWL%if ( this . fList_ === 0 ) f = now%NWL%else {%NWL%f = this . fList_%NWL%this . fList_ = this . handles_ [ f ] . n%NWL%}%NWL%this . ns_ [ now ] . handle = f%NWL%this . handles_ [ f ] . key = keyNew%NWL%1
coordinates . push ( interpolateLine ( [%NWL%[ lambda0 + epsilon , phi0 + epsilon ] ,%NWL%[ lambda0 + epsilon , phi1 - epsilon ] ,%NWL%[ lambda2 - epsilon , phi1 - epsilon ] ,%NWL%[ lambda2 - epsilon , phi2 + epsilon ]%NWL%] , 30 ) ) ;%NWL%}%NWL%for ( i = lobes [ 1 ] . length - 1; i >= 0; - - i )  {%NWL%lobe = lobes [ 1 ] [ i ] ;%NWL%lambda0 = lobe [ 0 ] [ 0 ] , phi0 = lobe [ 0 ] [ 1 ] , phi1 = lobe [ 1 ] [ 1 ] ;%NWL%coordinates . push ( interpolateLine ( [%NWL%0
%NWL%} ,%NWL%opacity: function ( v )  {%NWL%var f = this . fBuffer%NWL%this . indices . forEach ( function ( i )  {%NWL%f [ i ] = 256 - v * 256%NWL%} )%NWL%} ,%NWL%render: function ( t )  {%NWL%var x = this . attr . x || 0%NWL%var width = this . attr . width || 0%NWL%9
} ,%NWL%opacity: function ( v )  {%NWL%var f = this . fBuffer%NWL%this . indices . forEach ( function ( i )  {%NWL%f [ i ] = 256 - v * 256%NWL%} )%NWL%} ,%NWL%render: function ( t )  {%NWL%var x = this . attr . x || 0%NWL%var y = this . attr . y || 0%NWL%var height = this . attr . height || 0%NWL%8
test . projectionEqual ( aitoff ,  [  0 ,  45 ] ,  [ 480 . 000000 , 132 . 190275 ] ) ;%NWL%test . projectionEqual ( aitoff ,  [ - 180 ,  0 ] ,  [  8 . 761101 , 250 . 000000 ] ) ;%NWL%test . projectionEqual ( aitoff ,  [ 180 ,  0 ] ,  [ 951 . 238898 , 250 . 000000 ] ) ;%NWL%test . projectionEqual ( aitoff ,  [ - 179 ,  15 ] ,  [ 27 . 261952 , 189 . 342293 ] ) ;%NWL%test . projectionEqual ( aitoff ,  [  1 ,  1 ] ,  [ 482 . 617728 , 247 . 381972 ] ) ;%NWL%test . projectionEqual ( aitoff ,  [  45 ,  87 ] ,  [ 489 . 158099 , 21 . 6821110 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " geoAitoff . invert ( point ) returns undefined for points outside the target region " , function ( test )  {%NWL%var aitoff = d3 . geoAitoff ( ) . scale ( 150 ) ;%NWL%test . end ( ) ;%NWL%6
test . projectionEqual ( craig ,  [  1 ,  1 ] ,  [ 482 . 6179930 ,  247 . 382404 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " craig . parallel ( parallel ) sets the standard parallel " , function ( test )  {%NWL%var craig = d3 . geoCraig ( ) . scale ( 150 ) . parallel ( 30 ) ;%NWL%test . projectionEqual ( craig ,  [  0 ,  0 ] ,  [ 480 . 000000 , 250 . 000000 ] ) ;%NWL%test . projectionEqual ( craig ,  [  0 ,  - 30 ] ,  [ 480 . 000000 , 313 . 397459 ] ) ;%NWL%test . projectionEqual ( craig ,  [  0 ,  30 ] ,  [ 480 . 000000 , 163 . 397459 ] ) ;%NWL%test . projectionEqual ( craig ,  [  0 ,  - 45 ] ,  [ 480 . 000000 , 330 . 700720 ] ) ;%NWL%test . projectionEqual ( craig ,  [  0 ,  45 ] ,  [ 480 . 000000 , 118 . 568686 ] ) ;%NWL%test . end ( ) ;%NWL%1
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%require ( " . / projectionEqual " ) ;%NWL%var points = [ [ 0 , 0 ] ,  [ 30 . 3 , 24 . 1 ] ,  [ - 10 , 42 ] ,  [ - 2 ,  - 5 ] ,  [ 0 , - 55 ] ] ;%NWL%[%NWL%d3 . geoAiry ,%NWL%d3 . geoArmadillo ,%NWL%5
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%require ( " . / projectionEqual " ) ;%NWL%var points = [ [ 0 , 0 ] ,  [ 30 . 3 , 24 . 1 ] ,  [ - 10 , 42 ] ,  [ - 2 ,  - 5 ] ,  [ 0 , - 55 ] ] ;%NWL%[%NWL%d3 . geoAiry ,%NWL%d3 . geoAitoff ,%NWL%d3 . geoAugust ,%NWL%5
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%require ( " . / projectionEqual " ) ;%NWL%var points = [ [ 0 , 0 ] ,  [ 30 . 3 , 24 . 1 ] ,  [ - 10 , 42 ] ,  [ - 2 ,  - 5 ] ,  [ 0 , - 55 ] ] ;%NWL%[%NWL%d3 . geoAiry ,%NWL%d3 . geoAitoff ,%NWL%d3 . geoArmadillo ,%NWL%d3 . geoBaker ,%NWL%5
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%require ( " . / projectionEqual " ) ;%NWL%var points = [ [ 0 , 0 ] ,  [ 30 . 3 , 24 . 1 ] ,  [ - 10 , 42 ] ,  [ - 2 ,  - 5 ] ,  [ 0 , - 55 ] ] ;%NWL%[%NWL%d3 . geoAiry ,%NWL%d3 . geoAitoff ,%NWL%d3 . geoArmadillo ,%NWL%d3 . geoAugust ,%NWL%d3 . geoBerghaus ,%NWL%5
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%require ( " . / projectionEqual " ) ;%NWL%var points = [ [ 0 , 0 ] ,  [ 30 . 3 , 24 . 1 ] ,  [ - 10 , 42 ] ,  [ - 2 ,  - 5 ] ,  [ 0 , - 55 ] ] ;%NWL%[%NWL%d3 . geoAiry ,%NWL%d3 . geoAitoff ,%NWL%d3 . geoArmadillo ,%NWL%d3 . geoAugust ,%NWL%d3 . geoBaker ,%NWL%d3 . geoBoggs ,%NWL%5
d3 = require ( " . . / " ) ;%NWL%require ( " . / projectionEqual " ) ;%NWL%var points = [ [ 0 , 0 ] ,  [ 30 . 3 , 24 . 1 ] ,  [ - 10 , 42 ] ,  [ - 2 ,  - 5 ] ,  [ 0 , - 55 ] ] ;%NWL%[%NWL%d3 . geoAiry ,%NWL%d3 . geoAitoff ,%NWL%d3 . geoArmadillo ,%NWL%d3 . geoAugust ,%NWL%d3 . geoBaker ,%NWL%d3 . geoBerghaus ,%NWL%d3 . geoBonne ,%NWL%4
require ( " . / projectionEqual " ) ;%NWL%var points = [ [ 0 , 0 ] ,  [ 30 . 3 , 24 . 1 ] ,  [ - 10 , 42 ] ,  [ - 2 ,  - 5 ] ,  [ 0 , - 55 ] ] ;%NWL%[%NWL%d3 . geoAiry ,%NWL%d3 . geoAitoff ,%NWL%d3 . geoArmadillo ,%NWL%d3 . geoAugust ,%NWL%d3 . geoBaker ,%NWL%d3 . geoBerghaus ,%NWL%d3 . geoBoggs ,%NWL%d3 . geoBottomley ,%NWL%3
var points = [ [ 0 , 0 ] ,  [ 30 . 3 , 24 . 1 ] ,  [ - 10 , 42 ] ,  [ - 2 ,  - 5 ] ,  [ 0 , - 55 ] ] ;%NWL%[%NWL%d3 . geoAiry ,%NWL%d3 . geoAitoff ,%NWL%d3 . geoArmadillo ,%NWL%d3 . geoAugust ,%NWL%d3 . geoBaker ,%NWL%d3 . geoBerghaus ,%NWL%d3 . geoBoggs ,%NWL%d3 . geoBonne ,%NWL%d3 . geoBromley ,%NWL%2
[%NWL%d3 . geoAiry ,%NWL%d3 . geoAitoff ,%NWL%d3 . geoArmadillo ,%NWL%d3 . geoAugust ,%NWL%d3 . geoBaker ,%NWL%d3 . geoBerghaus ,%NWL%d3 . geoBoggs ,%NWL%d3 . geoBonne ,%NWL%d3 . geoBottomley ,%NWL%d3 . geoCollignon ,%NWL%1
d3 . geoAiry ,%NWL%d3 . geoAitoff ,%NWL%d3 . geoArmadillo ,%NWL%d3 . geoAugust ,%NWL%d3 . geoBaker ,%NWL%d3 . geoBerghaus ,%NWL%d3 . geoBoggs ,%NWL%d3 . geoBonne ,%NWL%d3 . geoBottomley ,%NWL%d3 . geoBromley ,%NWL%d3 . geoCraig ,%NWL%0
d3 . geoAitoff ,%NWL%d3 . geoArmadillo ,%NWL%d3 . geoAugust ,%NWL%d3 . geoBaker ,%NWL%d3 . geoBerghaus ,%NWL%d3 . geoBoggs ,%NWL%d3 . geoBonne ,%NWL%d3 . geoBottomley ,%NWL%d3 . geoBromley ,%NWL%d3 . geoCollignon ,%NWL%d3 . geoCraster ,%NWL%0
d3 . geoArmadillo ,%NWL%d3 . geoAugust ,%NWL%d3 . geoBaker ,%NWL%d3 . geoBerghaus ,%NWL%d3 . geoBoggs ,%NWL%d3 . geoBonne ,%NWL%d3 . geoBottomley ,%NWL%d3 . geoBromley ,%NWL%d3 . geoCollignon ,%NWL%d3 . geoCraig ,%NWL%d3 . geoCylindricalEqualArea ,%NWL%0
d3 . geoAugust ,%NWL%d3 . geoBaker ,%NWL%d3 . geoBerghaus ,%NWL%d3 . geoBoggs ,%NWL%d3 . geoBonne ,%NWL%d3 . geoBottomley ,%NWL%d3 . geoBromley ,%NWL%d3 . geoCollignon ,%NWL%d3 . geoCraig ,%NWL%d3 . geoCraster ,%NWL%d3 . geoCylindricalStereographic ,%NWL%0
d3 . geoBaker ,%NWL%d3 . geoBerghaus ,%NWL%d3 . geoBoggs ,%NWL%d3 . geoBonne ,%NWL%d3 . geoBottomley ,%NWL%d3 . geoBromley ,%NWL%d3 . geoCollignon ,%NWL%d3 . geoCraig ,%NWL%d3 . geoCraster ,%NWL%d3 . geoCylindricalEqualArea ,%NWL%d3 . geoEckert1 ,%NWL%0
d3 . geoBerghaus ,%NWL%d3 . geoBoggs ,%NWL%d3 . geoBonne ,%NWL%d3 . geoBottomley ,%NWL%d3 . geoBromley ,%NWL%d3 . geoCollignon ,%NWL%d3 . geoCraig ,%NWL%d3 . geoCraster ,%NWL%d3 . geoCylindricalEqualArea ,%NWL%d3 . geoCylindricalStereographic ,%NWL%d3 . geoEckert2 ,%NWL%0
d3 . geoBoggs ,%NWL%d3 . geoBonne ,%NWL%d3 . geoBottomley ,%NWL%d3 . geoBromley ,%NWL%d3 . geoCollignon ,%NWL%d3 . geoCraig ,%NWL%d3 . geoCraster ,%NWL%d3 . geoCylindricalEqualArea ,%NWL%d3 . geoCylindricalStereographic ,%NWL%d3 . geoEckert1 ,%NWL%d3 . geoEckert3 ,%NWL%0
d3 . geoBonne ,%NWL%d3 . geoBottomley ,%NWL%d3 . geoBromley ,%NWL%d3 . geoCollignon ,%NWL%d3 . geoCraig ,%NWL%d3 . geoCraster ,%NWL%d3 . geoCylindricalEqualArea ,%NWL%d3 . geoCylindricalStereographic ,%NWL%d3 . geoEckert1 ,%NWL%d3 . geoEckert2 ,%NWL%d3 . geoEckert4 ,%NWL%0
d3 . geoBottomley ,%NWL%d3 . geoBromley ,%NWL%d3 . geoCollignon ,%NWL%d3 . geoCraig ,%NWL%d3 . geoCraster ,%NWL%d3 . geoCylindricalEqualArea ,%NWL%d3 . geoCylindricalStereographic ,%NWL%d3 . geoEckert1 ,%NWL%d3 . geoEckert2 ,%NWL%d3 . geoEckert3 ,%NWL%d3 . geoEckert5 ,%NWL%0
d3 . geoBromley ,%NWL%d3 . geoCollignon ,%NWL%d3 . geoCraig ,%NWL%d3 . geoCraster ,%NWL%d3 . geoCylindricalEqualArea ,%NWL%d3 . geoCylindricalStereographic ,%NWL%d3 . geoEckert1 ,%NWL%d3 . geoEckert2 ,%NWL%d3 . geoEckert3 ,%NWL%d3 . geoEckert4 ,%NWL%d3 . geoEckert6 ,%NWL%0
d3 . geoCollignon ,%NWL%d3 . geoCraig ,%NWL%d3 . geoCraster ,%NWL%d3 . geoCylindricalEqualArea ,%NWL%d3 . geoCylindricalStereographic ,%NWL%d3 . geoEckert1 ,%NWL%d3 . geoEckert2 ,%NWL%d3 . geoEckert3 ,%NWL%d3 . geoEckert4 ,%NWL%d3 . geoEckert5 ,%NWL%d3 . geoEisenlohr ,%NWL%0
d3 . geoCraig ,%NWL%d3 . geoCraster ,%NWL%d3 . geoCylindricalEqualArea ,%NWL%d3 . geoCylindricalStereographic ,%NWL%d3 . geoEckert1 ,%NWL%d3 . geoEckert2 ,%NWL%d3 . geoEckert3 ,%NWL%d3 . geoEckert4 ,%NWL%d3 . geoEckert5 ,%NWL%d3 . geoEckert6 ,%NWL%d3 . geoFahey ,%NWL%0
d3 . geoCraster ,%NWL%d3 . geoCylindricalEqualArea ,%NWL%d3 . geoCylindricalStereographic ,%NWL%d3 . geoEckert1 ,%NWL%d3 . geoEckert2 ,%NWL%d3 . geoEckert3 ,%NWL%d3 . geoEckert4 ,%NWL%d3 . geoEckert5 ,%NWL%d3 . geoEckert6 ,%NWL%d3 . geoEisenlohr ,%NWL%d3 . geoFoucaut ,%NWL%0
d3 . geoCylindricalEqualArea ,%NWL%d3 . geoCylindricalStereographic ,%NWL%d3 . geoEckert1 ,%NWL%d3 . geoEckert2 ,%NWL%d3 . geoEckert3 ,%NWL%d3 . geoEckert4 ,%NWL%d3 . geoEckert5 ,%NWL%d3 . geoEckert6 ,%NWL%d3 . geoEisenlohr ,%NWL%d3 . geoFahey ,%NWL%d3 . geoGilbert ,%NWL%0
d3 . geoCylindricalStereographic ,%NWL%d3 . geoEckert1 ,%NWL%d3 . geoEckert2 ,%NWL%d3 . geoEckert3 ,%NWL%d3 . geoEckert4 ,%NWL%d3 . geoEckert5 ,%NWL%d3 . geoEckert6 ,%NWL%d3 . geoEisenlohr ,%NWL%d3 . geoFahey ,%NWL%d3 . geoFoucaut ,%NWL%d3 . geoGingery ,%NWL%0
d3 . geoEckert1 ,%NWL%d3 . geoEckert2 ,%NWL%d3 . geoEckert3 ,%NWL%d3 . geoEckert4 ,%NWL%d3 . geoEckert5 ,%NWL%d3 . geoEckert6 ,%NWL%d3 . geoEisenlohr ,%NWL%d3 . geoFahey ,%NWL%d3 . geoFoucaut ,%NWL%d3 . geoGilbert ,%NWL%d3 . geoGinzburg4 ,%NWL%0
d3 . geoEckert2 ,%NWL%d3 . geoEckert3 ,%NWL%d3 . geoEckert4 ,%NWL%d3 . geoEckert5 ,%NWL%d3 . geoEckert6 ,%NWL%d3 . geoEisenlohr ,%NWL%d3 . geoFahey ,%NWL%d3 . geoFoucaut ,%NWL%d3 . geoGilbert ,%NWL%d3 . geoGingery ,%NWL%d3 . geoGinzburg5 ,%NWL%0
d3 . geoEckert3 ,%NWL%d3 . geoEckert4 ,%NWL%d3 . geoEckert5 ,%NWL%d3 . geoEckert6 ,%NWL%d3 . geoEisenlohr ,%NWL%d3 . geoFahey ,%NWL%d3 . geoFoucaut ,%NWL%d3 . geoGilbert ,%NWL%d3 . geoGingery ,%NWL%d3 . geoGinzburg4 ,%NWL%d3 . geoGinzburg6 ,%NWL%0
d3 . geoEckert4 ,%NWL%d3 . geoEckert5 ,%NWL%d3 . geoEckert6 ,%NWL%d3 . geoEisenlohr ,%NWL%d3 . geoFahey ,%NWL%d3 . geoFoucaut ,%NWL%d3 . geoGilbert ,%NWL%d3 . geoGingery ,%NWL%d3 . geoGinzburg4 ,%NWL%d3 . geoGinzburg5 ,%NWL%d3 . geoGinzburg8 ,%NWL%0
d3 . geoEckert5 ,%NWL%d3 . geoEckert6 ,%NWL%d3 . geoEisenlohr ,%NWL%d3 . geoFahey ,%NWL%d3 . geoFoucaut ,%NWL%d3 . geoGilbert ,%NWL%d3 . geoGingery ,%NWL%d3 . geoGinzburg4 ,%NWL%d3 . geoGinzburg5 ,%NWL%d3 . geoGinzburg6 ,%NWL%d3 . geoGinzburg9 ,%NWL%0
d3 . geoEckert6 ,%NWL%d3 . geoEisenlohr ,%NWL%d3 . geoFahey ,%NWL%d3 . geoFoucaut ,%NWL%d3 . geoGilbert ,%NWL%d3 . geoGingery ,%NWL%d3 . geoGinzburg4 ,%NWL%d3 . geoGinzburg5 ,%NWL%d3 . geoGinzburg6 ,%NWL%d3 . geoGinzburg8 ,%NWL%d3 . geoGringorten ,%NWL%0
d3 . geoEisenlohr ,%NWL%d3 . geoFahey ,%NWL%d3 . geoFoucaut ,%NWL%d3 . geoGilbert ,%NWL%d3 . geoGingery ,%NWL%d3 . geoGinzburg4 ,%NWL%d3 . geoGinzburg5 ,%NWL%d3 . geoGinzburg6 ,%NWL%d3 . geoGinzburg8 ,%NWL%d3 . geoGinzburg9 ,%NWL%d3 . geoGringortenQuincuncial ,%NWL%0
d3 . geoFahey ,%NWL%d3 . geoFoucaut ,%NWL%d3 . geoGilbert ,%NWL%d3 . geoGingery ,%NWL%d3 . geoGinzburg4 ,%NWL%d3 . geoGinzburg5 ,%NWL%d3 . geoGinzburg6 ,%NWL%d3 . geoGinzburg8 ,%NWL%d3 . geoGinzburg9 ,%NWL%d3 . geoGringorten ,%NWL%d3 . geoGuyou ,%NWL%0
d3 . geoFoucaut ,%NWL%d3 . geoGilbert ,%NWL%d3 . geoGingery ,%NWL%d3 . geoGinzburg4 ,%NWL%d3 . geoGinzburg5 ,%NWL%d3 . geoGinzburg6 ,%NWL%d3 . geoGinzburg8 ,%NWL%d3 . geoGinzburg9 ,%NWL%d3 . geoGringorten ,%NWL%d3 . geoGringortenQuincuncial ,%NWL%d3 . geoHammer ,%NWL%0
d3 . geoGilbert ,%NWL%d3 . geoGingery ,%NWL%d3 . geoGinzburg4 ,%NWL%d3 . geoGinzburg5 ,%NWL%d3 . geoGinzburg6 ,%NWL%d3 . geoGinzburg8 ,%NWL%d3 . geoGinzburg9 ,%NWL%d3 . geoGringorten ,%NWL%d3 . geoGringortenQuincuncial ,%NWL%d3 . geoGuyou ,%NWL%d3 . geoHammerRetroazimuthal ,%NWL%0
d3 . geoGingery ,%NWL%d3 . geoGinzburg4 ,%NWL%d3 . geoGinzburg5 ,%NWL%d3 . geoGinzburg6 ,%NWL%d3 . geoGinzburg8 ,%NWL%d3 . geoGinzburg9 ,%NWL%d3 . geoGringorten ,%NWL%d3 . geoGringortenQuincuncial ,%NWL%d3 . geoGuyou ,%NWL%d3 . geoHammer ,%NWL%d3 . geoHealpix ,%NWL%0
d3 . geoGinzburg4 ,%NWL%d3 . geoGinzburg5 ,%NWL%d3 . geoGinzburg6 ,%NWL%d3 . geoGinzburg8 ,%NWL%d3 . geoGinzburg9 ,%NWL%d3 . geoGringorten ,%NWL%d3 . geoGringortenQuincuncial ,%NWL%d3 . geoGuyou ,%NWL%d3 . geoHammer ,%NWL%d3 . geoHammerRetroazimuthal ,%NWL%d3 . geoHill ,%NWL%0
d3 . geoGinzburg5 ,%NWL%d3 . geoGinzburg6 ,%NWL%d3 . geoGinzburg8 ,%NWL%d3 . geoGinzburg9 ,%NWL%d3 . geoGringorten ,%NWL%d3 . geoGringortenQuincuncial ,%NWL%d3 . geoGuyou ,%NWL%d3 . geoHammer ,%NWL%d3 . geoHammerRetroazimuthal ,%NWL%d3 . geoHealpix ,%NWL%d3 . geoHomolosine ,%NWL%0
d3 . geoGinzburg6 ,%NWL%d3 . geoGinzburg8 ,%NWL%d3 . geoGinzburg9 ,%NWL%d3 . geoGringorten ,%NWL%d3 . geoGringortenQuincuncial ,%NWL%d3 . geoGuyou ,%NWL%d3 . geoHammer ,%NWL%d3 . geoHammerRetroazimuthal ,%NWL%d3 . geoHealpix ,%NWL%d3 . geoHill ,%NWL%d3 . geoInterruptedBoggs ,%NWL%0
d3 . geoGinzburg8 ,%NWL%d3 . geoGinzburg9 ,%NWL%d3 . geoGringorten ,%NWL%d3 . geoGringortenQuincuncial ,%NWL%d3 . geoGuyou ,%NWL%d3 . geoHammer ,%NWL%d3 . geoHammerRetroazimuthal ,%NWL%d3 . geoHealpix ,%NWL%d3 . geoHill ,%NWL%d3 . geoHomolosine ,%NWL%d3 . geoInterruptedHomolosine ,%NWL%0
d3 . geoGinzburg9 ,%NWL%d3 . geoGringorten ,%NWL%d3 . geoGringortenQuincuncial ,%NWL%d3 . geoGuyou ,%NWL%d3 . geoHammer ,%NWL%d3 . geoHammerRetroazimuthal ,%NWL%d3 . geoHealpix ,%NWL%d3 . geoHill ,%NWL%d3 . geoHomolosine ,%NWL%d3 . geoInterruptedBoggs ,%NWL%d3 . geoInterruptedMollweide ,%NWL%0
d3 . geoGringorten ,%NWL%d3 . geoGringortenQuincuncial ,%NWL%d3 . geoGuyou ,%NWL%d3 . geoHammer ,%NWL%d3 . geoHammerRetroazimuthal ,%NWL%d3 . geoHealpix ,%NWL%d3 . geoHill ,%NWL%d3 . geoHomolosine ,%NWL%d3 . geoInterruptedBoggs ,%NWL%d3 . geoInterruptedHomolosine ,%NWL%d3 . geoInterruptedMollweideHemispheres ,%NWL%0
d3 . geoGringortenQuincuncial ,%NWL%d3 . geoGuyou ,%NWL%d3 . geoHammer ,%NWL%d3 . geoHammerRetroazimuthal ,%NWL%d3 . geoHealpix ,%NWL%d3 . geoHill ,%NWL%d3 . geoHomolosine ,%NWL%d3 . geoInterruptedBoggs ,%NWL%d3 . geoInterruptedHomolosine ,%NWL%d3 . geoInterruptedMollweide ,%NWL%d3 . geoInterruptedSinusoidal ,%NWL%0
d3 . geoGuyou ,%NWL%d3 . geoHammer ,%NWL%d3 . geoHammerRetroazimuthal ,%NWL%d3 . geoHealpix ,%NWL%d3 . geoHill ,%NWL%d3 . geoHomolosine ,%NWL%d3 . geoInterruptedBoggs ,%NWL%d3 . geoInterruptedHomolosine ,%NWL%d3 . geoInterruptedMollweide ,%NWL%d3 . geoInterruptedMollweideHemispheres ,%NWL%d3 . geoKavrayskiy7 ,%NWL%0
d3 . geoHammer ,%NWL%d3 . geoHammerRetroazimuthal ,%NWL%d3 . geoHealpix ,%NWL%d3 . geoHill ,%NWL%d3 . geoHomolosine ,%NWL%d3 . geoInterruptedBoggs ,%NWL%d3 . geoInterruptedHomolosine ,%NWL%d3 . geoInterruptedMollweide ,%NWL%d3 . geoInterruptedMollweideHemispheres ,%NWL%d3 . geoInterruptedSinusoidal ,%NWL%d3 . geoLagrange ,%NWL%0
d3 . geoHammerRetroazimuthal ,%NWL%d3 . geoHealpix ,%NWL%d3 . geoHill ,%NWL%d3 . geoHomolosine ,%NWL%d3 . geoInterruptedBoggs ,%NWL%d3 . geoInterruptedHomolosine ,%NWL%d3 . geoInterruptedMollweide ,%NWL%d3 . geoInterruptedMollweideHemispheres ,%NWL%d3 . geoInterruptedSinusoidal ,%NWL%d3 . geoKavrayskiy7 ,%NWL%d3 . geoLarrivee ,%NWL%0
d3 . geoHealpix ,%NWL%d3 . geoHill ,%NWL%d3 . geoHomolosine ,%NWL%d3 . geoInterruptedBoggs ,%NWL%d3 . geoInterruptedHomolosine ,%NWL%d3 . geoInterruptedMollweide ,%NWL%d3 . geoInterruptedMollweideHemispheres ,%NWL%d3 . geoInterruptedSinusoidal ,%NWL%d3 . geoKavrayskiy7 ,%NWL%d3 . geoLagrange ,%NWL%d3 . geoLaskowski ,%NWL%0
d3 . geoHill ,%NWL%d3 . geoHomolosine ,%NWL%d3 . geoInterruptedBoggs ,%NWL%d3 . geoInterruptedHomolosine ,%NWL%d3 . geoInterruptedMollweide ,%NWL%d3 . geoInterruptedMollweideHemispheres ,%NWL%d3 . geoInterruptedSinusoidal ,%NWL%d3 . geoKavrayskiy7 ,%NWL%d3 . geoLagrange ,%NWL%d3 . geoLarrivee ,%NWL%d3 . geoLittrow ,%NWL%0
d3 . geoHomolosine ,%NWL%d3 . geoInterruptedBoggs ,%NWL%d3 . geoInterruptedHomolosine ,%NWL%d3 . geoInterruptedMollweide ,%NWL%d3 . geoInterruptedMollweideHemispheres ,%NWL%d3 . geoInterruptedSinusoidal ,%NWL%d3 . geoKavrayskiy7 ,%NWL%d3 . geoLagrange ,%NWL%d3 . geoLarrivee ,%NWL%d3 . geoLaskowski ,%NWL%d3 . geoLoximuthal ,%NWL%0
d3 . geoInterruptedBoggs ,%NWL%d3 . geoInterruptedHomolosine ,%NWL%d3 . geoInterruptedMollweide ,%NWL%d3 . geoInterruptedMollweideHemispheres ,%NWL%d3 . geoInterruptedSinusoidal ,%NWL%d3 . geoKavrayskiy7 ,%NWL%d3 . geoLagrange ,%NWL%d3 . geoLarrivee ,%NWL%d3 . geoLaskowski ,%NWL%d3 . geoLittrow ,%NWL%d3 . geoMiller ,%NWL%0
d3 . geoInterruptedHomolosine ,%NWL%d3 . geoInterruptedMollweide ,%NWL%d3 . geoInterruptedMollweideHemispheres ,%NWL%d3 . geoInterruptedSinusoidal ,%NWL%d3 . geoKavrayskiy7 ,%NWL%d3 . geoLagrange ,%NWL%d3 . geoLarrivee ,%NWL%d3 . geoLaskowski ,%NWL%d3 . geoLittrow ,%NWL%d3 . geoLoximuthal ,%NWL%d3 . geoMollweide ,%NWL%0
d3 . geoInterruptedMollweide ,%NWL%d3 . geoInterruptedMollweideHemispheres ,%NWL%d3 . geoInterruptedSinusoidal ,%NWL%d3 . geoKavrayskiy7 ,%NWL%d3 . geoLagrange ,%NWL%d3 . geoLarrivee ,%NWL%d3 . geoLaskowski ,%NWL%d3 . geoLittrow ,%NWL%d3 . geoLoximuthal ,%NWL%d3 . geoMiller ,%NWL%d3 . geoMtFlatPolarParabolic ,%NWL%0
d3 . geoInterruptedMollweideHemispheres ,%NWL%d3 . geoInterruptedSinusoidal ,%NWL%d3 . geoKavrayskiy7 ,%NWL%d3 . geoLagrange ,%NWL%d3 . geoLarrivee ,%NWL%d3 . geoLaskowski ,%NWL%d3 . geoLittrow ,%NWL%d3 . geoLoximuthal ,%NWL%d3 . geoMiller ,%NWL%d3 . geoMollweide ,%NWL%d3 . geoMtFlatPolarQuartic ,%NWL%0
d3 . geoInterruptedSinusoidal ,%NWL%d3 . geoKavrayskiy7 ,%NWL%d3 . geoLagrange ,%NWL%d3 . geoLarrivee ,%NWL%d3 . geoLaskowski ,%NWL%d3 . geoLittrow ,%NWL%d3 . geoLoximuthal ,%NWL%d3 . geoMiller ,%NWL%d3 . geoMollweide ,%NWL%d3 . geoMtFlatPolarParabolic ,%NWL%d3 . geoMtFlatPolarSinusoidal ,%NWL%0
d3 . geoKavrayskiy7 ,%NWL%d3 . geoLagrange ,%NWL%d3 . geoLarrivee ,%NWL%d3 . geoLaskowski ,%NWL%d3 . geoLittrow ,%NWL%d3 . geoLoximuthal ,%NWL%d3 . geoMiller ,%NWL%d3 . geoMollweide ,%NWL%d3 . geoMtFlatPolarParabolic ,%NWL%d3 . geoMtFlatPolarQuartic ,%NWL%d3 . geoNaturalEarth ,%NWL%0
d3 . geoLagrange ,%NWL%d3 . geoLarrivee ,%NWL%d3 . geoLaskowski ,%NWL%d3 . geoLittrow ,%NWL%d3 . geoLoximuthal ,%NWL%d3 . geoMiller ,%NWL%d3 . geoMollweide ,%NWL%d3 . geoMtFlatPolarParabolic ,%NWL%d3 . geoMtFlatPolarQuartic ,%NWL%d3 . geoMtFlatPolarSinusoidal ,%NWL%d3 . geoNaturalEarth2 ,%NWL%0
d3 . geoLarrivee ,%NWL%d3 . geoLaskowski ,%NWL%d3 . geoLittrow ,%NWL%d3 . geoLoximuthal ,%NWL%d3 . geoMiller ,%NWL%d3 . geoMollweide ,%NWL%d3 . geoMtFlatPolarParabolic ,%NWL%d3 . geoMtFlatPolarQuartic ,%NWL%d3 . geoMtFlatPolarSinusoidal ,%NWL%d3 . geoNaturalEarth ,%NWL%d3 . geoNellHammer ,%NWL%0
d3 . geoLaskowski ,%NWL%d3 . geoLittrow ,%NWL%d3 . geoLoximuthal ,%NWL%d3 . geoMiller ,%NWL%d3 . geoMollweide ,%NWL%d3 . geoMtFlatPolarParabolic ,%NWL%d3 . geoMtFlatPolarQuartic ,%NWL%d3 . geoMtFlatPolarSinusoidal ,%NWL%d3 . geoNaturalEarth ,%NWL%d3 . geoNaturalEarth2 ,%NWL%d3 . geoPatterson ,%NWL%0
d3 . geoLittrow ,%NWL%d3 . geoLoximuthal ,%NWL%d3 . geoMiller ,%NWL%d3 . geoMollweide ,%NWL%d3 . geoMtFlatPolarParabolic ,%NWL%d3 . geoMtFlatPolarQuartic ,%NWL%d3 . geoMtFlatPolarSinusoidal ,%NWL%d3 . geoNaturalEarth ,%NWL%d3 . geoNaturalEarth2 ,%NWL%d3 . geoNellHammer ,%NWL%d3 . geoPeirceQuincuncial ,%NWL%0
d3 . geoLoximuthal ,%NWL%d3 . geoMiller ,%NWL%d3 . geoMollweide ,%NWL%d3 . geoMtFlatPolarParabolic ,%NWL%d3 . geoMtFlatPolarQuartic ,%NWL%d3 . geoMtFlatPolarSinusoidal ,%NWL%d3 . geoNaturalEarth ,%NWL%d3 . geoNaturalEarth2 ,%NWL%d3 . geoNellHammer ,%NWL%d3 . geoPatterson ,%NWL%d3 . geoPolyconic ,%NWL%0
d3 . geoMiller ,%NWL%d3 . geoMollweide ,%NWL%d3 . geoMtFlatPolarParabolic ,%NWL%d3 . geoMtFlatPolarQuartic ,%NWL%d3 . geoMtFlatPolarSinusoidal ,%NWL%d3 . geoNaturalEarth ,%NWL%d3 . geoNaturalEarth2 ,%NWL%d3 . geoNellHammer ,%NWL%d3 . geoPatterson ,%NWL%d3 . geoPeirceQuincuncial ,%NWL%d3 . geoRectangularPolyconic ,%NWL%0
d3 . geoMollweide ,%NWL%d3 . geoMtFlatPolarParabolic ,%NWL%d3 . geoMtFlatPolarQuartic ,%NWL%d3 . geoMtFlatPolarSinusoidal ,%NWL%d3 . geoNaturalEarth ,%NWL%d3 . geoNaturalEarth2 ,%NWL%d3 . geoNellHammer ,%NWL%d3 . geoPatterson ,%NWL%d3 . geoPeirceQuincuncial ,%NWL%d3 . geoPolyconic ,%NWL%d3 . geoRobinson ,%NWL%0
d3 . geoMtFlatPolarParabolic ,%NWL%d3 . geoMtFlatPolarQuartic ,%NWL%d3 . geoMtFlatPolarSinusoidal ,%NWL%d3 . geoNaturalEarth ,%NWL%d3 . geoNaturalEarth2 ,%NWL%d3 . geoNellHammer ,%NWL%d3 . geoPatterson ,%NWL%d3 . geoPeirceQuincuncial ,%NWL%d3 . geoPolyconic ,%NWL%d3 . geoRectangularPolyconic ,%NWL%d3 . geoSatellite ,%NWL%0
d3 . geoMtFlatPolarQuartic ,%NWL%d3 . geoMtFlatPolarSinusoidal ,%NWL%d3 . geoNaturalEarth ,%NWL%d3 . geoNaturalEarth2 ,%NWL%d3 . geoNellHammer ,%NWL%d3 . geoPatterson ,%NWL%d3 . geoPeirceQuincuncial ,%NWL%d3 . geoPolyconic ,%NWL%d3 . geoRectangularPolyconic ,%NWL%d3 . geoRobinson ,%NWL%d3 . geoSinuMollweide ,%NWL%0
d3 . geoMtFlatPolarSinusoidal ,%NWL%d3 . geoNaturalEarth ,%NWL%d3 . geoNaturalEarth2 ,%NWL%d3 . geoNellHammer ,%NWL%d3 . geoPatterson ,%NWL%d3 . geoPeirceQuincuncial ,%NWL%d3 . geoPolyconic ,%NWL%d3 . geoRectangularPolyconic ,%NWL%d3 . geoRobinson ,%NWL%d3 . geoSatellite ,%NWL%d3 . geoSinusoidal ,%NWL%0
d3 . geoNaturalEarth ,%NWL%d3 . geoNaturalEarth2 ,%NWL%d3 . geoNellHammer ,%NWL%d3 . geoPatterson ,%NWL%d3 . geoPeirceQuincuncial ,%NWL%d3 . geoPolyconic ,%NWL%d3 . geoRectangularPolyconic ,%NWL%d3 . geoRobinson ,%NWL%d3 . geoSatellite ,%NWL%d3 . geoSinuMollweide ,%NWL%d3 . geoTimes ,%NWL%0
d3 . geoNaturalEarth2 ,%NWL%d3 . geoNellHammer ,%NWL%d3 . geoPatterson ,%NWL%d3 . geoPeirceQuincuncial ,%NWL%d3 . geoPolyconic ,%NWL%d3 . geoRectangularPolyconic ,%NWL%d3 . geoRobinson ,%NWL%d3 . geoSatellite ,%NWL%d3 . geoSinuMollweide ,%NWL%d3 . geoSinusoidal ,%NWL%d3 . geoTwoPointEquidistantUsa ,%NWL%0
d3 . geoNellHammer ,%NWL%d3 . geoPatterson ,%NWL%d3 . geoPeirceQuincuncial ,%NWL%d3 . geoPolyconic ,%NWL%d3 . geoRectangularPolyconic ,%NWL%d3 . geoRobinson ,%NWL%d3 . geoSatellite ,%NWL%d3 . geoSinuMollweide ,%NWL%d3 . geoSinusoidal ,%NWL%d3 . geoTimes ,%NWL%d3 . geoVanDerGrinten ,%NWL%0
d3 . geoPatterson ,%NWL%d3 . geoPeirceQuincuncial ,%NWL%d3 . geoPolyconic ,%NWL%d3 . geoRectangularPolyconic ,%NWL%d3 . geoRobinson ,%NWL%d3 . geoSatellite ,%NWL%d3 . geoSinuMollweide ,%NWL%d3 . geoSinusoidal ,%NWL%d3 . geoTimes ,%NWL%d3 . geoTwoPointEquidistantUsa ,%NWL%d3 . geoVanDerGrinten2 ,%NWL%0
d3 . geoPeirceQuincuncial ,%NWL%d3 . geoPolyconic ,%NWL%d3 . geoRectangularPolyconic ,%NWL%d3 . geoRobinson ,%NWL%d3 . geoSatellite ,%NWL%d3 . geoSinuMollweide ,%NWL%d3 . geoSinusoidal ,%NWL%d3 . geoTimes ,%NWL%d3 . geoTwoPointEquidistantUsa ,%NWL%d3 . geoVanDerGrinten ,%NWL%d3 . geoVanDerGrinten3 ,%NWL%0
d3 . geoPolyconic ,%NWL%d3 . geoRectangularPolyconic ,%NWL%d3 . geoRobinson ,%NWL%d3 . geoSatellite ,%NWL%d3 . geoSinuMollweide ,%NWL%d3 . geoSinusoidal ,%NWL%d3 . geoTimes ,%NWL%d3 . geoTwoPointEquidistantUsa ,%NWL%d3 . geoVanDerGrinten ,%NWL%d3 . geoVanDerGrinten2 ,%NWL%d3 . geoVanDerGrinten4 ,%NWL%0
d3 . geoRectangularPolyconic ,%NWL%d3 . geoRobinson ,%NWL%d3 . geoSatellite ,%NWL%d3 . geoSinuMollweide ,%NWL%d3 . geoSinusoidal ,%NWL%d3 . geoTimes ,%NWL%d3 . geoTwoPointEquidistantUsa ,%NWL%d3 . geoVanDerGrinten ,%NWL%d3 . geoVanDerGrinten2 ,%NWL%d3 . geoVanDerGrinten3 ,%NWL%d3 . geoWagner4 ,%NWL%0
d3 . geoRobinson ,%NWL%d3 . geoSatellite ,%NWL%d3 . geoSinuMollweide ,%NWL%d3 . geoSinusoidal ,%NWL%d3 . geoTimes ,%NWL%d3 . geoTwoPointEquidistantUsa ,%NWL%d3 . geoVanDerGrinten ,%NWL%d3 . geoVanDerGrinten2 ,%NWL%d3 . geoVanDerGrinten3 ,%NWL%d3 . geoVanDerGrinten4 ,%NWL%d3 . geoWagner6 ,%NWL%0
d3 . geoSatellite ,%NWL%d3 . geoSinuMollweide ,%NWL%d3 . geoSinusoidal ,%NWL%d3 . geoTimes ,%NWL%d3 . geoTwoPointEquidistantUsa ,%NWL%d3 . geoVanDerGrinten ,%NWL%d3 . geoVanDerGrinten2 ,%NWL%d3 . geoVanDerGrinten3 ,%NWL%d3 . geoVanDerGrinten4 ,%NWL%d3 . geoWagner4 ,%NWL%d3 . geoWagner7 ,%NWL%0
d3 . geoSinuMollweide ,%NWL%d3 . geoSinusoidal ,%NWL%d3 . geoTimes ,%NWL%d3 . geoTwoPointEquidistantUsa ,%NWL%d3 . geoVanDerGrinten ,%NWL%d3 . geoVanDerGrinten2 ,%NWL%d3 . geoVanDerGrinten3 ,%NWL%d3 . geoVanDerGrinten4 ,%NWL%d3 . geoWagner4 ,%NWL%d3 . geoWagner6 ,%NWL%d3 . geoWiechel ,%NWL%0
} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize ( MultiPoint ) quantizes coordinates " , function ( test )  {%NWL%test . deepEqual ( d3 . geoQuantize ( {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ 0 . 1000001 , 0 . 1000001 ] ]%NWL%} , 2 ) ,  {%NWL%type: " MultiPoint " ,%NWL%coordinates: [ [ 0 . 1 , 0 . 1 ] ]%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize ( LineString ) quantizes coordinates " , function ( test )  {%NWL%test . deepEqual ( d3 . geoQuantize ( {%NWL%type: " LineString " ,%NWL%coordinates: [ [ 0 . 1000001 , 0 . 1000001 ] ,  [ 0 . 2000001 , 0 . 2000001 ] ]%NWL%} , 2 ) ,  {%NWL%type: " LineString " ,%NWL%coordinates: [ [ 0 . 1 , 0 . 1 ] ,  [ 0 . 2 , 0 . 2 ] ]%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize ( MultiLineString ) quantizes coordinates " , function ( test )  {%NWL%test . deepEqual ( d3 . geoQuantize ( {%NWL%type: " MultiLineString " ,%NWL%coordinates: [ [ [ 0 . 1000001 , 0 . 1000001 ] ,  [ 0 . 2000001 , 0 . 2000001 ] ] ]%NWL%} , 2 ) ,  {%NWL%type: " MultiLineString " ,%NWL%coordinates: [ [ [ 0 . 1 , 0 . 1 ] ,  [ 0 . 2 , 0 . 2 ] ] ]%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize ( Polygon ) quantizes coordinates " , function ( test )  {%NWL%test . deepEqual ( d3 . geoQuantize ( {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ 0 . 1000001 , 0 . 1000001 ] ,  [ 0 . 2000001 , 0 . 1000001 ] ,  [ 0 . 1000001 , 0 . 2000001 ] ,  [ 0 . 1000001 , 0 . 1000001 ] ] ]%NWL%} , 2 ) ,  {%NWL%type: " Polygon " ,%NWL%coordinates: [ [ [ 0 . 1 , 0 . 1 ] ,  [ 0 . 2 , 0 . 1 ] ,  [ 0 . 1 , 0 . 2 ] ,  [ 0 . 1 , 0 . 1 ] ] ]%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize ( MultiPolygon ) quantizes coordinates " , function ( test )  {%NWL%test . deepEqual ( d3 . geoQuantize ( {%NWL%type: " MultiPolygon " ,%NWL%coordinates: [ [ [ [ 0 . 1000001 , 0 . 1000001 ] ,  [ 0 . 2000001 , 0 . 1000001 ] ,  [ 0 . 1000001 , 0 . 2000001 ] ,  [ 0 . 1000001 , 0 . 1000001 ] ] ] ]%NWL%} , 2 ) ,  {%NWL%type: " MultiPolygon " ,%NWL%coordinates: [ [ [ [ 0 . 1 , 0 . 1 ] ,  [ 0 . 2 , 0 . 1 ] ,  [ 0 . 1 , 0 . 2 ] ,  [ 0 . 1 , 0 . 1 ] ] ] ]%NWL%test . end ( ) ;%NWL%1
]%NWL%} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%[ " fiji " ,  " antarctica " ,  " russia " ] . forEach ( function ( name )  {%NWL%tape ( " stitch ( "  + name +  " ) " , function ( test )  {%NWL%var unstitched = require ( " . / data / unstitched - "  + name +  " . json " ) ,%NWL%stitched = require ( " . / data / stitched - "  + name +  " . json " ) ,%NWL%original = JSON . parse ( JSON . stringify ( unstitched ) ) ;%NWL%test . deepEqual ( d3 . geoStitch ( unstitched ) , stitched ) ;%NWL%test . end ( ) ;%NWL%2
var std = 1 ,%NWL%mean = 0;%NWL%var input_pos_match = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ] ;%NWL%var input_no_match = [ 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ] ;%NWL%tape ( ' rule_4 marks noise ' , function ( test )  {%NWL%var result = rule_4 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_4 does not mark no variance ' , function ( test )  {%NWL%test . notOk ( result ) ;%NWL%6
mean = 0;%NWL%var input_pos_match = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ] ;%NWL%var input_no_match = [ 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ] ;%NWL%tape ( ' rule_4 marks noise ' , function ( test )  {%NWL%var result = rule_4 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_4 does not mark no variance ' , function ( test )  {%NWL%var result = rule_4 ( input_no_match , mean , std ) ;%NWL%test . end ( ) ;%NWL%6
} else {%NWL%node . x = previousNode ? x + = separation ( node , previousNode ) : 0;%NWL%node . y = 0;%NWL%previousNode = node;%NWL%}%NWL%} ) ;%NWL%var left = leafLeft ( root ) ,%NWL%right = leafRight ( root ) ,%NWL%x0 = left . x - separation ( left , right )  / 2 ,%NWL%x1 = right . x + separation ( right , left )  / 2;%NWL%node . x = ( node . x - root . x )  * dx;%NWL%1
node . x = previousNode ? x + = separation ( node , previousNode ) : 0;%NWL%node . y = 0;%NWL%previousNode = node;%NWL%}%NWL%} ) ;%NWL%var left = leafLeft ( root ) ,%NWL%right = leafRight ( root ) ,%NWL%x0 = left . x - separation ( left , right )  / 2 ,%NWL%x1 = right . x + separation ( right , left )  / 2;%NWL%return root . eachAfter ( nodeSize ? function ( node )  {%NWL%node . y = ( root . y - node . y )  * dy;%NWL%0
previousNode = node;%NWL%}%NWL%} ) ;%NWL%var left = leafLeft ( root ) ,%NWL%right = leafRight ( root ) ,%NWL%x0 = left . x - separation ( left , right )  / 2 ,%NWL%x1 = right . x + separation ( right , left )  / 2;%NWL%return root . eachAfter ( nodeSize ? function ( node )  {%NWL%node . x = ( node . x - root . x )  * dx;%NWL%node . y = ( root . y - node . y )  * dy;%NWL%node . x = ( node . x - x0 )  /  ( x1 - x0 )  * dx;%NWL%8
}%NWL%} ) ;%NWL%var left = leafLeft ( root ) ,%NWL%right = leafRight ( root ) ,%NWL%x0 = left . x - separation ( left , right )  / 2 ,%NWL%x1 = right . x + separation ( right , left )  / 2;%NWL%return root . eachAfter ( nodeSize ? function ( node )  {%NWL%node . x = ( node . x - root . x )  * dx;%NWL%node . y = ( root . y - node . y )  * dy;%NWL%} : function ( node )  {%NWL%node . y = ( 1 -  ( root . y ? node . y / root . y : 1 ) )  * dy;%NWL%7
export default function ( node )  {%NWL%node . x0 = Math . round ( node . x0 ) ;%NWL%node . x1 = Math . round ( node . x1 ) ;%NWL%1
export default function ( node )  {%NWL%node . x0 = Math . round ( node . x0 ) ;%NWL%node . y0 = Math . round ( node . y0 ) ;%NWL%node . y1 = Math . round ( node . y1 ) ;%NWL%1
data: { id: 2 , parentId: 0 }%NWL%}%NWL%]%NWL%} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " stratify ( data ) throws an error if the data does not have a single root " , function ( test )  {%NWL%var s = d3_hierarchy . stratify ( ) ;%NWL%test . throws ( function ( )  { s ( [ { id: " a " } ,  { id: " b " } ] ) ; } ,  / \bmultiple roots\b / ) ;%NWL%test . throws ( function ( )  { s ( [ { id: " a " , parentId: " a " } ] ) ; } ,  / \bno root\b / ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " stratify ( data ) throws an error if the data does not have a single root " , function ( test )  {%NWL%var s = d3_hierarchy . stratify ( ) ;%NWL%test . throws ( function ( )  { s ( [ { id: " a " } ,  { id: " b " } ] ) ; } ,  / \bmultiple roots\b / ) ;%NWL%test . throws ( function ( )  { s ( [ { id: " a " , parentId: " a " } ] ) ; } ,  / \bno root\b / ) ;%NWL%test . throws ( function ( )  { s ( [ { id: " a " , parentId: " b " } ,  { id: " b " , parentId: " a " } ] ) ; } ,  / \bno root\b / ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " stratify ( data ) throws an error if the hierarchy is cyclical " , function ( test )  {%NWL%var s = d3_hierarchy . stratify ( ) ;%NWL%test . throws ( function ( )  { s ( [ { id: " root " } ,  { id: " a " , parentId: " a " } ] ) ; } ,  / \bcycle\b / ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " stratify ( data ) throws an error if the hierarchy is cyclical " , function ( test )  {%NWL%var s = d3_hierarchy . stratify ( ) ;%NWL%test . throws ( function ( )  { s ( [ { id: " root " } ,  { id: " a " , parentId: " a " } ] ) ; } ,  / \bcycle\b / ) ;%NWL%test . throws ( function ( )  { s ( [ { id: " root " } ,  { id: " a " , parentId: " b " } ,  { id: " b " , parentId: " a " } ] ) ; } ,  / \bcycle\b / ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " stratify ( data ) throws an error if multiple parents have the same id " , function ( test )  {%NWL%var s = d3_hierarchy . stratify ( ) ;%NWL%test . end ( ) ;%NWL%0
test . throws ( function ( )  { s ( [ { id: " root " } ,  { id: " a " , parentId: " b " } ,  { id: " b " , parentId: " a " } ] ) ; } ,  / \bcycle\b / ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " stratify ( data ) throws an error if multiple parents have the same id " , function ( test )  {%NWL%var s = d3_hierarchy . stratify ( ) ;%NWL%test . throws ( function ( )  { s ( [ { id: " a " } ,  { id: " b " , parentId: " a " } ,  { id: " b " , parentId: " a " } ,  { id: " c " , parentId: " b " } ] ) ; } ,  / \bambiguous\b / ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " stratify ( data ) throws an error if the specified parent is not found " , function ( test )  {%NWL%var s = d3_hierarchy . stratify ( ) ;%NWL%test . end ( ) ;%NWL%1
]%NWL%} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " stratify ( data ) coerces the id to a string , if not null and not empty " , function ( test )  {%NWL%var s = d3_hierarchy . stratify ( ) ;%NWL%test . strictEqual ( s ( [ { id: { toString: function ( )  { return " a " } } } ] ) . id ,  " a " ) ;%NWL%test . strictEqual ( s ( [ { id: " " } ] ) . id , undefined ) ;%NWL%test . strictEqual ( s ( [ { id: null } ] ) . id , undefined ) ;%NWL%test . strictEqual ( s ( [ { id: undefined } ] ) . id , undefined ) ;%NWL%test . end ( ) ;%NWL%2
height: 0 ,%NWL%data: { foo: " ab " , parentId: " a "  }%NWL%}%NWL%]%NWL%} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " stratify . id ( id ) tests that id is a function " , function ( test )  {%NWL%var s = d3_hierarchy . stratify ( ) ;%NWL%test . throws ( function ( )  { s . id ( 42 ) ; } ) ;%NWL%test . end ( ) ;%NWL%5
height: 0 ,%NWL%data: { id: " ab " , foo: " a " }%NWL%}%NWL%]%NWL%} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " stratify . parentId ( id ) tests that id is a function " , function ( test )  {%NWL%var s = d3_hierarchy . stratify ( ) ;%NWL%test . throws ( function ( )  { s . parentId ( 42 ) ; } ) ;%NWL%test . end ( ) ;%NWL%5
var d3 = Object . assign ( { } , require ( " . . / . . / " ) , require ( " d3 - array " ) , require ( " d3 - random " ) ) ,%NWL%var slice = Array . prototype . slice ,%NWL%0
if ( ! ( n % 100 ) ) process . stdout . write ( " . " ) ;%NWL%if ( ! ( n % 10000 ) ) process . stdout . write ( " \n "  + n +  "  " ) ;%NWL%+ + n;%NWL%var radii = new Array ( 20 ) . fill ( ) . map ( r ) . map ( Math . ceil ) ;%NWL%try {%NWL%if ( intersectsAny ( d3 . packSiblings ( radii . map ( r => ( { r: r } ) ) ) ) )  {%NWL%throw new Error ( " overlap " ) ;%NWL%}%NWL%} catch ( error )  {%NWL%process . stdout . write ( " \n " ) ;%NWL%process . stdout . write ( " \n " ) ;%NWL%9
if ( ! ( n % 1000 ) ) process . stdout . write ( " \n "  + n +  "  " ) ;%NWL%+ + n;%NWL%var circles = new Array ( 20 ) . fill ( ) . map ( ( ) => ( { r: r ( ) , x: x ( ) , y: y ( ) } ) ) , circles2 ,%NWL%enclose = d3 . packEnclose ( circles ) , enclose2;%NWL%if ( circles . some ( circle => !encloses ( enclose , circle ) ) )  {%NWL%console . log ( JSON . stringify ( circles ) ) ;%NWL%}%NWL%for ( var i = 0; i < m; + + i )  {%NWL%if ( !equals ( enclose , enclose2 = d3 . packEnclose ( circles2 = d3 . shuffle ( circles . slice ( ) ) ) ) )  {%NWL%console . log ( JSON . stringify ( enclose ) ) ;%NWL%console . log ( JSON . stringify ( circles ) ) ;%NWL%5
) ) ;%NWL%function test ( input , expected , tile )  {%NWL%return function ( test )  {%NWL%d3_queue . queue ( )%NWL%. defer ( fs . readFile , input ,  " utf8 " )%NWL%. defer ( fs . readFile , expected ,  " utf8 " )%NWL%. await ( ready ) ;%NWL%function ready ( error , inputText , expectedText )  {%NWL%if ( error ) throw error;%NWL%var stratify = d3_hierarchy . stratify ( )%NWL%var pack = d3_hierarchy . pack ( )%NWL%9
var pack = d3_hierarchy . pack ( )%NWL%. size ( [ 960 , 960 ] ) ;%NWL%var data = d3_dsv . csvParse ( inputText ) ,%NWL%expected = JSON . parse ( expectedText ) ,%NWL%actual = pack ( stratify ( data )%NWL%. sum ( function ( d )  { return d . value; } )%NWL%. sort ( function ( a , b )  { return b . value - a . value || a . data . id . localeCompare ( b . data . id ) ; } ) ) ;%NWL%( function visit ( node )  {%NWL%node . name = node . data . id . slice ( node . data . id . lastIndexOf ( " . " )  + 1 ) ;%NWL%node . x = round ( node . x ) ;%NWL%node . r = round ( node . r ) ;%NWL%9
node . x = round ( node . x ) ;%NWL%node . y = round ( node . y ) ;%NWL%node . r = round ( node . r ) ;%NWL%delete node . id;%NWL%delete node . parent;%NWL%delete node . data;%NWL%delete node . depth;%NWL%delete node . height;%NWL%if ( node . children ) node . children . forEach ( visit ) ;%NWL%} ) ( actual ) ;%NWL%node . x = round ( node . x ) ;%NWL%0
node . y = round ( node . y ) ;%NWL%node . r = round ( node . r ) ;%NWL%delete node . id;%NWL%delete node . parent;%NWL%delete node . data;%NWL%delete node . depth;%NWL%delete node . height;%NWL%if ( node . children ) node . children . forEach ( visit ) ;%NWL%} ) ( actual ) ;%NWL%( function visit ( node )  {%NWL%node . y = round ( node . y ) ;%NWL%0
node . r = round ( node . r ) ;%NWL%delete node . id;%NWL%delete node . parent;%NWL%delete node . data;%NWL%delete node . depth;%NWL%delete node . height;%NWL%if ( node . children ) node . children . forEach ( visit ) ;%NWL%} ) ( actual ) ;%NWL%( function visit ( node )  {%NWL%node . x = round ( node . x ) ;%NWL%node . r = round ( node . r ) ;%NWL%0
test . equal ( intersectsAny ( d3 . packSiblings ( [ 2 , 9071 , 79 , 51 , 325 , 867 , 546 , 19773 , 371 , 16 , 165781 , 10474 , 6928 , 40201 , 31062 , 14213 , 8626 , 12 , 299 , 1075 , 98918 , 4738 , 664 , 2694 , 2619 , 51237 , 21431 , 99 , 5920 , 1117 , 321 , 519162 , 33559 , 234 , 4207 ] . map ( circleValue ) ) ) , false ) ;%NWL%test . equal ( intersectsAny ( d3 . packSiblings ( [ 0 . 3371386860049076 , 58 . 65337373332081 , 2 . 118883785686244 , 1 . 7024669121097333 , 5 . 834919697833051 , 8 . 949453403094978 , 6 . 792586534702093 , 105 . 30490014617664 , 6 . 058936212213754 , 0 . 9535722042975694 , 313 . 7636051642043 ] . map ( circleRadius ) ) ) , false ) ;%NWL%test . equal ( intersectsAny ( d3 . packSiblings ( [ 6 . 26551789195159 , 1 . 707773433636342 , 9 . 43220282933871 , 9 . 298909705475646 , 5 . 753163715613753 , 8 . 882383159012575 , 0 . 5819319661882536 , 2 . 0234859171687747 , 2 . 096171518434433 , 9 . 762727931304937 ] . map ( circleRadius ) ) ) , false ) ;%NWL%test . equal ( intersectsAny ( d3 . packSiblings ( [ 9 . 153035316963035 , 9 . 86048622524424 , 8 . 3974499571329 , 7 . 8338007571397865 , 8 . 78260490259886 , 6 . 165829618300345 , 7 . 134819943097564 , 7 . 803701771392344 , 5 . 056638985134191 , 7 . 424601077645588 , 8 . 538658023474753 , 2 . 4616388562274896 , 0 . 5444633747829343 , 9 . 005740508584667 ] . map ( circleRadius ) ) ) , false ) ;%NWL%test . equal ( intersectsAny ( d3 . packSiblings ( [ 2 . 23606797749979 , 52 . 07088264296293 , 5 . 196152422706632 , 20 . 09975124224178 , 357 . 11557267679996 , 4 . 898979485566356 , 14 . 7648230602334 , 17 . 334875731491763 ] . map ( circleRadius ) ) ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " packSiblings ( circles ) can successfully pack a circle with a tiny radius " , function ( test )  {%NWL%test . equal ( intersectsAny ( d3 . packSiblings ( [%NWL%0 . 5672035864083508 ,%NWL%0 . 5628456216244132 ,%NWL%9
test . equal ( intersectsAny ( d3 . packSiblings ( [ 9 . 153035316963035 , 9 . 86048622524424 , 8 . 3974499571329 , 7 . 8338007571397865 , 8 . 78260490259886 , 6 . 165829618300345 , 7 . 134819943097564 , 7 . 803701771392344 , 5 . 056638985134191 , 7 . 424601077645588 , 8 . 538658023474753 , 2 . 4616388562274896 , 0 . 5444633747829343 , 9 . 005740508584667 ] . map ( circleRadius ) ) ) , false ) ;%NWL%test . equal ( intersectsAny ( d3 . packSiblings ( [ 2 . 23606797749979 , 52 . 07088264296293 , 5 . 196152422706632 , 20 . 09975124224178 , 357 . 11557267679996 , 4 . 898979485566356 , 14 . 7648230602334 , 17 . 334875731491763 ] . map ( circleRadius ) ) ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " packSiblings ( circles ) can successfully pack a circle with a tiny radius " , function ( test )  {%NWL%test . equal ( intersectsAny ( d3 . packSiblings ( [%NWL%0 . 5672035864083508 ,%NWL%0 . 6363498687452267 ,%NWL%0 . 5628456216244132 ,%NWL%1 . 5619458670239148 ,%NWL%0 . 9195955097595698 ,%NWL%6
test . equal ( intersectsAny ( d3 . packSiblings ( [ 2 . 23606797749979 , 52 . 07088264296293 , 5 . 196152422706632 , 20 . 09975124224178 , 357 . 11557267679996 , 4 . 898979485566356 , 14 . 7648230602334 , 17 . 334875731491763 ] . map ( circleRadius ) ) ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " packSiblings ( circles ) can successfully pack a circle with a tiny radius " , function ( test )  {%NWL%test . equal ( intersectsAny ( d3 . packSiblings ( [%NWL%0 . 5672035864083508 ,%NWL%0 . 6363498687452267 ,%NWL%0 . 5628456216244132 ,%NWL%1 . 5619458670239148 ,%NWL%1 . 5658933259424268 ,%NWL%0 . 4747083763630309 ,%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " packSiblings ( circles ) can successfully pack a circle with a tiny radius " , function ( test )  {%NWL%test . equal ( intersectsAny ( d3 . packSiblings ( [%NWL%0 . 5672035864083508 ,%NWL%0 . 6363498687452267 ,%NWL%0 . 5628456216244132 ,%NWL%1 . 5619458670239148 ,%NWL%1 . 5658933259424268 ,%NWL%0 . 9195955097595698 ,%NWL%0 . 38341282734497434 ,%NWL%4
} ) ;%NWL%tape ( " packSiblings ( circles ) can successfully pack a circle with a tiny radius " , function ( test )  {%NWL%test . equal ( intersectsAny ( d3 . packSiblings ( [%NWL%0 . 5672035864083508 ,%NWL%0 . 6363498687452267 ,%NWL%0 . 5628456216244132 ,%NWL%1 . 5619458670239148 ,%NWL%1 . 5658933259424268 ,%NWL%0 . 9195955097595698 ,%NWL%0 . 4747083763630309 ,%NWL%1 . 3475593361729394 ,%NWL%6
tape ( " packSiblings ( circles ) can successfully pack a circle with a tiny radius " , function ( test )  {%NWL%test . equal ( intersectsAny ( d3 . packSiblings ( [%NWL%0 . 5672035864083508 ,%NWL%0 . 6363498687452267 ,%NWL%0 . 5628456216244132 ,%NWL%1 . 5619458670239148 ,%NWL%1 . 5658933259424268 ,%NWL%0 . 9195955097595698 ,%NWL%0 . 4747083763630309 ,%NWL%0 . 38341282734497434 ,%NWL%0 . 7492342961633259 ,%NWL%2
test . equal ( intersectsAny ( d3 . packSiblings ( [%NWL%0 . 5672035864083508 ,%NWL%0 . 6363498687452267 ,%NWL%0 . 5628456216244132 ,%NWL%1 . 5619458670239148 ,%NWL%1 . 5658933259424268 ,%NWL%0 . 9195955097595698 ,%NWL%0 . 4747083763630309 ,%NWL%0 . 38341282734497434 ,%NWL%1 . 3475593361729394 ,%NWL%1 . 0716990115071823 ,%NWL%4
0 . 5672035864083508 ,%NWL%0 . 6363498687452267 ,%NWL%0 . 5628456216244132 ,%NWL%1 . 5619458670239148 ,%NWL%1 . 5658933259424268 ,%NWL%0 . 9195955097595698 ,%NWL%0 . 4747083763630309 ,%NWL%0 . 38341282734497434 ,%NWL%1 . 3475593361729394 ,%NWL%0 . 7492342961633259 ,%NWL%0 . 31686823341701664 ,%NWL%0
var tape = require ( " tape " ) ,%NWL%d3_hierarchy = require ( " . . / . . / " ) ,%NWL%round = require ( " . / round " ) ,%NWL%simple = require ( " . . / data / simple2 " ) ;%NWL%var treemap = d3_hierarchy . treemap ( ) ;%NWL%0
d3_hierarchy = require ( " . . / . . / " ) ,%NWL%round = require ( " . / round " ) ,%NWL%simple = require ( " . . / data / simple2 " ) ;%NWL%tape ( " treemap ( ) has the expected defaults " , function ( test )  {%NWL%var treemap = d3_hierarchy . treemap ( ) ;%NWL%test . equal ( treemap . tile ( ) , d3_hierarchy . treemapSquarify ) ;%NWL%test . deepEqual ( treemap . size ( ) ,  [ 1 , 1 ] ) ;%NWL%test . deepEqual ( treemap . round ( ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var treemap = d3_hierarchy . treemap ( ) . size ( [ 600 , 400 ] ) . round ( true ) ,%NWL%4
{ x0: 300 , x1: 471 , y0:  0 , y1: 233 } ,%NWL%{ x0: 471 , x1: 600 , y0:  0 , y1: 233 } ,%NWL%{ x0: 300 , x1: 540 , y0: 233 , y1: 317 } ,%NWL%{ x0: 300 , x1: 540 , y0: 317 , y1: 400 } ,%NWL%{ x0: 540 , x1: 600 , y0: 233 , y1: 400 }%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " treemap . round ( round ) coerces the specified round to boolean " , function ( test )  {%NWL%var treemap = d3_hierarchy . treemap ( ) . round ( " yes " ) ;%NWL%test . end ( ) ;%NWL%6
{ x0: 300 , x1: 540 , y0: 317 , y1: 400 } ,%NWL%{ x0: 540 , x1: 600 , y0: 233 , y1: 400 }%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " treemap . round ( round ) coerces the specified round to boolean " , function ( test )  {%NWL%var treemap = d3_hierarchy . treemap ( ) . round ( " yes " ) ;%NWL%test . strictEqual ( treemap . round ( ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var treemap = d3_hierarchy . treemap ( ) . padding ( " 42 " ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " treemap . padding ( padding ) sets the inner and outer padding to the specified value " , function ( test )  {%NWL%var treemap = d3_hierarchy . treemap ( ) . padding ( " 42 " ) ;%NWL%test . strictEqual ( treemap . padding ( ) ( ) , 42 ) ;%NWL%test . strictEqual ( treemap . paddingInner ( ) ( ) , 42 ) ;%NWL%test . strictEqual ( treemap . paddingOuter ( ) ( ) , 42 ) ;%NWL%test . strictEqual ( treemap . paddingTop ( ) ( ) , 42 ) ;%NWL%test . strictEqual ( treemap . paddingRight ( ) ( ) , 42 ) ;%NWL%test . strictEqual ( treemap . paddingBottom ( ) ( ) , 42 ) ;%NWL%test . end ( ) ;%NWL%0
var treemap = d3_hierarchy . treemap ( ) . padding ( " 42 " ) ;%NWL%test . strictEqual ( treemap . padding ( ) ( ) , 42 ) ;%NWL%test . strictEqual ( treemap . paddingInner ( ) ( ) , 42 ) ;%NWL%test . strictEqual ( treemap . paddingOuter ( ) ( ) , 42 ) ;%NWL%test . strictEqual ( treemap . paddingTop ( ) ( ) , 42 ) ;%NWL%test . strictEqual ( treemap . paddingRight ( ) ( ) , 42 ) ;%NWL%test . strictEqual ( treemap . paddingBottom ( ) ( ) , 42 ) ;%NWL%test . strictEqual ( treemap . paddingLeft ( ) ( ) , 42 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var treemap = d3_hierarchy . treemap ( ) . size ( [ 6 , 4 ] ) . paddingInner ( 0 . 5 ) ,%NWL%0
{ x0: 4 . 71 , x1: 6 . 00 , y0: 0 . 00 , y1: 2 . 33 } ,%NWL%{ x0: 3 . 00 , x1: 5 . 40 , y0: 2 . 33 , y1: 3 . 17 } ,%NWL%{ x0: 3 . 00 , x1: 5 . 40 , y0: 3 . 17 , y1: 4 . 00 } ,%NWL%{ x0: 5 . 40 , x1: 6 . 00 , y0: 2 . 33 , y1: 4 . 00 }%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " treemap . size ( size ) coerces the specified size to numbers " , function ( test )  {%NWL%var treemap = d3_hierarchy . treemap ( ) . size ( [ " 6 " ,  { valueOf: function ( )  { return 4; } } ] ) ;%NWL%test . strictEqual ( treemap . size ( ) [ 0 ] , 6 ) ;%NWL%test . end ( ) ;%NWL%5
test . strictEqual ( treemap . size ( ) [ 0 ] , 6 ) ;%NWL%test . strictEqual ( treemap . size ( ) [ 1 ] , 4 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " treemap . size ( size ) makes defensive copies " , function ( test )  {%NWL%var size = [ 6 , 4 ] ,%NWL%treemap = d3_hierarchy . treemap ( ) . size ( size ) ,%NWL%root = ( size [ 1 ] = 100 , treemap ( d3_hierarchy . hierarchy ( simple ) . sum ( defaultValue ) . sort ( descendingValue ) ) ) ,%NWL%nodes = root . descendants ( ) . map ( round ) ;%NWL%test . deepEqual ( treemap . size ( ) ,  [ 6 , 4 ] ) ;%NWL%test . deepEqual ( treemap . size ( ) ,  [ 6 , 4 ] ) ;%NWL%9
{ x0: 4 . 71 , x1: 6 . 00 , y0: 0 . 00 , y1: 2 . 33 } ,%NWL%{ x0: 3 . 00 , x1: 5 . 40 , y0: 2 . 33 , y1: 3 . 17 } ,%NWL%{ x0: 3 . 00 , x1: 5 . 40 , y0: 3 . 17 , y1: 4 . 00 } ,%NWL%{ x0: 5 . 40 , x1: 6 . 00 , y0: 2 . 33 , y1: 4 . 00 }%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " treemap ( data ) observes the specified sibling order " , function ( test )  {%NWL%var treemap = d3_hierarchy . treemap ( ) ,%NWL%root = treemap ( d3_hierarchy . hierarchy ( simple ) . sum ( defaultValue ) . sort ( ascendingValue ) ) ;%NWL%test . end ( ) ;%NWL%5
d3_hierarchy = require ( " . . / . . / " ) ,%NWL%round = require ( " . / round " ) ;%NWL%tape ( " treemapResquarify ( parent , x0 , y0 , x1 , y1 ) produces a stable update " , function ( test )  {%NWL%var tile = d3_hierarchy . treemapResquarify ,%NWL%root = { value: 20 , children: [ { value: 10 } ,  { value: 10 } ] } ;%NWL%tile ( root , 0 , 0 , 20 , 10 ) ;%NWL%test . deepEqual ( root . children . map ( round ) ,  [%NWL%{ x0: 0 , x1: 10 , y0: 0 , y1: 10 } ,%NWL%{ x0: 10 , x1: 20 , y0: 0 , y1: 10 }%NWL%] ) ;%NWL%test . deepEqual ( root . children . map ( round ) ,  [%NWL%6
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " treemapResquarify . ratio ( ratio ) is stable if the ratio is unchanged " , function ( test )  {%NWL%var root = { value: 20 , children: [ { value: 10 } ,  { value: 10 } ] } ;%NWL%d3_hierarchy . treemapResquarify ( root , 0 , 0 , 20 , 10 ) ;%NWL%test . deepEqual ( root . children . map ( round ) ,  [%NWL%{ x0: 0 , x1: 10 , y0: 0 , y1: 10 } ,%NWL%{ x0: 10 , x1: 20 , y0: 0 , y1: 10 }%NWL%] ) ;%NWL%test . deepEqual ( root . children . map ( round ) ,  [%NWL%6
] ) ;%NWL%d3_hierarchy . treemapResquarify . ratio ( ( 1 + Math . sqrt ( 5 ) )  / 2 ) ( root , 0 , 0 , 10 , 20 ) ;%NWL%test . deepEqual ( root . children . map ( round ) ,  [%NWL%{ x0: 0 , x1: 5 , y0: 0 , y1: 20 } ,%NWL%{ x0: 5 , x1: 10 , y0: 0 , y1: 20 }%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " treemapResquarify . ratio ( ratio ) is unstable if the ratio is changed " , function ( test )  {%NWL%var root = { value: 20 , children: [ { value: 10 } ,  { value: 10 } ] } ;%NWL%test . deepEqual ( root . children . map ( round ) ,  [%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " treemapResquarify . ratio ( ratio ) is unstable if the ratio is changed " , function ( test )  {%NWL%var root = { value: 20 , children: [ { value: 10 } ,  { value: 10 } ] } ;%NWL%d3_hierarchy . treemapResquarify ( root , 0 , 0 , 20 , 10 ) ;%NWL%test . deepEqual ( root . children . map ( round ) ,  [%NWL%{ x0: 0 , x1: 10 , y0: 0 , y1: 10 } ,%NWL%{ x0: 10 , x1: 20 , y0: 0 , y1: 10 }%NWL%] ) ;%NWL%test . deepEqual ( root . children . map ( round ) ,  [%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " treemapSquarify ( parent , x0 , y0 , x1 , y1 ) does not produce a stable update " , function ( test )  {%NWL%var tile = d3_hierarchy . treemapSquarify ,%NWL%root = { value: 20 , children: [ { value: 10 } ,  { value: 10 } ] } ;%NWL%tile ( root , 0 , 0 , 20 , 10 ) ;%NWL%test . deepEqual ( root . children . map ( round ) ,  [%NWL%{ x0: 0 , x1: 10 , y0: 0 , y1: 10 } ,%NWL%{ x0: 10 , x1: 20 , y0: 0 , y1: 10 }%NWL%] ) ;%NWL%test . deepEqual ( root . children . map ( round ) ,  [%NWL%6
function cubehelix ( hue )  {%NWL%return ( function cubehelixGamma ( y )  {%NWL%y = + y;%NWL%function cubehelix ( start , end )  {%NWL%var h = hue ( ( start = colorCubehelix ( start ) ) . h ,  ( end = colorCubehelix ( end ) ) . h ) ,%NWL%s = color ( start . s , end . s ) ,%NWL%l = color ( start . l , end . l ) ,%NWL%opacity = color ( start . opacity , end . opacity ) ;%NWL%return function ( t )  {%NWL%start . h = h ( t ) ;%NWL%start . l = l ( Math . pow ( t , y ) ) ;%NWL%9
var tape = require ( " tape " ) ,%NWL%interpolate = require ( " . . / " ) ;%NWL%tape ( " interpolateArray ( a , b ) interpolates defined elements in a and b " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateArray ( [ 2 , 12 ] ,  [ 4 , 24 ] ) ( 0 . 5 ) ,  [ 3 , 18 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateArray ( a , b ) interpolates nested objects and arrays " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateArray ( [ [ 2 , 12 ] ] ,  [ [ 4 , 24 ] ] ) ( 0 . 5 ) ,  [ [ 3 , 18 ] ] ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " interpolateArray ( a , b ) interpolates defined elements in a and b " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateArray ( [ 2 , 12 ] ,  [ 4 , 24 ] ) ( 0 . 5 ) ,  [ 3 , 18 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateArray ( a , b ) interpolates nested objects and arrays " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateArray ( [ [ 2 , 12 ] ] ,  [ [ 4 , 24 ] ] ) ( 0 . 5 ) ,  [ [ 3 , 18 ] ] ) ;%NWL%test . deepEqual ( interpolate . interpolateArray ( [ { foo: [ 2 , 12 ] } ] ,  [ { foo: [ 4 , 24 ] } ] ) ( 0 . 5 ) ,  [ { foo: [ 3 , 18 ] } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateArray ( a , b ) ignores elements in a that are not in b " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " interpolateArray ( a , b ) interpolates nested objects and arrays " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateArray ( [ [ 2 , 12 ] ] ,  [ [ 4 , 24 ] ] ) ( 0 . 5 ) ,  [ [ 3 , 18 ] ] ) ;%NWL%test . deepEqual ( interpolate . interpolateArray ( [ { foo: [ 2 , 12 ] } ] ,  [ { foo: [ 4 , 24 ] } ] ) ( 0 . 5 ) ,  [ { foo: [ 3 , 18 ] } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateArray ( a , b ) ignores elements in a that are not in b " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateArray ( [ 2 , 12 , 12 ] ,  [ 4 , 24 ] ) ( 0 . 5 ) ,  [ 3 , 18 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateArray ( a , b ) uses constant elements in b that are not in a " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( interpolate . interpolateArray ( [ 2 , 12 , 12 ] ,  [ 4 , 24 ] ) ( 0 . 5 ) ,  [ 3 , 18 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateArray ( a , b ) uses constant elements in b that are not in a " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateArray ( [ 2 , 12 ] ,  [ 4 , 24 , 12 ] ) ( 0 . 5 ) ,  [ 3 , 18 , 12 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateArray ( a , b ) treats undefined as an empty array " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateArray ( undefined ,  [ 2 , 12 ] ) ( 0 . 5 ) ,  [ 2 , 12 ] ) ;%NWL%test . deepEqual ( interpolate . interpolateArray ( [ 2 , 12 ] , undefined ) ( 0 . 5 ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( interpolate . interpolateArray ( [ 2 , 12 ] , undefined ) ( 0 . 5 ) ,  [ ] ) ;%NWL%test . deepEqual ( interpolate . interpolateArray ( undefined , undefined ) ( 0 . 5 ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateArray ( a , b ) interpolates array - like objects " , function ( test )  {%NWL%var array = new Float64Array ( 2 ) ,%NWL%args = ( function ( )  { return arguments; } ) ( 2 , 12 ) ;%NWL%array [ 0 ] = 2;%NWL%array [ 1 ] = 12;%NWL%test . deepEqual ( interpolate . interpolateArray ( array ,  [ 4 , 24 ] ) ( 0 . 5 ) ,  [ 3 , 18 ] ) ;%NWL%test . end ( ) ;%NWL%2
var i = interpolate . interpolateDate ( new Date ( 2000 , 0 , 1 ) , new Date ( 2000 , 0 , 2 ) ) ;%NWL%test . equal ( i ( 0 . 0 ) instanceof Date , true ) ;%NWL%test . equal ( i ( 0 . 5 ) instanceof Date , true ) ;%NWL%test . equal ( i ( 1 . 0 ) instanceof Date , true ) ;%NWL%test . strictEqual ( + i ( 0 . 2 ) ,  + new Date ( 2000 , 0 , 1 , 4 , 48 ) ) ;%NWL%test . strictEqual ( + i ( 0 . 4 ) ,  + new Date ( 2000 , 0 , 1 , 9 , 36 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateDate ( a , b ) reuses the output datea " , function ( test )  {%NWL%var i = interpolate . interpolateDate ( new Date ( 2000 , 0 , 1 ) , new Date ( 2000 , 0 , 2 ) ) ;%NWL%test . end ( ) ;%NWL%6
interpolate = require ( " . . / " ) ;%NWL%tape ( " interpolateObject ( a , b ) interpolates defined properties in a and b " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateObject ( { a: 2 , b: 12 } ,  { a: 4 , b: 24 } ) ( 0 . 5 ) ,  { a: 3 , b: 18 } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateObject ( a , b ) interpolates inherited properties in a and b " , function ( test )  {%NWL%function a ( a )  { this . a = a; }%NWL%a . prototype . b = 12;%NWL%test . deepEqual ( interpolate . interpolateObject ( new a ( 2 ) ,  { a: 4 , b: 12 } ) ( 0 . 5 ) ,  { a: 3 , b: 12 } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { a: 2 , b: 12 } , new a ( 4 ) ) ( 0 . 5 ) ,  { a: 3 , b: 12 } ) ;%NWL%test . end ( ) ;%NWL%3
a . prototype . b = 12;%NWL%test . deepEqual ( interpolate . interpolateObject ( new a ( 2 ) ,  { a: 4 , b: 12 } ) ( 0 . 5 ) ,  { a: 3 , b: 12 } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { a: 2 , b: 12 } , new a ( 4 ) ) ( 0 . 5 ) ,  { a: 3 , b: 12 } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( new a ( 4 ) , new a ( 2 ) ) ( 0 . 5 ) ,  { a: 3 , b: 12 } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateObject ( a , b ) interpolates color properties as rgb " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateObject ( { background: " red " } ,  { background: " green " } ) ( 0 . 5 ) ,  { background: " rgb ( 128 , 64 , 0 ) " } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { fill: " red " } ,  { fill: " green " } ) ( 0 . 5 ) ,  { fill: " rgb ( 128 , 64 , 0 ) " } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { stroke: " red " } ,  { stroke: " green " } ) ( 0 . 5 ) ,  { stroke: " rgb ( 128 , 64 , 0 ) " } ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " interpolateObject ( a , b ) interpolates color properties as rgb " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateObject ( { background: " red " } ,  { background: " green " } ) ( 0 . 5 ) ,  { background: " rgb ( 128 , 64 , 0 ) " } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { fill: " red " } ,  { fill: " green " } ) ( 0 . 5 ) ,  { fill: " rgb ( 128 , 64 , 0 ) " } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { stroke: " red " } ,  { stroke: " green " } ) ( 0 . 5 ) ,  { stroke: " rgb ( 128 , 64 , 0 ) " } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { color: " red " } ,  { color: " green " } ) ( 0 . 5 ) ,  { color: " rgb ( 128 , 64 , 0 ) " } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateObject ( a , b ) interpolates nested objects and arrays " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateObject ( { foo: [ 2 , 12 ] } ,  { foo: [ 4 , 24 ] } ) ( 0 . 5 ) ,  { foo: [ 3 , 18 ] } ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( interpolate . interpolateObject ( { stroke: " red " } ,  { stroke: " green " } ) ( 0 . 5 ) ,  { stroke: " rgb ( 128 , 64 , 0 ) " } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { color: " red " } ,  { color: " green " } ) ( 0 . 5 ) ,  { color: " rgb ( 128 , 64 , 0 ) " } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateObject ( a , b ) interpolates nested objects and arrays " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateObject ( { foo: [ 2 , 12 ] } ,  { foo: [ 4 , 24 ] } ) ( 0 . 5 ) ,  { foo: [ 3 , 18 ] } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { foo: { bar: [ 2 , 12 ] } } ,  { foo: { bar: [ 4 , 24 ] } } ) ( 0 . 5 ) ,  { foo: { bar: [ 3 , 18 ] } } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateObject ( a , b ) ignores properties in a that are not in b " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " interpolateObject ( a , b ) interpolates nested objects and arrays " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateObject ( { foo: [ 2 , 12 ] } ,  { foo: [ 4 , 24 ] } ) ( 0 . 5 ) ,  { foo: [ 3 , 18 ] } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { foo: { bar: [ 2 , 12 ] } } ,  { foo: { bar: [ 4 , 24 ] } } ) ( 0 . 5 ) ,  { foo: { bar: [ 3 , 18 ] } } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateObject ( a , b ) ignores properties in a that are not in b " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateObject ( { foo: 2 , bar: 12 } ,  { foo: 4 } ) ( 0 . 5 ) ,  { foo: 3 } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateObject ( a , b ) uses constant properties in b that are not in a " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " interpolateObject ( a , b ) uses constant properties in b that are not in a " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateObject ( { foo: 2 } ,  { foo: 4 , bar: 12 } ) ( 0 . 5 ) ,  { foo: 3 , bar: 12 } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateObject ( a , b ) treats undefined as an empty object " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateObject ( NaN ,  { foo: 2 } ) ( 0 . 5 ) ,  { foo: 2 } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { foo: 2 } , undefined ) ( 0 . 5 ) ,  { } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( undefined ,  { foo: 2 } ) ( 0 . 5 ) ,  { foo: 2 } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { foo: 2 } , null ) ( 0 . 5 ) ,  { } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( null ,  { foo: 2 } ) ( 0 . 5 ) ,  { foo: 2 } ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " interpolateObject ( a , b ) treats undefined as an empty object " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolateObject ( NaN ,  { foo: 2 } ) ( 0 . 5 ) ,  { foo: 2 } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { foo: 2 } , undefined ) ( 0 . 5 ) ,  { } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( undefined ,  { foo: 2 } ) ( 0 . 5 ) ,  { foo: 2 } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( { foo: 2 } , null ) ( 0 . 5 ) ,  { } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( null ,  { foo: 2 } ) ( 0 . 5 ) ,  { foo: 2 } ) ;%NWL%test . deepEqual ( interpolate . interpolateObject ( null , NaN ) ( 0 . 5 ) ,  { } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateObject ( a , b ) interpolates objects without prototype " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . equal ( i ( 0 . 5 ) , 26 ) ;%NWL%test . equal ( i ( 0 . 6 ) , 29 ) ;%NWL%test . equal ( i ( 0 . 7 ) , 32 ) ;%NWL%test . equal ( i ( 0 . 8 ) , 36 ) ;%NWL%test . equal ( i ( 0 . 9 ) , 39 ) ;%NWL%test . equal ( i ( 1 . 0 ) , 42 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateRound ( a , b ) does not pre - round a and b " , function ( test )  {%NWL%var i = interpolate . interpolateRound ( 2 . 6 , 3 . 6 ) ;%NWL%test . end ( ) ;%NWL%6
var tape = require ( " tape " ) ,%NWL%interpolate = require ( " . . / " ) ;%NWL%tape ( " interpolateString ( a , b ) interpolates matching numbers in a and b " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 30 " ,  " 50 / 10 100 " ) ( 0 . 2 ) ,  " 18 / 18 44 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 30 " ,  " 50 / 10 100 " ) ( 0 . 4 ) ,  " 26 / 16 58 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) coerces a and b to strings " , function ( test )  {%NWL%test . end ( ) ;%NWL%5
test . equal ( interpolate . interpolateString ( " 10 / 20 30 " ,  " 50 / 10 100 " ) ( 0 . 2 ) ,  " 18 / 18 44 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 30 " ,  " 50 / 10 100 " ) ( 0 . 4 ) ,  " 26 / 16 58 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) coerces a and b to strings " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( { toString: function ( )  { return " 2px " ; } } ,  { toString: function ( )  { return " 12px " ; } } ) ( 0 . 25 ) ,  " 4 . 5px " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) preserves non - numbers in string b " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 30 " ,  " 50 / 10 foo " ) ( 0 . 2 ) ,  " 18 / 18 foo " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( interpolate . interpolateString ( { toString: function ( )  { return " 2px " ; } } ,  { toString: function ( )  { return " 12px " ; } } ) ( 0 . 25 ) ,  " 4 . 5px " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) preserves non - numbers in string b " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 30 " ,  " 50 / 10 foo " ) ( 0 . 2 ) ,  " 18 / 18 foo " ) ;%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 30 " ,  " 50 / 10 foo " ) ( 0 . 4 ) ,  " 26 / 16 foo " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) preserves non - matching numbers in string b " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 foo " ,  " 50 / 10 100 " ) ( 0 . 2 ) ,  " 18 / 18 100 " ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( interpolate . interpolateString ( " 10 / 20 30 " ,  " 50 / 10 foo " ) ( 0 . 4 ) ,  " 26 / 16 foo " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) preserves non - matching numbers in string b " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 foo " ,  " 50 / 10 100 " ) ( 0 . 2 ) ,  " 18 / 18 100 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 bar " ,  " 50 / 10 100 " ) ( 0 . 4 ) ,  " 26 / 16 100 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) preserves equal - value numbers in both strings " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 100 20 " ,  " 50 / 10 100 , 20 " ) ( 0 . 2 ) ,  " 18 / 18 100 , 20 " ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( interpolate . interpolateString ( " 10 / 20 foo " ,  " 50 / 10 100 " ) ( 0 . 2 ) ,  " 18 / 18 100 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 bar " ,  " 50 / 10 100 " ) ( 0 . 4 ) ,  " 26 / 16 100 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) preserves equal - value numbers in both strings " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 100 20 " ,  " 50 / 10 100 , 20 " ) ( 0 . 2 ) ,  " 18 / 18 100 , 20 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " 10 / 20 100 20 " ,  " 50 / 10 100 , 20 " ) ( 0 . 4 ) ,  " 26 / 16 100 , 20 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) interpolates decimal notation correctly " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " interpolateString ( a , b ) interpolates decimal notation correctly " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " 1 . " ,  " 2 . " ) ( 0 . 5 ) ,  " 1 . 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) interpolates exponent notation correctly " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " 1e + 3 " ,  " 1e + 4 " ) ( 0 . 5 ) ,  " 5500 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " 1e - 3 " ,  " 1e - 4 " ) ( 0 . 5 ) ,  " 0 . 00055 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " 1 . e - 3 " ,  " 1 . e - 4 " ) ( 0 . 5 ) ,  " 0 . 00055 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " - 1 . e - 3 " ,  " - 1 . e - 4 " ) ( 0 . 5 ) ,  " - 0 . 00055 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " + 1 . e - 3 " ,  " + 1 . e - 4 " ) ( 0 . 5 ) ,  " 0 . 00055 " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( interpolate . interpolateString ( " 1 . e - 3 " ,  " 1 . e - 4 " ) ( 0 . 5 ) ,  " 0 . 00055 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " - 1 . e - 3 " ,  " - 1 . e - 4 " ) ( 0 . 5 ) ,  " - 0 . 00055 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " + 1 . e - 3 " ,  " + 1 . e - 4 " ) ( 0 . 5 ) ,  " 0 . 00055 " ) ;%NWL%test . equal ( interpolate . interpolateString ( " . 1e - 2 " ,  " . 1e - 3 " ) ( 0 . 5 ) ,  " 0 . 00055 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) with no numbers , returns the target string " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " foo " ,  " bar " ) ( 0 . 5 ) ,  " bar " ) ;%NWL%test . equal ( interpolate . interpolateString ( " foo " ,  " " ) ( 0 . 5 ) ,  " " ) ;%NWL%test . equal ( interpolate . interpolateString ( " " ,  " bar " ) ( 0 . 5 ) ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " interpolateString ( a , b ) with no numbers , returns the target string " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " foo " ,  " bar " ) ( 0 . 5 ) ,  " bar " ) ;%NWL%test . equal ( interpolate . interpolateString ( " foo " ,  " " ) ( 0 . 5 ) ,  " " ) ;%NWL%test . equal ( interpolate . interpolateString ( " " ,  " bar " ) ( 0 . 5 ) ,  " bar " ) ;%NWL%test . equal ( interpolate . interpolateString ( " " ,  " " ) ( 0 . 5 ) ,  " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateString ( a , b ) with two numerically - equivalent numbers , returns the default format " , function ( test )  {%NWL%test . equal ( interpolate . interpolateString ( " top: 1000px; " ,  " top: 1e3px; " ) ( 0 . 5 ) ,  " top: 1000px; " ) ;%NWL%test . end ( ) ;%NWL%6
var tape = require ( " tape " ) ,%NWL%color = require ( " d3 - color " ) ,%NWL%interpolate = require ( " . . / " ) ;%NWL%tape ( " interpolate ( a , b ) interpolates strings if b is a string and not a color " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( " foo " ,  " bar " ) ( 0 . 5 ) ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates strings if b is a string and not a color , even if b is coercible to a number " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( " 1 " ,  " 2 " ) ( 0 . 5 ) ,  " 1 . 5 " ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates RGB colors if b is a string and a color " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( " red " ,  " blue " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " #ff0000 " ,  " #0000ff " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " #f00 " ,  " #00f " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " rgb ( 255 , 0 , 0 ) " ,  " rgb ( 0 , 0 , 255 ) " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " rgba ( 255 , 0 , 0 , 1 . 0 ) " ,  " rgba ( 0 , 0 , 255 , 1 . 0 ) " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " rgb ( 100% , 0% , 0% ) " ,  " rgb ( 0% , 0% , 100% ) " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " rgba ( 100% , 0% , 0% , 1 . 0 ) " ,  " rgba ( 0% , 0% , 100% , 1 . 0 ) " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%0
test . strictEqual ( interpolate . interpolate ( " #f00 " ,  " #00f " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " rgb ( 255 , 0 , 0 ) " ,  " rgb ( 0 , 0 , 255 ) " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " rgba ( 255 , 0 , 0 , 1 . 0 ) " ,  " rgba ( 0 , 0 , 255 , 1 . 0 ) " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " rgb ( 100% , 0% , 0% ) " ,  " rgb ( 0% , 0% , 100% ) " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " rgba ( 100% , 0% , 0% , 1 . 0 ) " ,  " rgba ( 0% , 0% , 100% , 1 . 0 ) " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " rgba ( 100% , 0% , 0% , 0 . 5 ) " ,  " rgba ( 0% , 0% , 100% , 0 . 7 ) " ) ( 0 . 5 ) ,  " rgba ( 128 , 0 , 128 , 0 . 6 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates RGB colors if b is a color " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( " red " , color . rgb ( " blue " ) ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%6
test . strictEqual ( interpolate . interpolate ( " rgba ( 100% , 0% , 0% , 1 . 0 ) " ,  " rgba ( 0% , 0% , 100% , 1 . 0 ) " ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " rgba ( 100% , 0% , 0% , 0 . 5 ) " ,  " rgba ( 0% , 0% , 100% , 0 . 7 ) " ) ( 0 . 5 ) ,  " rgba ( 128 , 0 , 128 , 0 . 6 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates RGB colors if b is a color " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( " red " , color . rgb ( " blue " ) ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " red " , color . hsl ( " blue " ) ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates arrays if b is an array " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " interpolate ( a , b ) interpolates RGB colors if b is a color " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( " red " , color . rgb ( " blue " ) ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . strictEqual ( interpolate . interpolate ( " red " , color . hsl ( " blue " ) ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates arrays if b is an array " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolate ( [ " red " ] ,  [ " blue " ] ) ( 0 . 5 ) ,  [ " rgb ( 128 , 0 , 128 ) " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates arrays if b is an array , even if b is coercible to a number " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " interpolate ( a , b ) interpolates arrays if b is an array " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolate ( [ " red " ] ,  [ " blue " ] ) ( 0 . 5 ) ,  [ " rgb ( 128 , 0 , 128 ) " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates arrays if b is an array , even if b is coercible to a number " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolate ( [ 1 ] ,  [ 2 ] ) ( 0 . 5 ) ,  [ 1 . 5 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates numbers if b is a number " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( 1 , 2 ) ( 0 . 5 ) , 1 . 5 ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " interpolate ( a , b ) interpolates arrays if b is an array , even if b is coercible to a number " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolate ( [ 1 ] ,  [ 2 ] ) ( 0 . 5 ) ,  [ 1 . 5 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates numbers if b is a number " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( 1 , 2 ) ( 0 . 5 ) , 1 . 5 ) ;%NWL%test . ok ( isNaN ( interpolate . interpolate ( 1 , NaN ) ( 0 . 5 ) ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects if b is an object that is not coercible to a number " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . strictEqual ( interpolate . interpolate ( 1 , 2 ) ( 0 . 5 ) , 1 . 5 ) ;%NWL%test . ok ( isNaN ( interpolate . interpolate ( 1 , NaN ) ( 0 . 5 ) ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects if b is an object that is not coercible to a number " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolate ( { color: " red " } ,  { color: " blue " } ) ( 0 . 5 ) ,  { color: " rgb ( 128 , 0 , 128 ) " } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates numbers if b is an object that is coercible to a number " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( 1 , new Number ( 2 ) ) ( 0 . 5 ) , 1 . 5 ) ;%NWL%test . end ( ) ;%NWL%2
} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates numbers if b is an object that is coercible to a number " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( 1 , new Number ( 2 ) ) ( 0 . 5 ) , 1 . 5 ) ;%NWL%test . strictEqual ( interpolate . interpolate ( 1 , new String ( " 2 " ) ) ( 0 . 5 ) , 1 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates dates if b is a date " , function ( test )  {%NWL%var i = interpolate . interpolate ( new Date ( 2000 , 0 , 1 ) , new Date ( 2000 , 0 , 2 ) ) ,%NWL%d = i ( 0 . 5 ) ;%NWL%test . equal ( d instanceof Date , true ) ;%NWL%test . end ( ) ;%NWL%4
var i = interpolate . interpolate ( new Date ( 2000 , 0 , 1 ) , new Date ( 2000 , 0 , 2 ) ) ,%NWL%d = i ( 0 . 5 ) ;%NWL%test . equal ( d instanceof Date , true ) ;%NWL%test . strictEqual ( + i ( 0 . 5 ) ,  + new Date ( 2000 , 0 , 1 , 12 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) returns the constant b if b is null , undefined or a boolean " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( 0 , null ) ( 0 . 5 ) , null ) ;%NWL%test . strictEqual ( interpolate . interpolate ( 0 , undefined ) ( 0 . 5 ) , undefined ) ;%NWL%test . strictEqual ( interpolate . interpolate ( 0 , true ) ( 0 . 5 ) , true ) ;%NWL%test . end ( ) ;%NWL%4
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) returns the constant b if b is null , undefined or a boolean " , function ( test )  {%NWL%test . strictEqual ( interpolate . interpolate ( 0 , null ) ( 0 . 5 ) , null ) ;%NWL%test . strictEqual ( interpolate . interpolate ( 0 , undefined ) ( 0 . 5 ) , undefined ) ;%NWL%test . strictEqual ( interpolate . interpolate ( 0 , true ) ( 0 . 5 ) , true ) ;%NWL%test . strictEqual ( interpolate . interpolate ( 0 , false ) ( 0 . 5 ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects without prototype " , function ( test )  {%NWL%test . end ( ) ;%NWL%0
test . strictEqual ( interpolate . interpolate ( 0 , true ) ( 0 . 5 ) , true ) ;%NWL%test . strictEqual ( interpolate . interpolate ( 0 , false ) ( 0 . 5 ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects without prototype " , function ( test )  {%NWL%test . deepEqual ( interpolate . interpolate ( noproto ( { foo: 0 } ) , noproto ( { foo: 2 } ) ) ( 0 . 5 ) ,  { foo: 1 } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects with numeric valueOf as numbers " , function ( test )  {%NWL%var proto = { valueOf: foo } ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( interpolate . interpolate ( noproto ( { foo: 0 } ) , noproto ( { foo: 2 } ) ) ( 0 . 5 ) ,  { foo: 1 } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects with numeric valueOf as numbers " , function ( test )  {%NWL%var proto = { valueOf: foo } ;%NWL%test . deepEqual ( interpolate . interpolate ( noproto ( { foo: 0 } , proto ) , noproto ( { foo: 2 } , proto ) ) ( 0 . 5 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects with string valueOf as numbers if valueOf result is coercible to number " , function ( test )  {%NWL%var proto = { valueOf: fooString } ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( interpolate . interpolate ( noproto ( { foo: 0 } , proto ) , noproto ( { foo: 2 } , proto ) ) ( 0 . 5 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects with string valueOf as numbers if valueOf result is coercible to number " , function ( test )  {%NWL%var proto = { valueOf: fooString } ;%NWL%test . deepEqual ( interpolate . interpolate ( noproto ( { foo: 0 } , proto ) , noproto ( { foo: 2 } , proto ) ) ( 0 . 5 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects with string valueOf as objects if valueOf result is not coercible to number " , function ( test )  {%NWL%var proto = { valueOf: fooString } ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( interpolate . interpolate ( noproto ( { foo: 0 } , proto ) , noproto ( { foo: 2 } , proto ) ) ( 0 . 5 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects with string valueOf as objects if valueOf result is not coercible to number " , function ( test )  {%NWL%var proto = { valueOf: fooString } ;%NWL%test . deepEqual ( interpolate . interpolate ( noproto ( { foo: " bar " } , proto ) , noproto ( { foo: " baz " } , proto ) ) ( 0 . 5 ) ,  { foo: " baz " , valueOf: { } } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects with toString as numbers if toString result is coercible to number " , function ( test )  {%NWL%var proto = { toString: fooString } ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( interpolate . interpolate ( noproto ( { foo: " bar " } , proto ) , noproto ( { foo: " baz " } , proto ) ) ( 0 . 5 ) ,  { foo: " baz " , valueOf: { } } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects with toString as numbers if toString result is coercible to number " , function ( test )  {%NWL%var proto = { toString: fooString } ;%NWL%test . deepEqual ( interpolate . interpolate ( noproto ( { foo: 0 } , proto ) , noproto ( { foo: 2 } , proto ) ) ( 0 . 5 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolate ( a , b ) interpolates objects with toString as objects if toString result is not coercible to number " , function ( test )  {%NWL%var proto = { toString: fooString } ;%NWL%test . end ( ) ;%NWL%1
. attr ( " d " , bline ) ;%NWL%ele . selectAll ( " path . reye " ) . data ( [ reye ] ) . enter ( )%NWL%. append ( " path " )%NWL%. attr ( " class " ,  " reye " )%NWL%. attr ( " d " , bline ) ;%NWL%ele . append ( " path " )%NWL%. attr ( " class " ,  " lbrow " )%NWL%. attr ( " d " ,  " M "  +  ( 55 - eyewvar / 1 . 7 - sign ( browvar ) )  +  " , "  +%NWL%( 87 - eyehvar + browvar )  +  "  "  +%NWL%( 55 + eyewvar / 1 . 7 - sign ( browvar ) )  +  " , "  +%NWL%ele . append ( " path " )%NWL%5
var input_pos_match = [ 2 , 1 , 2 ] ;%NWL%var input_neg_match = [ - 2 , 1 ,  - 2 ] ;%NWL%var input_no_match_alt = [ 2 , 1 ,  - 2 ] ;%NWL%var input_no_match_mag = [ 1 . 5 , 1 , 1 . 5 ] ;%NWL%tape ( ' rule_5 marks positive trend ' , function ( test )  {%NWL%var result = rule_5 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_5 marks negative trend ' , function ( test )  {%NWL%test . ok ( result ) ;%NWL%6
var input_neg_match = [ - 2 , 1 ,  - 2 ] ;%NWL%var input_no_match_alt = [ 2 , 1 ,  - 2 ] ;%NWL%var input_no_match_mag = [ 1 . 5 , 1 , 1 . 5 ] ;%NWL%tape ( ' rule_5 marks positive trend ' , function ( test )  {%NWL%var result = rule_5 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_5 marks negative trend ' , function ( test )  {%NWL%var result = rule_5 ( input_neg_match , mean , std ) ;%NWL%test . end ( ) ;%NWL%6
} ) ;%NWL%tape ( ' rule_5 marks negative trend ' , function ( test )  {%NWL%var result = rule_5 ( input_neg_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_5 does not mark no variance ' , function ( test )  {%NWL%var resultAlt = rule_5 ( input_no_match_alt , mean , std ) ;%NWL%test . notOk ( resultAlt ) ;%NWL%var resultMag = rule_5 ( input_no_match_mag , mean , std ) ;%NWL%test . end ( ) ;%NWL%4
var py = y . call ( hexbin , point , i )  / dy , pj = Math . round ( py ) ,%NWL%px = x . call ( hexbin , point , i )  / dx -  ( pj & 1 ? . 5 : 0 ) , pi = Math . round ( px ) ,%NWL%py1 = py - pj;%NWL%if ( Math . abs ( py1 )  * 3 > 1 )  {%NWL%var px1 = px - pi ,%NWL%pi2 = pi +  ( px < pi ? - 1 : 1 )  / 2 ,%NWL%pj2 = pj +  ( py < pj ? - 1 : 1 ) ,%NWL%px2 = px - pi2 ,%NWL%py2 = py - pj2;%NWL%if ( px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2 ) pi = pi2 +  ( pj & 1 ? 1 : - 1 )  / 2 , pj = pj2;%NWL%var id = pi +  " - "  + pj , bin = binsById [ id ] ;%NWL%0
}%NWL%)%NWL%this . envelope . triggerGate ( )%NWL%}%NWL%_ . extend ( Voice . prototype ,%NWL%{ sample: 0%NWL%, length: 12%NWL%, mix: 0 . 5%NWL%, generate: function ( )  {%NWL%this . lfo . generate ( )%NWL%this . osc . generate ( )%NWL%9
)%NWL%this . envelope . triggerGate ( )%NWL%}%NWL%_ . extend ( Voice . prototype ,%NWL%{ sample: 0%NWL%, length: 12%NWL%, mix: 0 . 5%NWL%, generate: function ( )  {%NWL%this . lfo . generate ( )%NWL%this . osc . fm = this . lfo . getMix ( )%NWL%this . envelope . generate ( )%NWL%8
x: prior_pos_obj . x ,%NWL%y: prior_pos_obj . y%NWL%} ;%NWL%a = sign ( d . lassoPoint . cy - cur_pos_obj . y ) !=sign ( d . lassoPoint . cy - prior_pos_obj . y ) ;%NWL%}%NWL%return a;%NWL%} ) . forEach ( function ( d )  {%NWL%if ( cur_pos_obj . x>d . lassoPoint . cx )  {%NWL%d . lassoPoint . edges . right = d . lassoPoint . edges . right + 1;%NWL%}%NWL%d . lassoPoint . edges . left = d . lassoPoint . edges . left + 1;%NWL%8
node . stop ( 0 ) ;%NWL%} ;%NWL%window . setTimeout ( stop , delay ) ;%NWL%node . disconnect ( ) ;%NWL%}%NWL%stopNode ( osc , 1000 )%NWL%}%NWL%this . playTest = function ( )  {%NWL%var node = context . createOscillator ( ) ;%NWL%console . log ( " node is = "  + node ) ;%NWL%node . start ( 0 ) ;%NWL%0
window . setTimeout ( stop , delay ) ;%NWL%node . disconnect ( ) ;%NWL%}%NWL%stopNode ( osc , 1000 )%NWL%}%NWL%this . playTest = function ( )  {%NWL%var node = context . createOscillator ( ) ;%NWL%console . log ( " node is = "  + node ) ;%NWL%node . connect ( context . destination ) ;%NWL%node . start ( 0 ) ;%NWL%node . stop ( 0 ) ;%NWL%9
assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " d3 . urlencode " ) ;%NWL%suite . addBatch ( {%NWL%" urlencode " : {%NWL%topic: function ( )  {%NWL%return d3 . urlencode;%NWL%} ,%NWL%" returns an instanceof d3 . urlencode " : function ( urlencode )  {%NWL%assert . instanceOf ( urlencode ( ) , d3 . urlencode ) ;%NWL%} ,%NWL%assert . isArray ( urlencode ( ) , d3 . urlencode ) ;%NWL%8
var tape = require ( " tape " ) ,%NWL%polygon = require ( " . . / " ) ;%NWL%tape ( " polygonArea ( polygon ) returns the expected value for closed counterclockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonArea ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonArea ( polygon ) returns the expected value for closed clockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonArea ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ) ,  - 1 ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " polygonArea ( polygon ) returns the expected value for closed counterclockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonArea ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonArea ( polygon ) returns the expected value for closed clockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonArea ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ) ,  - 1 ) ;%NWL%test . equal ( polygon . polygonArea ( [ [ 1 , 1 ] ,  [ 3 , 2 ] ,  [ 2 , 3 ] ,  [ 1 , 1 ] ] ) ,  - 1 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonArea ( polygon ) returns the expected value for open counterclockwise polygons " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . equal ( polygon . polygonArea ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ) ,  - 1 ) ;%NWL%test . equal ( polygon . polygonArea ( [ [ 1 , 1 ] ,  [ 3 , 2 ] ,  [ 2 , 3 ] ,  [ 1 , 1 ] ] ) ,  - 1 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonArea ( polygon ) returns the expected value for open counterclockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonArea ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ] ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonArea ( polygon ) returns the expected value for open clockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonArea ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ] ) ,  - 1 ) ;%NWL%test . end ( ) ;%NWL%2
var tape = require ( " tape " ) ,%NWL%polygon = require ( " . . / " ) ;%NWL%tape ( " polygonCentroid ( points ) returns the expected value for closed counterclockwise polygons " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonCentroid ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ) ,  [ . 5 ,  . 5 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonCentroid ( points ) returns the expected value for closed clockwise polygons " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonCentroid ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ) ,  [ . 5 ,  . 5 ] ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " polygonCentroid ( points ) returns the expected value for closed counterclockwise polygons " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonCentroid ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ) ,  [ . 5 ,  . 5 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonCentroid ( points ) returns the expected value for closed clockwise polygons " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonCentroid ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ) ,  [ . 5 ,  . 5 ] ) ;%NWL%test . deepEqual ( polygon . polygonCentroid ( [ [ 1 , 1 ] ,  [ 3 , 2 ] ,  [ 2 , 3 ] ,  [ 1 , 1 ] ] ) ,  [ 2 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonCentroid ( points ) returns the expected value for open counterclockwise polygons " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( polygon . polygonCentroid ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ) ,  [ . 5 ,  . 5 ] ) ;%NWL%test . deepEqual ( polygon . polygonCentroid ( [ [ 1 , 1 ] ,  [ 3 , 2 ] ,  [ 2 , 3 ] ,  [ 1 , 1 ] ] ) ,  [ 2 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonCentroid ( points ) returns the expected value for open counterclockwise polygons " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonCentroid ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ] ) ,  [ . 5 ,  . 5 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonCentroid ( points ) returns the expected value for closed counterclockwise polygons " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonCentroid ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ] ) ,  [ . 5 ,  . 5 ] ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " polygonContains ( polygon , point ) returns the expected value for closed counterclockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ,  [ 0 . 5 , 0 . 5 ] ) , true ) ;%NWL%test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ,  [ 1 . 5 , 0 . 5 ] ) , false ) ;%NWL%test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ,  [ - 0 . 5 , 0 . 5 ] ) , false ) ;%NWL%test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ,  [ 0 . 5 , 1 . 5 ] ) , false ) ;%NWL%test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ,  [ 0 . 5 ,  - 0 . 5 ] ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonContains ( polygon , point ) returns the expected value for closed clockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ,  [ 0 . 5 , 0 . 5 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ,  [ 0 . 5 , 1 . 5 ] ) , false ) ;%NWL%test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ,  [ 0 . 5 ,  - 0 . 5 ] ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonContains ( polygon , point ) returns the expected value for closed clockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ,  [ 0 . 5 , 0 . 5 ] ) , true ) ;%NWL%test . equal ( polygon . polygonContains ( [ [ 1 , 1 ] ,  [ 3 , 2 ] ,  [ 2 , 3 ] ,  [ 1 , 1 ] ] ,  [ 1 . 5 , 1 . 5 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonContains ( polygon , point ) returns the expected value for open counterclockwise polygons " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ,  [ 0 . 5 , 0 . 5 ] ) , true ) ;%NWL%test . equal ( polygon . polygonContains ( [ [ 1 , 1 ] ,  [ 3 , 2 ] ,  [ 2 , 3 ] ,  [ 1 , 1 ] ] ,  [ 1 . 5 , 1 . 5 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonContains ( polygon , point ) returns the expected value for open counterclockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ] ,  [ 0 . 5 , 0 . 5 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonContains ( polygon , point ) returns the expected value for open clockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonContains ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ] ,  [ 0 . 5 , 0 . 5 ] ) , true ) ;%NWL%test . end ( ) ;%NWL%2
var tape = require ( " tape " ) ,%NWL%polygon = require ( " . . / " ) ;%NWL%tape ( " polygonHull ( points ) returns null if points has fewer than three elements " , function ( test )  {%NWL%test . equal ( polygon . polygonHull ( [ ] ) , null ) ;%NWL%test . equal ( polygon . polygonHull ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( polygon . polygonHull ( [ [ 0 , 1 ] ,  [ 1 , 0 ] ] ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonHull ( points ) returns the convex hull of the specified points " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonHull ( [ [ 200 , 200 ] ,  [ 760 , 300 ] ,  [ 500 , 500 ] ] ) ,  [ [ 760 , 300 ] ,  [ 200 , 200 ] ,  [ 500 , 500 ] ] ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( polygon . polygonHull ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( polygon . polygonHull ( [ [ 0 , 1 ] ,  [ 1 , 0 ] ] ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonHull ( points ) returns the convex hull of the specified points " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonHull ( [ [ 200 , 200 ] ,  [ 760 , 300 ] ,  [ 500 , 500 ] ] ) ,  [ [ 760 , 300 ] ,  [ 200 , 200 ] ,  [ 500 , 500 ] ] ) ;%NWL%test . deepEqual ( polygon . polygonHull ( [ [ 200 , 200 ] ,  [ 760 , 300 ] ,  [ 500 , 500 ] ,  [ 400 , 400 ] ] ) ,  [ [ 760 , 300 ] ,  [ 200 , 200 ] ,  [ 500 , 500 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonHull ( points ) handles points with duplicate ordinates " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " polygonHull ( points ) returns the convex hull of the specified points " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonHull ( [ [ 200 , 200 ] ,  [ 760 , 300 ] ,  [ 500 , 500 ] ] ) ,  [ [ 760 , 300 ] ,  [ 200 , 200 ] ,  [ 500 , 500 ] ] ) ;%NWL%test . deepEqual ( polygon . polygonHull ( [ [ 200 , 200 ] ,  [ 760 , 300 ] ,  [ 500 , 500 ] ,  [ 400 , 400 ] ] ) ,  [ [ 760 , 300 ] ,  [ 200 , 200 ] ,  [ 500 , 500 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonHull ( points ) handles points with duplicate ordinates " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonHull ( [ [ - 10 ,  - 10 ] ,  [ 10 , 10 ] ,  [ 10 ,  - 10 ] ,  [ - 10 , 10 ] ] ) ,  [ [ 10 , 10 ] ,  [ 10 ,  - 10 ] ,  [ - 10 ,  - 10 ] ,  [ - 10 , 10 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonHull ( points ) handles overlapping upper and lower hulls " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( polygon . polygonHull ( [ [ - 10 ,  - 10 ] ,  [ 10 , 10 ] ,  [ 10 ,  - 10 ] ,  [ - 10 , 10 ] ] ) ,  [ [ 10 , 10 ] ,  [ 10 ,  - 10 ] ,  [ - 10 ,  - 10 ] ,  [ - 10 , 10 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonHull ( points ) handles overlapping upper and lower hulls " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonHull ( [ [ 0 ,  - 10 ] ,  [ 0 , 10 ] ,  [ 0 , 0 ] ,  [ 10 , 0 ] ,  [ - 10 , 0 ] ] ) ,  [ [ 10 , 0 ] ,  [ 0 ,  - 10 ] ,  [ - 10 , 0 ] ,  [ 0 , 10 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonHull ( points ) handles various non - trivial hulls " , function ( test )  {%NWL%test . deepEqual ( polygon . polygonHull ( [ [ 60 , 20 ] ,  [ 250 , 140 ] ,  [ 180 , 170 ] ,  [ 79 , 140 ] ,  [ 50 , 60 ] ,  [ 60 , 20 ] ] ) ,  [ [ 250 , 140 ] ,  [ 60 , 20 ] ,  [ 50 , 60 ] ,  [ 79 , 140 ] ,  [ 180 , 170 ] ] ) ;%NWL%test . deepEqual ( polygon . polygonHull ( [ [ 50 , 60 ] ,  [ 60 , 20 ] ,  [ 70 , 45 ] ,  [ 100 , 70 ] ,  [ 125 , 90 ] ,  [ 200 , 113 ] ,  [ 250 , 140 ] ,  [ 180 , 170 ] ,  [ 105 , 140 ] ,  [ 79 , 140 ] ,  [ 60 , 85 ] ,  [ 50 , 60 ] ] ) ,  [ [ 250 , 140 ] ,  [ 60 , 20 ] ,  [ 50 , 60 ] ,  [ 79 , 140 ] ,  [ 180 , 170 ] ] ) ;%NWL%test . end ( ) ;%NWL%1
var tape = require ( " tape " ) ,%NWL%polygon = require ( " . . / " ) ;%NWL%tape ( " polygonLength ( polygon ) returns the expected value for closed counterclockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonLength ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ) , 4 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonLength ( polygon ) returns the expected value for closed clockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonLength ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ) , 4 ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " polygonLength ( polygon ) returns the expected value for closed counterclockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonLength ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ,  [ 0 , 0 ] ] ) , 4 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonLength ( polygon ) returns the expected value for closed clockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonLength ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ) , 4 ) ;%NWL%test . equal ( polygon . polygonLength ( [ [ 1 , 1 ] ,  [ 3 , 2 ] ,  [ 2 , 3 ] ,  [ 1 , 1 ] ] ) , Math . sqrt ( 20 )  + Math . sqrt ( 2 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonLength ( polygon ) returns the expected value for open counterclockwise polygons " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . equal ( polygon . polygonLength ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ) , 4 ) ;%NWL%test . equal ( polygon . polygonLength ( [ [ 1 , 1 ] ,  [ 3 , 2 ] ,  [ 2 , 3 ] ,  [ 1 , 1 ] ] ) , Math . sqrt ( 20 )  + Math . sqrt ( 2 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonLength ( polygon ) returns the expected value for open counterclockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonLength ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ] ) , 4 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " polygonLength ( polygon ) returns the expected value for open clockwise polygons " , function ( test )  {%NWL%test . equal ( polygon . polygonLength ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ] ) , 4 ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( q . add ( [ 1 , 0 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . add ( [ 0 , 1 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } ,  { data: [ 0 , 1 ] } ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . add ( [ 0 . 4 , 0 . 4 ] ) . root ( ) ,  [ [ { data: [ 0 , 0 ] } , , ,  { data: [ 0 . 4 , 0 . 4 ] } ] ,  { data: [ 1 , 0 ] } ,  { data: [ 0 , 1 ] } ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . add ( datum ) handles points being on the perimeter of the quadtree bounds " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . deepEqual ( q . add ( [ 0 , 0 ] ) . root ( ) ,  { data: [ 0 , 0 ] } ) ;%NWL%test . deepEqual ( q . add ( [ 1 , 1 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . add ( [ 1 , 0 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . end ( ) ;%NWL%3
tape ( " quadtree . add ( datum ) handles points being on the perimeter of the quadtree bounds " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . deepEqual ( q . add ( [ 0 , 0 ] ) . root ( ) ,  { data: [ 0 , 0 ] } ) ;%NWL%test . deepEqual ( q . add ( [ 1 , 1 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . add ( [ 1 , 0 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . add ( [ 0 , 1 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } ,  { data: [ 0 , 1 ] } ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . add ( datum ) handles points being to the top of the quadtree bounds " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( q . add ( [ 0 , 1 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } ,  { data: [ 0 , 1 ] } ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . add ( datum ) handles points being to the top of the quadtree bounds " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( q . add ( [ 1 ,  - 1 ] ) . extent ( ) ,  [ [ 0 ,  - 2 ] ,  [ 4 , 2 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . add ( datum ) handles points being to the right of the quadtree bounds " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( q . add ( [ 1 ,  - 1 ] ) . extent ( ) ,  [ [ 0 ,  - 2 ] ,  [ 4 , 2 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . add ( datum ) handles points being to the right of the quadtree bounds " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( q . add ( [ 3 , 1 ] ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . add ( datum ) handles points being to the bottom of the quadtree bounds " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( q . add ( [ 3 , 1 ] ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . add ( datum ) handles points being to the bottom of the quadtree bounds " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( q . add ( [ 1 , 3 ] ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . add ( datum ) handles points being to the left of the quadtree bounds " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . end ( ) ;%NWL%1
tape ( " quadtree . add ( datum ) handles points being to the left of the quadtree bounds " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( q . add ( [ - 1 , 1 ] ) . extent ( ) ,  [ [ - 2 , 0 ] ,  [ 2 , 4 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . add ( datum ) handles coincident points by creating a linked list " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . deepEqual ( q . add ( [ 0 , 0 ] ) . root ( ) ,  { data: [ 0 , 0 ] } ) ;%NWL%test . deepEqual ( q . add ( [ 1 , 0 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } , ,  ] ) ;%NWL%test . deepEqual ( q . add ( [ 0 , 1 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } ,  { data: [ 0 , 1 ] } ,  ] ) ;%NWL%test . end ( ) ;%NWL%3
var q = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . deepEqual ( q . add ( [ 0 , 0 ] ) . root ( ) ,  { data: [ 0 , 0 ] } ) ;%NWL%test . deepEqual ( q . add ( [ 1 , 0 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } , ,  ] ) ;%NWL%test . deepEqual ( q . add ( [ 0 , 1 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } ,  { data: [ 0 , 1 ] } ,  ] ) ;%NWL%test . deepEqual ( q . add ( [ 0 , 1 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } ,  { data: [ 0 , 1 ] , next: { data: [ 0 , 1 ] } } ,  ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . add ( datum ) implicitly defines trivial bounds for the first point " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) . add ( [ 1 , 2 ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 2 ] ,  [ 2 , 3 ] ] ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( q . add ( [ 0 , 1 ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } ,  { data: [ 1 , 0 ] } ,  { data: [ 0 , 1 ] } ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . add ( [ 0 . 4 , 0 . 4 ] ) . root ( ) ,  [ [ { data: [ 0 , 0 ] } , , ,  { data: [ 0 . 4 , 0 . 4 ] } ] ,  { data: [ 1 , 0 ] } ,  { data: [ 0 , 1 ] } ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . addAll ( data ) ignores points with NaN coordinates " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%test . deepEqual ( q . addAll ( [ [ NaN , 0 ] ,  [ 0 , NaN ] ] ) . root ( ) , undefined ) ;%NWL%test . equal ( q . extent ( ) , undefined ) ;%NWL%test . deepEqual ( q . addAll ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . addAll ( [ [ NaN , 0 ] ,  [ 0 , NaN ] ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . end ( ) ;%NWL%2
var q = d3_quadtree . quadtree ( ) ;%NWL%test . deepEqual ( q . addAll ( [ [ NaN , 0 ] ,  [ 0 , NaN ] ] ) . root ( ) , undefined ) ;%NWL%test . equal ( q . extent ( ) , undefined ) ;%NWL%test . deepEqual ( q . addAll ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . addAll ( [ [ NaN , 0 ] ,  [ 0 , NaN ] ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . addAll ( data ) correctly handles the empty array " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%test . equal ( q . extent ( ) , undefined ) ;%NWL%2
test . deepEqual ( q . addAll ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . addAll ( [ [ NaN , 0 ] ,  [ 0 , NaN ] ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . addAll ( data ) correctly handles the empty array " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%test . deepEqual ( q . addAll ( [ ] ) . root ( ) , undefined ) ;%NWL%test . equal ( q . extent ( ) , undefined ) ;%NWL%test . deepEqual ( q . addAll ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%2
test . deepEqual ( q . addAll ( [ [ NaN , 0 ] ,  [ 0 , NaN ] ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . addAll ( data ) correctly handles the empty array " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%test . deepEqual ( q . addAll ( [ ] ) . root ( ) , undefined ) ;%NWL%test . equal ( q . extent ( ) , undefined ) ;%NWL%test . deepEqual ( q . addAll ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . addAll ( [ ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . end ( ) ;%NWL%2
var q = d3_quadtree . quadtree ( ) ;%NWL%test . deepEqual ( q . addAll ( [ ] ) . root ( ) , undefined ) ;%NWL%test . equal ( q . extent ( ) , undefined ) ;%NWL%test . deepEqual ( q . addAll ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . addAll ( [ ] ) . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . addAll ( data ) computes the extent of the data before adding " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) . addAll ( [ [ 0 . 4 , 0 . 4 ] ,  [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . end ( ) ;%NWL%6
var q0 = d3_quadtree . quadtree ( ) . addAll ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . deepEqual ( q0 . copy ( ) , q0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . copy ( ) isolates changes to the extent " , function ( test )  {%NWL%var q0 = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ,%NWL%q1 = q0 . copy ( ) ;%NWL%q0 . add ( [ 2 , 2 ] ) ;%NWL%test . deepEqual ( q1 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%q1 . add ( [ - 1 ,  - 1 ] ) ;%NWL%test . end ( ) ;%NWL%2
var p0 = [ 1 , 1 ] ,%NWL%p1 = [ 2 , 2 ] ,%NWL%p2 = [ 3 , 3 ] ,%NWL%q0 = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) . addAll ( [ p0 , p1 ] ) ,%NWL%q1 = q0 . copy ( ) ;%NWL%q0 . add ( p2 ) ;%NWL%test . deepEqual ( q0 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) ;%NWL%test . deepEqual ( q0 . root ( ) ,  [ { data: [ 1 , 1 ] } , , ,  [ { data: [ 2 , 2 ] } , , ,  { data: [ 3 , 3 ] } ] ] ) ;%NWL%test . deepEqual ( q1 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) ;%NWL%test . deepEqual ( q1 . root ( ) ,  [ { data: [ 1 , 1 ] } , , ,  { data: [ 2 , 2 ] } ] ) ;%NWL%q0 . remove ( p2 ) ;%NWL%5
p1 = [ 2 , 2 ] ,%NWL%p2 = [ 3 , 3 ] ,%NWL%q0 = d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) . addAll ( [ p0 , p1 ] ) ,%NWL%q1 = q0 . copy ( ) ;%NWL%q0 . add ( p2 ) ;%NWL%test . deepEqual ( q0 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) ;%NWL%test . deepEqual ( q0 . root ( ) ,  [ { data: [ 1 , 1 ] } , , ,  [ { data: [ 2 , 2 ] } , , ,  { data: [ 3 , 3 ] } ] ] ) ;%NWL%test . deepEqual ( q1 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) ;%NWL%test . deepEqual ( q1 . root ( ) ,  [ { data: [ 1 , 1 ] } , , ,  { data: [ 2 , 2 ] } ] ) ;%NWL%q1 = q0 . copy ( ) ;%NWL%test . deepEqual ( q1 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) ;%NWL%7
var tape = require ( " tape " ) ,%NWL%d3_quadtree = require ( " . . / " ) ;%NWL%tape ( " quadtree . cover ( x , y ) sets a trivial extent if the extent was undefined " , function ( test )  {%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . cover ( 1 , 2 ) . extent ( ) ,  [ [ 1 , 2 ] ,  [ 2 , 3 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . cover ( x , y ) sets a non - trivial squarified and centered extent if the extent was trivial " , function ( test )  {%NWL%test . end ( ) ;%NWL%4
d3_quadtree = require ( " . . / " ) ;%NWL%tape ( " quadtree . cover ( x , y ) sets a trivial extent if the extent was undefined " , function ( test )  {%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . cover ( 1 , 2 ) . extent ( ) ,  [ [ 1 , 2 ] ,  [ 2 , 3 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . cover ( x , y ) sets a non - trivial squarified and centered extent if the extent was trivial " , function ( test )  {%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . cover ( 0 , 0 ) . cover ( 1 , 2 ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . cover ( x , y ) ignores invalid points " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " quadtree . data ( ) returns an array of data in the quadtree " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%test . deepEqual ( q . data ( ) ,  [ ] ) ;%NWL%q . add ( [ 0 , 0 ] ) . add ( [ 1 , 2 ] ) ;%NWL%test . deepEqual ( q . data ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 2 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . data ( ) correctly handles coincident nodes " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%q . add ( [ 0 , 0 ] ) . add ( [ 0 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%5
var tape = require ( " tape " ) ,%NWL%d3_quadtree = require ( " . . / " ) ;%NWL%tape ( " quadtree . extent ( extent ) extends the extent " , function ( test )  {%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 1 ] ,  [ 2 , 6 ] ] ) . extent ( ) ,  [ [ 0 , 1 ] ,  [ 8 , 9 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . extent ( ) can be inferred by quadtree . cover " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%test . deepEqual ( q . cover ( 0 , 0 ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . end ( ) ;%NWL%4
var q = d3_quadtree . quadtree ( ) ;%NWL%test . deepEqual ( q . cover ( 0 , 0 ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . deepEqual ( q . cover ( 2 , 4 ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . extent ( ) can be inferred by quadtree . add " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%q . add ( [ 0 , 0 ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%q . add ( [ 2 , 4 ] ) ;%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " quadtree . extent ( ) can be inferred by quadtree . add " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%q . add ( [ 0 , 0 ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%q . add ( [ 2 , 4 ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . extent ( extent ) squarifies and centers the specified extent " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 4 , 4 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . extent ( extent ) squarifies and centers the specified extent " , function ( test )  {%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 1 ] ,  [ 2 , 6 ] ] ) . extent ( ) ,  [ [ 0 , 1 ] ,  [ 8 , 9 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . extent ( extent ) ignores invalid extents " , function ( test )  {%NWL%test . equal ( d3_quadtree . quadtree ( ) . extent ( [ [ 1 , NaN ] ,  [ NaN , 0 ] ] ) . extent ( ) , undefined ) ;%NWL%test . equal ( d3_quadtree . quadtree ( ) . extent ( [ [ NaN , 1 ] ,  [ 0 , NaN ] ] ) . extent ( ) , undefined ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 1 ] ,  [ 2 , 6 ] ] ) . extent ( ) ,  [ [ 0 , 1 ] ,  [ 8 , 9 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . extent ( extent ) ignores invalid extents " , function ( test )  {%NWL%test . equal ( d3_quadtree . quadtree ( ) . extent ( [ [ 1 , NaN ] ,  [ NaN , 0 ] ] ) . extent ( ) , undefined ) ;%NWL%test . equal ( d3_quadtree . quadtree ( ) . extent ( [ [ NaN , 1 ] ,  [ 0 , NaN ] ] ) . extent ( ) , undefined ) ;%NWL%test . equal ( d3_quadtree . quadtree ( ) . extent ( [ [ NaN , NaN ] ,  [ NaN , NaN ] ] ) . extent ( ) , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . extent ( extent ) flips inverted extents " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . extent ( extent ) flips inverted extents " , function ( test )  {%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ 1 , 1 ] ,  [ 0 , 0 ] ] ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . extent ( extent ) tolerates partially - valid extents " , function ( test )  {%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ NaN , 0 ] ,  [ 1 , 1 ] ] ) . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ 0 , NaN ] ,  [ 1 , 1 ] ] ) . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ NaN , 1 ] ] ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " quadtree . extent ( extent ) tolerates partially - valid extents " , function ( test )  {%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ NaN , 0 ] ,  [ 1 , 1 ] ] ) . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ 0 , NaN ] ,  [ 1 , 1 ] ] ) . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ NaN , 1 ] ] ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 1 , NaN ] ] ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . extent ( extent ) allows trivial extents " , function ( test )  {%NWL%test . deepEqual ( d3_quadtree . quadtree ( ) . extent ( [ [ 0 , 0 ] ,  [ 0 , 0 ] ] ) . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . find ( x , y , radius ) returns the closest point within the search radius to the given [ x , y ] " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( [ [ 0 , 0 ] ,  [ 100 , 0 ] ,  [ 0 , 100 ] ,  [ 100 , 100 ] ] ) ;%NWL%test . deepEqual ( q . find ( 20 , 20 , Infinity ) ,  [ 0 , 0 ] ) ;%NWL%test . deepEqual ( q . find ( 20 , 20 , 20 * Math . SQRT2 + 1e - 6 ) ,  [ 0 , 0 ] ) ;%NWL%test . equal ( q . find ( 20 , 20 , 20 * Math . SQRT2 - 1e - 6 ) , undefined ) ;%NWL%test . deepEqual ( q . find ( 0 , 20 , 20 + 1e - 6 ) ,  [ 0 , 0 ] ) ;%NWL%test . equal ( q . find ( 0 , 20 , 20 - 1e - 6 ) , undefined ) ;%NWL%test . deepEqual ( q . find ( 20 , 0 , 20 + 1e - 6 ) ,  [ 0 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( q . find ( 20 , 20 , 20 * Math . SQRT2 - 1e - 6 ) , undefined ) ;%NWL%test . deepEqual ( q . find ( 0 , 20 , 20 + 1e - 6 ) ,  [ 0 , 0 ] ) ;%NWL%test . equal ( q . find ( 0 , 20 , 20 - 1e - 6 ) , undefined ) ;%NWL%test . deepEqual ( q . find ( 20 , 0 , 20 + 1e - 6 ) ,  [ 0 , 0 ] ) ;%NWL%test . equal ( q . find ( 20 , 0 , 20 - 1e - 6 ) , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . find ( x , y , null ) treats the given radius as Infinity " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( [ [ 0 , 0 ] ,  [ 100 , 0 ] ,  [ 0 , 100 ] ,  [ 100 , 100 ] ] ) ;%NWL%test . deepEqual ( q . find ( 20 , 20 , null ) ,  [ 0 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%5
var q = d3_quadtree . quadtree ( ) ;%NWL%test . ok ( q instanceof d3_quadtree . quadtree ) ;%NWL%test . equal ( q . visit ( function ( node , x0 , y0 , x1 , y1 )  { throw new Error; } ) , q ) ;%NWL%test . equal ( q . size ( ) , 0 ) ;%NWL%test . equal ( q . extent ( ) , undefined ) ;%NWL%test . equal ( q . root ( ) , undefined ) ;%NWL%test . deepEqual ( q . data ( ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . quadtree ( nodes ) is equivalent to d3 . quadtree ( ) . addAll ( nodes ) " , function ( test )  {%NWL%test . ok ( q instanceof d3_quadtree . quadtree ) ;%NWL%1
test . equal ( q . visit ( function ( node , x0 , y0 , x1 , y1 )  { throw new Error; } ) , q ) ;%NWL%test . equal ( q . size ( ) , 0 ) ;%NWL%test . equal ( q . extent ( ) , undefined ) ;%NWL%test . equal ( q . root ( ) , undefined ) ;%NWL%test . deepEqual ( q . data ( ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . quadtree ( nodes ) is equivalent to d3 . quadtree ( ) . addAll ( nodes ) " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . ok ( q instanceof d3_quadtree . quadtree ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( q . data ( ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . quadtree ( nodes ) is equivalent to d3 . quadtree ( ) . addAll ( nodes ) " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . ok ( q instanceof d3_quadtree . quadtree ) ;%NWL%test . deepEqual ( q . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . quadtree ( nodes , x , y ) is equivalent to d3 . quadtree ( ) . x ( x ) . y ( y ) . addAll ( nodes ) " , function ( test )  {%NWL%test . ok ( q instanceof d3_quadtree . quadtree ) ;%NWL%5
} ) ;%NWL%tape ( " d3 . quadtree ( nodes ) is equivalent to d3 . quadtree ( ) . addAll ( nodes ) " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . ok ( q instanceof d3_quadtree . quadtree ) ;%NWL%test . deepEqual ( q . root ( ) ,  [ { data: [ 0 , 0 ] } , , ,  { data: [ 1 , 1 ] } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . quadtree ( nodes , x , y ) is equivalent to d3 . quadtree ( ) . x ( x ) . y ( y ) . addAll ( nodes ) " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( [ { x: 0 , y: 0 } ,  { x: 1 , y: 1 } ] , function ( d )  { return d . x; } , function ( d )  { return d . y; } ) ;%NWL%test . ok ( q instanceof d3_quadtree . quadtree ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " quadtree . remove ( datum ) removes a point and returns the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . add ( p0 ) ;%NWL%test . deepEqual ( q . root ( ) ,  { data: p0 } ) ;%NWL%test . equal ( q . remove ( p0 ) , q ) ;%NWL%test . deepEqual ( q . root ( ) , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes the only point in the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%test . equal ( q . remove ( p0 ) , q ) ;%NWL%4
q = d3_quadtree . quadtree ( ) . add ( p0 ) ;%NWL%test . deepEqual ( q . root ( ) ,  { data: p0 } ) ;%NWL%test . equal ( q . remove ( p0 ) , q ) ;%NWL%test . deepEqual ( q . root ( ) , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes the only point in the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . add ( p0 ) ;%NWL%test . equal ( q . remove ( p0 ) , q ) ;%NWL%test . deepEqual ( q . root ( ) , undefined ) ;%NWL%3
test . equal ( q . remove ( p0 ) , q ) ;%NWL%test . deepEqual ( q . root ( ) , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes the only point in the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . add ( p0 ) ;%NWL%test . equal ( q . remove ( p0 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( q . root ( ) , undefined ) ;%NWL%test . end ( ) ;%NWL%2
q = d3_quadtree . quadtree ( ) . add ( p0 ) ;%NWL%test . equal ( q . remove ( p0 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( q . root ( ) , undefined ) ;%NWL%test . deepEqual ( p0 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes a first coincident point at the root in the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%test . equal ( q . remove ( p0 ) , q ) ;%NWL%1
test . equal ( q . remove ( p0 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( q . root ( ) , undefined ) ;%NWL%test . deepEqual ( p0 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes a first coincident point at the root in the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%1
test . deepEqual ( q . root ( ) , undefined ) ;%NWL%test . deepEqual ( p0 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes a first coincident point at the root in the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . equal ( q . remove ( p0 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( p0 ,  [ 1 , 1 ] ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes a first coincident point at the root in the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . equal ( q . remove ( p0 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . equal ( q . root ( ) . data , p1 ) ;%NWL%test . deepEqual ( p0 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( q . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . equal ( q . root ( ) . data , p1 ) ;%NWL%test . deepEqual ( p0 ,  [ 1 , 1 ] ) ;%NWL%test . deepEqual ( p1 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes another coincident point at the root in the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%0
test . deepEqual ( p0 ,  [ 1 , 1 ] ) ;%NWL%test . deepEqual ( p1 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes another coincident point at the root in the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . equal ( q . remove ( p1 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . deepEqual ( p0 ,  [ 1 , 1 ] ) ;%NWL%0
test . deepEqual ( p1 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes another coincident point at the root in the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . equal ( q . remove ( p1 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . equal ( q . root ( ) . data , p0 ) ;%NWL%test . deepEqual ( p1 ,  [ 1 , 1 ] ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes another coincident point at the root in the quadtree " , function ( test )  {%NWL%var p0 = [ 1 , 1 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . equal ( q . remove ( p1 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%test . equal ( q . root ( ) . data , p0 ) ;%NWL%test . deepEqual ( p0 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( p1 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes a non - root point in the quadtree " , function ( test )  {%NWL%var p0 = [ 0 , 0 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . equal ( q . remove ( p0 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . equal ( q . root ( ) . data , p1 ) ;%NWL%test . deepEqual ( p1 ,  [ 1 , 1 ] ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes a non - root point in the quadtree " , function ( test )  {%NWL%var p0 = [ 0 , 0 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . equal ( q . remove ( p0 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . equal ( q . root ( ) . data , p1 ) ;%NWL%test . deepEqual ( p0 ,  [ 0 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . equal ( q . root ( ) . data , p1 ) ;%NWL%test . deepEqual ( p0 ,  [ 0 , 0 ] ) ;%NWL%test . deepEqual ( p1 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes another non - root point in the quadtree " , function ( test )  {%NWL%var p0 = [ 0 , 0 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%0
test . deepEqual ( p0 ,  [ 0 , 0 ] ) ;%NWL%test . deepEqual ( p1 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes another non - root point in the quadtree " , function ( test )  {%NWL%var p0 = [ 0 , 0 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . equal ( q . remove ( p1 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . deepEqual ( p0 ,  [ 0 , 0 ] ) ;%NWL%0
test . deepEqual ( p1 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes another non - root point in the quadtree " , function ( test )  {%NWL%var p0 = [ 0 , 0 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . equal ( q . remove ( p1 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . equal ( q . root ( ) . data , p0 ) ;%NWL%test . deepEqual ( p1 ,  [ 1 , 1 ] ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) removes another non - root point in the quadtree " , function ( test )  {%NWL%var p0 = [ 0 , 0 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q = d3_quadtree . quadtree ( ) . addAll ( [ p0 , p1 ] ) ;%NWL%test . equal ( q . remove ( p1 ) , q ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . equal ( q . root ( ) . data , p0 ) ;%NWL%test . deepEqual ( p0 ,  [ 0 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( p1 ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) ignores a point not in the quadtree " , function ( test )  {%NWL%var p0 = [ 0 , 0 ] ,%NWL%p1 = [ 1 , 1 ] ,%NWL%q0 = d3_quadtree . quadtree ( ) . add ( p0 ) ,%NWL%q1 = d3_quadtree . quadtree ( ) . add ( p1 ) ;%NWL%test . equal ( q0 . remove ( p1 ) , q0 ) ;%NWL%test . deepEqual ( q0 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . end ( ) ;%NWL%1
q1 = d3_quadtree . quadtree ( ) . add ( p1 ) ;%NWL%test . equal ( q0 . remove ( p1 ) , q0 ) ;%NWL%test . deepEqual ( q0 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . equal ( q0 . root ( ) . data , p0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) ignores a coincident point not in the quadtree " , function ( test )  {%NWL%var p0 = [ 0 , 0 ] ,%NWL%p1 = [ 0 , 0 ] ,%NWL%q0 = d3_quadtree . quadtree ( ) . add ( p0 ) ,%NWL%test . equal ( q0 . remove ( p1 ) , q0 ) ;%NWL%1
test . equal ( q0 . remove ( p1 ) , q0 ) ;%NWL%test . deepEqual ( q0 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . equal ( q0 . root ( ) . data , p0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) ignores a coincident point not in the quadtree " , function ( test )  {%NWL%var p0 = [ 0 , 0 ] ,%NWL%p1 = [ 0 , 0 ] ,%NWL%q0 = d3_quadtree . quadtree ( ) . add ( p0 ) ,%NWL%q1 = d3_quadtree . quadtree ( ) . add ( p1 ) ;%NWL%test . deepEqual ( q0 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%1
test . deepEqual ( q0 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . equal ( q0 . root ( ) . data , p0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) ignores a coincident point not in the quadtree " , function ( test )  {%NWL%var p0 = [ 0 , 0 ] ,%NWL%p1 = [ 0 , 0 ] ,%NWL%q0 = d3_quadtree . quadtree ( ) . add ( p0 ) ,%NWL%q1 = d3_quadtree . quadtree ( ) . add ( p1 ) ;%NWL%test . equal ( q0 . remove ( p1 ) , q0 ) ;%NWL%test . equal ( q0 . root ( ) . data , p0 ) ;%NWL%1
test . equal ( q0 . root ( ) . data , p0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . remove ( datum ) ignores a coincident point not in the quadtree " , function ( test )  {%NWL%var p0 = [ 0 , 0 ] ,%NWL%p1 = [ 0 , 0 ] ,%NWL%q0 = d3_quadtree . quadtree ( ) . add ( p0 ) ,%NWL%q1 = d3_quadtree . quadtree ( ) . add ( p1 ) ;%NWL%test . equal ( q0 . remove ( p1 ) , q0 ) ;%NWL%test . deepEqual ( q0 . extent ( ) ,  [ [ 0 , 0 ] ,  [ 1 , 1 ] ] ) ;%NWL%test . end ( ) ;%NWL%1
d3_quadtree = require ( " . . / " ) ;%NWL%tape ( " quadtree . size ( ) returns the number of points in the quadtree " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%test . equal ( q . size ( ) , 0 ) ;%NWL%q . add ( [ 0 , 0 ] ) . add ( [ 1 , 2 ] ) ;%NWL%test . equal ( q . size ( ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . size ( ) correctly counts coincident nodes " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%test . equal ( q . size ( ) , 2 ) ;%NWL%5
tape ( " quadtree . size ( ) returns the number of points in the quadtree " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%test . equal ( q . size ( ) , 0 ) ;%NWL%q . add ( [ 0 , 0 ] ) . add ( [ 1 , 2 ] ) ;%NWL%test . equal ( q . size ( ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . size ( ) correctly counts coincident nodes " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) ;%NWL%q . add ( [ 0 , 0 ] ) . add ( [ 0 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( results ,  [%NWL%[  0 ,  0 , 1024 , 1024 ] ,%NWL%[  0 ,  0 , 512 , 512 ] ,%NWL%[ 512 , 512 , 1024 , 1024 ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . visit ( callback ) on an empty quadtree with no bounds does nothing " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) ;%NWL%test . equal ( q . visit ( function ( node , x0 , y0 , x1 , y1 )  { results . push ( [ x0 , y0 , x1 , y1 ] ) ; } ) , q ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " quadtree . visit ( callback ) on an empty quadtree with no bounds does nothing " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) ;%NWL%test . equal ( q . visit ( function ( node , x0 , y0 , x1 , y1 )  { results . push ( [ x0 , y0 , x1 , y1 ] ) ; } ) , q ) ;%NWL%test . equal ( results . length , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . visit ( callback ) on an empty quadtree with bounds does nothing " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( )%NWL%. extent ( [ [ 0 , 0 ] ,  [ 960 , 960 ] ] ) ;%NWL%test . deepEqual ( results . length , 0 ) ;%NWL%4
tape ( " quadtree . visit ( callback ) on an empty quadtree with no bounds does nothing " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( ) ;%NWL%test . equal ( q . visit ( function ( node , x0 , y0 , x1 , y1 )  { results . push ( [ x0 , y0 , x1 , y1 ] ) ; } ) , q ) ;%NWL%test . equal ( results . length , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . visit ( callback ) on an empty quadtree with bounds does nothing " , function ( test )  {%NWL%var results = [ ] , q = d3_quadtree . quadtree ( )%NWL%. extent ( [ [ 0 , 0 ] ,  [ 960 , 960 ] ] ) ;%NWL%test . equal ( q . visit ( function ( node , x0 , y0 , x1 , y1 )  { results . push ( [ x0 , y0 , x1 , y1 ] ) ; } ) , q ) ;%NWL%test . end ( ) ;%NWL%4
var tape = require ( " tape " ) ,%NWL%d3_quadtree = require ( " . . / " ) ;%NWL%tape ( " quadtree . x ( x ) sets the x - accessor used by quadtree . add " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) . x ( x ) . add ( { x: 1 , 1: 2 } ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 2 ] ,  [ 2 , 3 ] ] ) ;%NWL%test . deepEqual ( q . root ( ) ,  { data: { x: 1 , 1: 2 } } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . x ( x ) sets the x - accessor used by quadtree . addAll " , function ( test )  {%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 2 ] ,  [ 2 , 3 ] ] ) ;%NWL%4
d3_quadtree = require ( " . . / " ) ;%NWL%tape ( " quadtree . x ( x ) sets the x - accessor used by quadtree . add " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) . x ( x ) . add ( { x: 1 , 1: 2 } ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 2 ] ,  [ 2 , 3 ] ] ) ;%NWL%test . deepEqual ( q . root ( ) ,  { data: { x: 1 , 1: 2 } } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . x ( x ) sets the x - accessor used by quadtree . addAll " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) . x ( x ) . addAll ( [ { x: 1 , 1: 2 } ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 2 ] ,  [ 2 , 3 ] ] ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( q . root ( ) ,  { data: { x: 1 , 1: 2 } } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . x ( x ) sets the x - accessor used by quadtree . remove " , function ( test )  {%NWL%var p0 = { x: 0 , 1: 1 } ,%NWL%p1 = { x: 1 , 1: 2 } ,%NWL%q = d3_quadtree . quadtree ( ) . x ( x ) ;%NWL%test . deepEqual ( q . add ( p0 ) . root ( ) ,  { data: { x: 0 , 1: 1 } } ) ;%NWL%test . deepEqual ( q . add ( p1 ) . root ( ) ,  [ { data: { x: 0 , 1: 1 } } , , ,  { data: { x: 1 , 1: 2 } } ] ) ;%NWL%test . deepEqual ( q . remove ( p1 ) . root ( ) ,  { data: { x: 0 , 1: 1 } } ) ;%NWL%test . end ( ) ;%NWL%1
var tape = require ( " tape " ) ,%NWL%d3_quadtree = require ( " . . / " ) ;%NWL%tape ( " quadtree . y ( y ) sets the y - accessor used by quadtree . add " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) . y ( y ) . add ( { 0: 1 , y: 2 } ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 2 ] ,  [ 2 , 3 ] ] ) ;%NWL%test . deepEqual ( q . root ( ) ,  { data: { 0: 1 , y: 2 } } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . y ( y ) sets the y - accessor used by quadtree . addAll " , function ( test )  {%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 2 ] ,  [ 2 , 3 ] ] ) ;%NWL%4
d3_quadtree = require ( " . . / " ) ;%NWL%tape ( " quadtree . y ( y ) sets the y - accessor used by quadtree . add " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) . y ( y ) . add ( { 0: 1 , y: 2 } ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 2 ] ,  [ 2 , 3 ] ] ) ;%NWL%test . deepEqual ( q . root ( ) ,  { data: { 0: 1 , y: 2 } } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . y ( y ) sets the y - accessor used by quadtree . addAll " , function ( test )  {%NWL%var q = d3_quadtree . quadtree ( ) . y ( y ) . addAll ( [ { 0: 1 , y: 2 } ] ) ;%NWL%test . deepEqual ( q . extent ( ) ,  [ [ 1 , 2 ] ,  [ 2 , 3 ] ] ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( q . root ( ) ,  { data: { 0: 1 , y: 2 } } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quadtree . y ( y ) sets the y - accessor used by quadtree . remove " , function ( test )  {%NWL%var p0 = { 0: 0 , y: 1 } ,%NWL%p1 = { 0: 1 , y: 2 } ,%NWL%q = d3_quadtree . quadtree ( ) . y ( y ) ;%NWL%test . deepEqual ( q . add ( p0 ) . root ( ) ,  { data: { 0: 0 , y: 1 } } ) ;%NWL%test . deepEqual ( q . add ( p1 ) . root ( ) ,  [ { data: { 0: 0 , y: 1 } } , , ,  { data: { 0: 1 , y: 2 } } ] ) ;%NWL%test . deepEqual ( q . remove ( p1 ) . root ( ) ,  { data: { 0: 0 , y: 1 } } ) ;%NWL%test . end ( ) ;%NWL%1
}%NWL%} )%NWL%var arrayProto = {%NWL%contains: function ( item )  {%NWL%return ~ this . indexOf ( item )%NWL%} ,%NWL%prepend: function ( )  {%NWL%this . unshift . apply ( this , arguments )%NWL%return this%NWL%}%NWL%this . push . apply ( this , arguments )%NWL%7
var tape = require ( " tape " ) ,%NWL%seedrandom = require ( " seedrandom " ) ,%NWL%d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ,%NWL%skewness = require ( " . / skewness " ) ,%NWL%kurtosis = require ( " . / kurtosis " ) ;%NWL%require ( " . / inDelta " ) ;%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " f330fbece4c1c99f " ) ) ;%NWL%0
d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ,%NWL%skewness = require ( " . / skewness " ) ,%NWL%kurtosis = require ( " . / kurtosis " ) ;%NWL%require ( " . / inDelta " ) ;%NWL%tape . test ( " d3 . randomBates ( n ) returns random numbers with a mean of one - half " , function ( test )  {%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " f330fbece4c1c99f " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomBates ( 1 ) ) ) , 0 . 5 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomBates ( 10 ) ) ) , 0 . 5 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " c4af5ee918417093 " ) ) ;%NWL%5
require ( " . / inDelta " ) ;%NWL%tape . test ( " d3 . randomBates ( n ) returns random numbers with a mean of one - half " , function ( test )  {%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " f330fbece4c1c99f " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomBates ( 1 ) ) ) , 0 . 5 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomBates ( 10 ) ) ) , 0 . 5 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomBates ( n ) returns random numbers with a variance of 1 /  ( 12 * n ) " , function ( test )  {%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " c4af5ee918417093 " ) ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomBates ( 1 ) ) ) , 1 / 12 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%5
test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomBates ( 1 ) ) ) , 0 . 5 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomBates ( 10 ) ) ) , 0 . 5 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomBates ( n ) returns random numbers with a variance of 1 /  ( 12 * n ) " , function ( test )  {%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " c4af5ee918417093 " ) ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomBates ( 1 ) ) ) , 1 / 12 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomBates ( 10 ) ) ) , 1 / 120 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " bb0bb470f346ff65 " ) ) ;%NWL%5
} ) ;%NWL%tape . test ( " d3 . randomBates ( n ) returns random numbers with a variance of 1 /  ( 12 * n ) " , function ( test )  {%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " c4af5ee918417093 " ) ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomBates ( 1 ) ) ) , 1 / 12 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomBates ( 10 ) ) ) , 1 / 120 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomBates ( n ) returns random numbers with a skewness of 0 " , function ( test )  {%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " bb0bb470f346ff65 " ) ) ;%NWL%test . inDelta ( skewness ( d3 . range ( 10000 ) . map ( randomBates ( 1 ) ) ) , 0 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%5
test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomBates ( 1 ) ) ) , 1 / 12 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomBates ( 10 ) ) ) , 1 / 120 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomBates ( n ) returns random numbers with a skewness of 0 " , function ( test )  {%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " bb0bb470f346ff65 " ) ) ;%NWL%test . inDelta ( skewness ( d3 . range ( 10000 ) . map ( randomBates ( 1 ) ) ) , 0 , 0 . 05 ) ;%NWL%test . inDelta ( skewness ( d3 . range ( 10000 ) . map ( randomBates ( 10 ) ) ) , 0 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " 3c21f0c8f5a8332c " ) ) ;%NWL%5
} ) ;%NWL%tape . test ( " d3 . randomBates ( n ) returns random numbers with a skewness of 0 " , function ( test )  {%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " bb0bb470f346ff65 " ) ) ;%NWL%test . inDelta ( skewness ( d3 . range ( 10000 ) . map ( randomBates ( 1 ) ) ) , 0 , 0 . 05 ) ;%NWL%test . inDelta ( skewness ( d3 . range ( 10000 ) . map ( randomBates ( 10 ) ) ) , 0 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomBates ( n ) returns random numbers with a kurtosis of - 6 /  ( 5 * n ) " , function ( test )  {%NWL%var randomBates = d3 . randomBates . source ( seedrandom ( " 3c21f0c8f5a8332c " ) ) ;%NWL%test . inDelta ( kurtosis ( d3 . range ( 10000 ) . map ( randomBates ( 1 ) ) ) ,  - 6 / 5 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%5
var tape = require ( " tape " ) ,%NWL%seedrandom = require ( " seedrandom " ) ,%NWL%d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ;%NWL%require ( " . / inDelta " ) ;%NWL%var randomExponential = d3 . randomExponential . source ( seedrandom ( " d5cb594f444fc692 " ) ) ;%NWL%0
var tape = require ( " tape " ) ,%NWL%seedrandom = require ( " seedrandom " ) ,%NWL%d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ,%NWL%skewness = require ( " . / skewness " ) ,%NWL%kurtosis = require ( " . / kurtosis " ) ;%NWL%require ( " . / inDelta " ) ;%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " f330fbece4c1c99f " ) ) ;%NWL%0
d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ,%NWL%skewness = require ( " . / skewness " ) ,%NWL%kurtosis = require ( " . / kurtosis " ) ;%NWL%require ( " . / inDelta " ) ;%NWL%tape . test ( " d3 . randomIrwinHall ( n ) returns random numbers with a mean of n / 2 " , function ( test )  {%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " f330fbece4c1c99f " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 1 ) ) ) , 1 / 2 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 10 ) ) ) , 10 / 2 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " c4af5ee918417093 " ) ) ;%NWL%5
require ( " . / inDelta " ) ;%NWL%tape . test ( " d3 . randomIrwinHall ( n ) returns random numbers with a mean of n / 2 " , function ( test )  {%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " f330fbece4c1c99f " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 1 ) ) ) , 1 / 2 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 10 ) ) ) , 10 / 2 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomIrwinHall ( n ) returns random numbers with a variance of n / 12 " , function ( test )  {%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " c4af5ee918417093 " ) ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 1 ) ) ) , 1 / 12 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%5
test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 1 ) ) ) , 1 / 2 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 10 ) ) ) , 10 / 2 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomIrwinHall ( n ) returns random numbers with a variance of n / 12 " , function ( test )  {%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " c4af5ee918417093 " ) ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 1 ) ) ) , 1 / 12 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 10 ) ) ) , 10 / 12 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " bb0bb470f346ff65 " ) ) ;%NWL%5
} ) ;%NWL%tape . test ( " d3 . randomIrwinHall ( n ) returns random numbers with a variance of n / 12 " , function ( test )  {%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " c4af5ee918417093 " ) ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 1 ) ) ) , 1 / 12 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 10 ) ) ) , 10 / 12 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomIrwinHall ( n ) returns random numbers with a skewness of 0 " , function ( test )  {%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " bb0bb470f346ff65 " ) ) ;%NWL%test . inDelta ( skewness ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 1 ) ) ) , 0 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%5
test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 1 ) ) ) , 1 / 12 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . variance ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 10 ) ) ) , 10 / 12 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomIrwinHall ( n ) returns random numbers with a skewness of 0 " , function ( test )  {%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " bb0bb470f346ff65 " ) ) ;%NWL%test . inDelta ( skewness ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 1 ) ) ) , 0 , 0 . 05 ) ;%NWL%test . inDelta ( skewness ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 10 ) ) ) , 0 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " 3c21f0c8f5a8332c " ) ) ;%NWL%5
} ) ;%NWL%tape . test ( " d3 . randomIrwinHall ( n ) returns random numbers with a skewness of 0 " , function ( test )  {%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " bb0bb470f346ff65 " ) ) ;%NWL%test . inDelta ( skewness ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 1 ) ) ) , 0 , 0 . 05 ) ;%NWL%test . inDelta ( skewness ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 10 ) ) ) , 0 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomIrwinHall ( n ) returns random numbers with a kurtosis of - 6 /  ( 5 * n ) " , function ( test )  {%NWL%var randomIrwinHall = d3 . randomIrwinHall . source ( seedrandom ( " 3c21f0c8f5a8332c " ) ) ;%NWL%test . inDelta ( kurtosis ( d3 . range ( 10000 ) . map ( randomIrwinHall ( 1 ) ) ) ,  - 6 / 5 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%5
var d3 = require ( " d3 - array " ) ;%NWL%var mean = d3 . mean ( numbers ) ,%NWL%0
var tape = require ( " tape " ) ,%NWL%seedrandom = require ( " seedrandom " ) ,%NWL%d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ;%NWL%require ( " . / inDelta " ) ;%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " a22ebc7c488a3a47 " ) ) ;%NWL%0
var tape = require ( " tape " ) ,%NWL%seedrandom = require ( " seedrandom " ) ,%NWL%d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ;%NWL%require ( " . / inDelta " ) ;%NWL%tape . test ( " d3 . randomLogNormal ( ) returns random numbers with a log - mean of zero " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " a22ebc7c488a3a47 " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( ) ) , Math . log ) , 0 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " 06fd26b46c25607e " ) ) ;%NWL%0
seedrandom = require ( " seedrandom " ) ,%NWL%d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ;%NWL%require ( " . / inDelta " ) ;%NWL%tape . test ( " d3 . randomLogNormal ( ) returns random numbers with a log - mean of zero " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " a22ebc7c488a3a47 " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( ) ) , Math . log ) , 0 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomLogNormal ( ) returns random numbers with a log - standard deviation of one " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " 06fd26b46c25607e " ) ) ;%NWL%test . end ( ) ;%NWL%6
tape . test ( " d3 . randomLogNormal ( ) returns random numbers with a log - mean of zero " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " a22ebc7c488a3a47 " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( ) ) , Math . log ) , 0 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomLogNormal ( ) returns random numbers with a log - standard deviation of one " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " 06fd26b46c25607e " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomLogNormal ( ) ) , Math . log ) , 1 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " fffe77600db5c1ad " ) ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomLogNormal ( ) returns random numbers with a log - standard deviation of one " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " 06fd26b46c25607e " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomLogNormal ( ) ) , Math . log ) , 1 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomLogNormal ( mu ) returns random numbers with the specified log - mean " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " fffe77600db5c1ad " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( 42 ) ) , Math . log ) , 42 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%0
var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " 06fd26b46c25607e " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomLogNormal ( ) ) , Math . log ) , 1 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomLogNormal ( mu ) returns random numbers with the specified log - mean " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " fffe77600db5c1ad " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( 42 ) ) , Math . log ) , 42 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( - 2 ) ) , Math . log ) ,  - 2 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " 9caf2156de45315a " ) ) ;%NWL%0
} ) ;%NWL%tape . test ( " d3 . randomLogNormal ( mu ) returns random numbers with the specified log - mean " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " fffe77600db5c1ad " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( 42 ) ) , Math . log ) , 42 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( - 2 ) ) , Math . log ) ,  - 2 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomLogNormal ( mu ) returns random numbers with a log - standard deviation of 1 " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " 9caf2156de45315a " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomLogNormal ( 42 ) ) , Math . log ) , 1 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%5
test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( 42 ) ) , Math . log ) , 42 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( - 2 ) ) , Math . log ) ,  - 2 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomLogNormal ( mu ) returns random numbers with a log - standard deviation of 1 " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " 9caf2156de45315a " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomLogNormal ( 42 ) ) , Math . log ) , 1 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomLogNormal ( - 2 ) ) , Math . log ) , 1 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " c0d761f591fb5e43 " ) ) ;%NWL%5
var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " 9caf2156de45315a " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomLogNormal ( 42 ) ) , Math . log ) , 1 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomLogNormal ( - 2 ) ) , Math . log ) , 1 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " d3 . randomLogNormal ( mu , sigma ) returns random numbers with the specified log - mean and log - standard deviation " , function ( test )  {%NWL%var randomLogNormal = d3 . randomLogNormal . source ( seedrandom ( " c0d761f591fb5e43 " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( 42 , 2 ) ) , Math . log ) , 42 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomLogNormal ( - 2 , 2 ) ) , Math . log ) ,  - 2 , 0 . 05 ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomLogNormal ( 42 , 2 ) ) , Math . log ) , 2 , 0 . 05 ) ;%NWL%test . end ( ) ;%NWL%3
var tape = require ( " tape " ) ,%NWL%seedrandom = require ( " seedrandom " ) ,%NWL%d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ;%NWL%require ( " . / inDelta " ) ;%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " a22ebc7c488a3a47 " ) ) ;%NWL%0
var tape = require ( " tape " ) ,%NWL%seedrandom = require ( " seedrandom " ) ,%NWL%d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ;%NWL%require ( " . / inDelta " ) ;%NWL%tape . test ( " randomNormal ( ) returns random numbers with a mean of zero " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " a22ebc7c488a3a47 " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( ) ) ) , 0 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " 06fd26b46c25607e " ) ) ;%NWL%0
seedrandom = require ( " seedrandom " ) ,%NWL%d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ;%NWL%require ( " . / inDelta " ) ;%NWL%tape . test ( " randomNormal ( ) returns random numbers with a mean of zero " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " a22ebc7c488a3a47 " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( ) ) ) , 0 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomNormal ( ) returns random numbers with a standard deviation of one " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " 06fd26b46c25607e " ) ) ;%NWL%test . end ( ) ;%NWL%6
tape . test ( " randomNormal ( ) returns random numbers with a mean of zero " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " a22ebc7c488a3a47 " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( ) ) ) , 0 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomNormal ( ) returns random numbers with a standard deviation of one " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " 06fd26b46c25607e " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomNormal ( ) ) ) , 1 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " fffe77600db5c1ad " ) ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomNormal ( ) returns random numbers with a standard deviation of one " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " 06fd26b46c25607e " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomNormal ( ) ) ) , 1 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomNormal ( mu ) returns random numbers with the specified mean " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " fffe77600db5c1ad " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( 42 ) ) ) , 42 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%0
var randomNormal = d3 . randomNormal . source ( seedrandom ( " 06fd26b46c25607e " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomNormal ( ) ) ) , 1 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomNormal ( mu ) returns random numbers with the specified mean " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " fffe77600db5c1ad " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( 42 ) ) ) , 42 ,  . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( - 2 ) ) ) ,  - 2 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " 9caf2156de45315a " ) ) ;%NWL%0
} ) ;%NWL%tape . test ( " randomNormal ( mu ) returns random numbers with the specified mean " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " fffe77600db5c1ad " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( 42 ) ) ) , 42 ,  . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( - 2 ) ) ) ,  - 2 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomNormal ( mu ) returns random numbers with a standard deviation of 1 " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " 9caf2156de45315a " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomNormal ( 42 ) ) ) , 1 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%5
test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( 42 ) ) ) , 42 ,  . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( - 2 ) ) ) ,  - 2 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomNormal ( mu ) returns random numbers with a standard deviation of 1 " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " 9caf2156de45315a " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomNormal ( 42 ) ) ) , 1 ,  . 05 ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomNormal ( - 2 ) ) ) , 1 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " c0d761f591fb5e43 " ) ) ;%NWL%5
var randomNormal = d3 . randomNormal . source ( seedrandom ( " 9caf2156de45315a " ) ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomNormal ( 42 ) ) ) , 1 ,  . 05 ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomNormal ( - 2 ) ) ) , 1 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomNormal ( mu , sigma ) returns random numbers with the specified mean and standard deviation " , function ( test )  {%NWL%var randomNormal = d3 . randomNormal . source ( seedrandom ( " c0d761f591fb5e43 " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( 42 , 2 ) ) ) , 42 ,  . 05 ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomNormal ( - 2 , 2 ) ) ) ,  - 2 ,  . 05 ) ;%NWL%test . inDelta ( d3 . deviation ( d3 . range ( 10000 ) . map ( randomNormal ( 42 , 2 ) ) ) , 2 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%3
var d3 = require ( " d3 - array " ) ;%NWL%var mean = d3 . mean ( numbers ) ,%NWL%0
var tape = require ( " tape " ) ,%NWL%seedrandom = require ( " seedrandom " ) ,%NWL%d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ;%NWL%require ( " . / inDelta " ) ;%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " d7bcbccaa96bba8c " ) ) ;%NWL%0
var tape = require ( " tape " ) ,%NWL%seedrandom = require ( " seedrandom " ) ,%NWL%d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ;%NWL%require ( " . / inDelta " ) ;%NWL%tape . test ( " randomUniform ( ) returns random numbers with a mean of 0 . 5 " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " d7bcbccaa96bba8c " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomUniform ( ) ) ) , 0 . 5 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " f232de9b208a7137 " ) ) ;%NWL%0
d3 = Object . assign ( { } , require ( " . . / " ) , require ( " d3 - array " ) ) ;%NWL%require ( " . / inDelta " ) ;%NWL%tape . test ( " randomUniform ( ) returns random numbers with a mean of 0 . 5 " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " d7bcbccaa96bba8c " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomUniform ( ) ) ) , 0 . 5 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( ) returns random numbers within the range [ 0 , 1 ) " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " f232de9b208a7137 " ) ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( ) ) ) >= 0 ) ;%NWL%test . end ( ) ;%NWL%5
var randomUniform = d3 . randomUniform . source ( seedrandom ( " d7bcbccaa96bba8c " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomUniform ( ) ) ) , 0 . 5 ,  . 05 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( ) returns random numbers within the range [ 0 , 1 ) " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " f232de9b208a7137 " ) ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( ) ) ) >= 0 ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( ) ) ) < 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " c52f4e6cd112aada " ) ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( ) returns random numbers within the range [ 0 , 1 ) " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " f232de9b208a7137 " ) ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( ) ) ) >= 0 ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( ) ) ) < 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( max ) returns random numbers with a mean of max / 2 " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " c52f4e6cd112aada " ) ) ;%NWL%test . end ( ) ;%NWL%0
var randomUniform = d3 . randomUniform . source ( seedrandom ( " f232de9b208a7137 " ) ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( ) ) ) >= 0 ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( ) ) ) < 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( max ) returns random numbers with a mean of max / 2 " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " c52f4e6cd112aada " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomUniform ( 42 ) ) ) , 21 ,  . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " 8f2959eba39debfd " ) ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( max ) returns random numbers with a mean of max / 2 " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " c52f4e6cd112aada " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomUniform ( 42 ) ) ) , 21 ,  . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( max ) returns random numbers within the range [ 0 , max ) " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " 8f2959eba39debfd " ) ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( 42 ) ) ) >= 0 ) ;%NWL%test . end ( ) ;%NWL%0
var randomUniform = d3 . randomUniform . source ( seedrandom ( " c52f4e6cd112aada " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomUniform ( 42 ) ) ) , 21 ,  . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( max ) returns random numbers within the range [ 0 , max ) " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " 8f2959eba39debfd " ) ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( 42 ) ) ) >= 0 ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( 42 ) ) ) < 42 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " 5ea383210c9bdd21 " ) ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( max ) returns random numbers within the range [ 0 , max ) " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " 8f2959eba39debfd " ) ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( 42 ) ) ) >= 0 ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( 42 ) ) ) < 42 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( min , max ) returns random numbers with a mean of ( min + max )  / 2 " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " 5ea383210c9bdd21 " ) ) ;%NWL%test . end ( ) ;%NWL%0
var randomUniform = d3 . randomUniform . source ( seedrandom ( " 8f2959eba39debfd " ) ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( 42 ) ) ) >= 0 ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( 42 ) ) ) < 42 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( min , max ) returns random numbers with a mean of ( min + max )  / 2 " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " 5ea383210c9bdd21 " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomUniform ( 10 , 42 ) ) ) , 26 ,  . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " 88f461e6b7454981 " ) ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( min , max ) returns random numbers with a mean of ( min + max )  / 2 " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " 5ea383210c9bdd21 " ) ) ;%NWL%test . inDelta ( d3 . mean ( d3 . range ( 10000 ) . map ( randomUniform ( 10 , 42 ) ) ) , 26 ,  . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape . test ( " randomUniform ( min , max ) returns random numbers within the range [ min , max ) " , function ( test )  {%NWL%var randomUniform = d3 . randomUniform . source ( seedrandom ( " 88f461e6b7454981 " ) ) ;%NWL%test . ok ( d3 . min ( d3 . range ( 10000 ) . map ( randomUniform ( 10 , 42 ) ) ) >= 10 ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( XMLHttpRequest . _last . _info . url ,  " test / data / sample . csv " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / csv " ) ;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " csv ( url , callback ) is an alias csv ( url ) . get ( callback ) " , function ( test )  {%NWL%request . csv ( " test / data / sample . csv " ) . get ( function ( error , data )  {%NWL%test . equal ( XMLHttpRequest . _last . _info . url ,  " test / data / sample . csv " ) ;%NWL%0
test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / csv " ) ;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " csv ( url , callback ) is an alias csv ( url ) . get ( callback ) " , function ( test )  {%NWL%request . csv ( " test / data / sample . csv " ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%0
test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / csv " ) ;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " csv ( url , callback ) is an alias csv ( url ) . get ( callback ) " , function ( test )  {%NWL%request . csv ( " test / data / sample . csv " ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . equal ( XMLHttpRequest . _last . _info . url ,  " test / data / sample . csv " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%0
test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / csv " ) ;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " csv ( url , callback ) is an alias csv ( url ) . get ( callback ) " , function ( test )  {%NWL%request . csv ( " test / data / sample . csv " ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . equal ( XMLHttpRequest . _last . _info . url ,  " test / data / sample . csv " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / csv " ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " csv ( url , callback ) is an alias csv ( url ) . get ( callback ) " , function ( test )  {%NWL%request . csv ( " test / data / sample . csv " ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . equal ( XMLHttpRequest . _last . _info . url ,  " test / data / sample . csv " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / csv " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / csv " ) ;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " csv ( url , row , callback ) observes the specified row conversion function " , function ( test )  {%NWL%request . csv ( " test / data / sample . csv " , function ( d )  { d . Hello = - d . Hello; return d; } , function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . end ( ) ;%NWL%4
tape ( " csv ( url , row , callback ) observes the specified row conversion function " , function ( test )  {%NWL%request . csv ( " test / data / sample . csv " , function ( d )  { d . Hello = - d . Hello; return d; } , function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . deepEqual ( data , table ( [ { Hello: - 42 , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " csv ( url , row , callback ) is an alias for csv ( url ) . row ( row ) . get ( callback ) " , function ( test )  {%NWL%request . csv ( " test / data / sample . csv " ) . row ( function ( d )  { d . Hello = - d . Hello; return d; } ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . end ( ) ;%NWL%4
request . csv ( " test / data / sample . csv " ) . row ( function ( d )  { d . Hello = - d . Hello; return d; } ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . deepEqual ( data , table ( [ { Hello: - 42 , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " csv ( url ) . mimeType ( type ) . get ( callback ) observes the specified mime type " , function ( test )  {%NWL%request . csv ( " test / data / sample . csv " ) . mimeType ( " text / plain " ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%3
test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " application / json " ) ;%NWL%test . equal ( XMLHttpRequest . _last . readyState , 4 ) ;%NWL%test . equal ( XMLHttpRequest . _last . status , 200 ) ;%NWL%test . deepEqual ( json ,  { message: " Hello , world! " } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " json ( url , callback ) returns an error when given invalid JSON " , function ( test )  {%NWL%request . json ( " test / data / sample . tsv " , function ( error , json )  {%NWL%test . end ( ) ;%NWL%5
test . equal ( XMLHttpRequest . _last . readyState , 4 ) ;%NWL%test . equal ( XMLHttpRequest . _last . status , 200 ) ;%NWL%test . deepEqual ( json ,  { message: " Hello , world! " } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " json ( url ) . mimeType ( type ) . get ( callback ) observes the specified mime type " , function ( test )  {%NWL%request . json ( " test / data / sample . json " ) . mimeType ( " applicatin / json + test " ) . get ( function ( error , json )  {%NWL%if ( error ) throw error;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " applicatin / json + test " ) ;%NWL%test . end ( ) ;%NWL%3
var input_pos_match = [ 2 , 1 , 2 , 0 , 1 . 5 ] ;%NWL%var input_neg_match = [ - 2 ,  - 1 ,  - 2 , 0 ,  - 1 . 5 ] ;%NWL%var input_no_match_alt = [ 2 , 1 ,  - 2 , 0 , 1 . 5 ] ;%NWL%var input_no_match_mag = [ 0 . 5 , 1 , 0 . 5 , 4 , 0 ] ;%NWL%tape ( ' rule_6 marks positive trend ' , function ( test )  {%NWL%var result = rule_6 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_6 marks negative trend ' , function ( test )  {%NWL%test . ok ( result ) ;%NWL%6
var input_neg_match = [ - 2 ,  - 1 ,  - 2 , 0 ,  - 1 . 5 ] ;%NWL%var input_no_match_alt = [ 2 , 1 ,  - 2 , 0 , 1 . 5 ] ;%NWL%var input_no_match_mag = [ 0 . 5 , 1 , 0 . 5 , 4 , 0 ] ;%NWL%tape ( ' rule_6 marks positive trend ' , function ( test )  {%NWL%var result = rule_6 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_6 marks negative trend ' , function ( test )  {%NWL%var result = rule_6 ( input_neg_match , mean , std ) ;%NWL%test . end ( ) ;%NWL%6
} ) ;%NWL%tape ( ' rule_6 marks negative trend ' , function ( test )  {%NWL%var result = rule_6 ( input_neg_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_6 does not mark no variance ' , function ( test )  {%NWL%var resultAlt = rule_6 ( input_no_match_alt , mean , std ) ;%NWL%test . notOk ( resultAlt ) ;%NWL%var resultMag = rule_6 ( input_no_match_mag , mean , std ) ;%NWL%test . end ( ) ;%NWL%4
test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / plain " ) ;%NWL%test . equal ( XMLHttpRequest . _last . readyState , 4 ) ;%NWL%test . equal ( XMLHttpRequest . _last . status , 200 ) ;%NWL%test . equal ( text ,  " Hello , world!\n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " text ( url ) . mimeType ( type ) . get ( callback ) observes the specified mime type " , function ( test )  {%NWL%request . text ( " test / data / sample . txt " ) . mimeType ( " text / plain + special " ) . get ( function ( error , text )  {%NWL%if ( error ) throw error;%NWL%test . equal ( text ,  " Hello , world!\n " ) ;%NWL%3
test . equal ( XMLHttpRequest . _last . readyState , 4 ) ;%NWL%test . equal ( XMLHttpRequest . _last . status , 200 ) ;%NWL%test . equal ( text ,  " Hello , world!\n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " text ( url ) . mimeType ( type ) . get ( callback ) observes the specified mime type " , function ( test )  {%NWL%request . text ( " test / data / sample . txt " ) . mimeType ( " text / plain + special " ) . get ( function ( error , text )  {%NWL%if ( error ) throw error;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / plain + special " ) ;%NWL%test . end ( ) ;%NWL%3
test . equal ( XMLHttpRequest . _last . _info . url ,  " test / data / sample . tsv " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / tab - separated - values " ) ;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " tsv ( url , callback ) is an alias tsv ( url ) . get ( callback ) " , function ( test )  {%NWL%request . tsv ( " test / data / sample . tsv " ) . get ( function ( error , data )  {%NWL%test . equal ( XMLHttpRequest . _last . _info . url ,  " test / data / sample . tsv " ) ;%NWL%0
test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / tab - separated - values " ) ;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " tsv ( url , callback ) is an alias tsv ( url ) . get ( callback ) " , function ( test )  {%NWL%request . tsv ( " test / data / sample . tsv " ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%0
test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / tab - separated - values " ) ;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " tsv ( url , callback ) is an alias tsv ( url ) . get ( callback ) " , function ( test )  {%NWL%request . tsv ( " test / data / sample . tsv " ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . equal ( XMLHttpRequest . _last . _info . url ,  " test / data / sample . tsv " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%0
test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / tab - separated - values " ) ;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " tsv ( url , callback ) is an alias tsv ( url ) . get ( callback ) " , function ( test )  {%NWL%request . tsv ( " test / data / sample . tsv " ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . equal ( XMLHttpRequest . _last . _info . url ,  " test / data / sample . tsv " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / tab - separated - values " ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " tsv ( url , callback ) is an alias tsv ( url ) . get ( callback ) " , function ( test )  {%NWL%request . tsv ( " test / data / sample . tsv " ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . equal ( XMLHttpRequest . _last . _info . url ,  " test / data / sample . tsv " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / tab - separated - values " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( XMLHttpRequest . _last . _info . method ,  " GET " ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . async , true ) ;%NWL%test . equal ( XMLHttpRequest . _last . _info . mimeType ,  " text / tab - separated - values " ) ;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " tsv ( url , row , callback ) observes the specified row conversion function " , function ( test )  {%NWL%request . tsv ( " test / data / sample . tsv " , function ( d )  { d . Hello = - d . Hello; return d; } , function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . end ( ) ;%NWL%4
tape ( " tsv ( url , row , callback ) observes the specified row conversion function " , function ( test )  {%NWL%request . tsv ( " test / data / sample . tsv " , function ( d )  { d . Hello = - d . Hello; return d; } , function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . deepEqual ( data , table ( [ { Hello: - 42 , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " tsv ( url , row , callback ) is an alias for tsv ( url ) . row ( row ) . get ( callback ) " , function ( test )  {%NWL%request . tsv ( " test / data / sample . tsv " ) . row ( function ( d )  { d . Hello = - d . Hello; return d; } ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . end ( ) ;%NWL%4
request . tsv ( " test / data / sample . tsv " ) . row ( function ( d )  { d . Hello = - d . Hello; return d; } ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . deepEqual ( data , table ( [ { Hello: - 42 , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " tsv ( url ) . mimeType ( type ) . get ( callback ) observes the specified mime type " , function ( test )  {%NWL%request . tsv ( " test / data / sample . tsv " ) . mimeType ( " text / plain " ) . get ( function ( error , data )  {%NWL%if ( error ) throw error;%NWL%test . deepEqual ( data , table ( [ { Hello: " 42 " , World: " \ " fish\ " " } ] ,  [ " Hello " ,  " World " ] ) ) ;%NWL%test . end ( ) ;%NWL%3
test . equal ( request . responseText ,  " Hello , world!\n " ) ;%NWL%test . equal ( request . readyState , 4 ) ;%NWL%test . equal ( request . status , 200 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " request ( url , callback ) invokes the callback with an error if the request fails " , function ( test )  {%NWL%request . request ( " / / does / not / exist " , function ( error , request )  {%NWL%test . ok ( error instanceof XMLHttpRequestProgressEvent ) ;%NWL%test . ok ( error . target instanceof XMLHttpRequest ) ;%NWL%test . end ( ) ;%NWL%3
test . equal ( request . responseText ,  " Hello , world!\n " ) ;%NWL%test . equal ( request . _info . mimeType , undefined ) ;%NWL%test . equal ( request . readyState , 4 ) ;%NWL%test . equal ( request . status , 200 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " request ( url , nonFunction ) throws an error " , function ( test )  {%NWL%test . throws ( function ( )  { request . request ( " test / data / sample . txt " ,  " fail " ) ; } ,  / invalid callback / ) ;%NWL%test . throws ( function ( )  { request . request ( " test / data / sample . txt " , false ) ; } ,  / invalid callback / ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " request ( url , nonFunction ) throws an error " , function ( test )  {%NWL%test . throws ( function ( )  { request . request ( " test / data / sample . txt " ,  " fail " ) ; } ,  / invalid callback / ) ;%NWL%test . throws ( function ( )  { request . request ( " test / data / sample . txt " , false ) ; } ,  / invalid callback / ) ;%NWL%test . throws ( function ( )  { request . request ( " test / data / sample . txt " , 0 ) ; } ,  / invalid callback / ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " request ( url ) . mimeType ( type ) . get ( callback ) observes the specified mime type " , function ( test )  {%NWL%request . request ( " test / data / sample . txt " ) . mimeType ( " text / plain " ) . get ( function ( error , request )  {%NWL%if ( error ) throw error;%NWL%test . equal ( request . _info . mimeType ,  " text / plain " ) ;%NWL%test . end ( ) ;%NWL%4
request . request ( " test / data / sample . txt " ) . mimeType ( " text / plain " ) . get ( function ( error , request )  {%NWL%if ( error ) throw error;%NWL%test . equal ( request . _info . mimeType ,  " text / plain " ) ;%NWL%test . equal ( request . responseText ,  " Hello , world!\n " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " request ( url ) . get ( null , nonFunction ) throws an error " , function ( test )  {%NWL%test . throws ( function ( )  { request . request ( " test / data / sample . txt " ) . get ( null ,  " fail " ) ; } ,  / invalid callback / ) ;%NWL%test . throws ( function ( )  { request . request ( " test / data / sample . txt " ) . get ( null , false ) ; } ,  / invalid callback / ) ;%NWL%test . end ( ) ;%NWL%4
test . throws ( function ( )  { request . request ( " test / data / sample . txt " ) . get ( null ,  " fail " ) ; } ,  / invalid callback / ) ;%NWL%test . throws ( function ( )  { request . request ( " test / data / sample . txt " ) . get ( null , false ) ; } ,  / invalid callback / ) ;%NWL%test . throws ( function ( )  { request . request ( " test / data / sample . txt " ) . get ( null , 0 ) ; } ,  / invalid callback / ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " request ( url ) . on ( \ " beforesend\ " , listener ) . get ( ) invokes the listener before sending " , function ( test )  {%NWL%var r = request . request ( " test / data / sample . txt " ) ;%NWL%r . on ( " beforesend " , function ( request )  {%NWL%test . equal ( this , r ) ;%NWL%test . ok ( request instanceof XMLHttpRequest ) ;%NWL%test . end ( ) ;%NWL%3
var queue = [ ] , map = queue . map , some = queue . some , hasOwnProperty = queue . hasOwnProperty;%NWL%export var require = requireFrom ( function ( name )  {%NWL%if ( !name . length || / ^ [ \s . _ ] / . test ( name ) || / \s$ / . test ( name ) ) throw new Error ( " illegal name " ) ;%NWL%return " https: / / unpkg . com / "  + name;%NWL%} ) ;%NWL%export function requireFrom ( source )  {%NWL%var modules = new Map;%NWL%var url = source ( name +  " " ) , module = modules . get ( url ) ;%NWL%0
var queue = [ ] , map = queue . map , some = queue . some , hasOwnProperty = queue . hasOwnProperty;%NWL%export var require = requireFrom ( function ( name )  {%NWL%if ( !name . length || / ^ [ \s . _ ] / . test ( name ) || / \s$ / . test ( name ) ) throw new Error ( " illegal name " ) ;%NWL%return " https: / / unpkg . com / "  + name;%NWL%} ) ;%NWL%export function requireFrom ( source )  {%NWL%var modules = new Map;%NWL%function require ( name )  {%NWL%var url = source ( name +  " " ) , module = modules . get ( url ) ;%NWL%var script = document . createElement ( " script " ) ;%NWL%0
function computeLinkBreadths ( graph )  {%NWL%graph . nodes . forEach ( function ( node )  {%NWL%node . sourceLinks . sort ( ascendingTargetBreadth ) ;%NWL%node . targetLinks . sort ( ascendingSourceBreadth ) ;%NWL%} ) ;%NWL%graph . nodes . forEach ( function ( node )  {%NWL%var y0 = node . y0 , y1 = y0;%NWL%node . sourceLinks . forEach ( function ( link )  {%NWL%link . y0 = y0 + link . width / 2 , y0 + = link . width;%NWL%} ) ;%NWL%link . y1 = y1 + link . width / 2 , y1 + = link . width;%NWL%8
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%var sankey = d3 . sankey ( ) . nodeWidth ( 15 ) . nodePadding ( 10 ) . extent ( [ [ 1 , 1 ] ,  [ 959 , 494 ] ] ) ,%NWL%0
for ( k = 1 , p = pows ( i ) ; k < base; + + k )  {%NWL%t = p * k;%NWL%if ( t < u ) continue;%NWL%if ( t > v ) break;%NWL%z . push ( t ) ;%NWL%}%NWL%} else for ( ; i < j; + + i )  {%NWL%for ( k = base - 1 , p = pows ( i ) ; k >= 1; - - k )  {%NWL%t = p * k;%NWL%if ( t < u ) continue;%NWL%z . push ( t ) ;%NWL%4
test . equal ( s . bandwidth ( ) , 40 ) ;%NWL%s . padding ( 0 . 2 ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 7 . 5 , 45 , 82 . 5 ] ) ;%NWL%test . equal ( s . bandwidth ( ) , 30 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band ( value ) returns undefined for values outside the domain " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) ;%NWL%test . equal ( s ( " d " ) , undefined ) ;%NWL%test . equal ( s ( " e " ) , undefined ) ;%NWL%test . end ( ) ;%NWL%4
var s = scale . scaleBand ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) ;%NWL%test . equal ( s ( " d " ) , undefined ) ;%NWL%test . equal ( s ( " e " ) , undefined ) ;%NWL%test . equal ( s ( " f " ) , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band ( value ) does not implicitly add values to the domain " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) ;%NWL%s ( " d " ) ;%NWL%s ( " e " ) ;%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( s . domain ( ) ,  [ " a " ,  " b " ,  " c " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . step ( ) returns the distance between the starts of adjacent bands " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . range ( [ 0 , 960 ] ) ;%NWL%test . equal ( s . domain ( [ " foo " ] ) . step ( ) , 960 ) ;%NWL%test . equal ( s . domain ( [ " foo " ,  " bar " ] ) . step ( ) , 480 ) ;%NWL%test . equal ( s . domain ( [ " foo " ,  " bar " ,  " baz " ] ) . step ( ) , 320 ) ;%NWL%s . padding ( 0 . 5 ) ;%NWL%test . equal ( s . domain ( [ " foo " ] ) . step ( ) , 640 ) ;%NWL%test . end ( ) ;%NWL%1
s . padding ( 0 . 5 ) ;%NWL%test . equal ( s . domain ( [ " foo " ] ) . step ( ) , 640 ) ;%NWL%test . equal ( s . domain ( [ " foo " ,  " bar " ] ) . step ( ) , 384 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . bandwidth ( ) returns the width of the band " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . range ( [ 0 , 960 ] ) ;%NWL%test . equal ( s . domain ( [ ] ) . bandwidth ( ) , 960 ) ;%NWL%test . equal ( s . domain ( [ " foo " ] ) . bandwidth ( ) , 960 ) ;%NWL%test . equal ( s . domain ( [ " foo " ,  " bar " ] ) . bandwidth ( ) , 480 ) ;%NWL%s . padding ( 0 . 5 ) ;%NWL%0
test . equal ( s . domain ( [ " foo " ,  " bar " ,  " baz " ] ) . bandwidth ( ) , 320 ) ;%NWL%s . padding ( 0 . 5 ) ;%NWL%test . equal ( s . domain ( [ ] ) . bandwidth ( ) , 480 ) ;%NWL%test . equal ( s . domain ( [ " foo " ] ) . bandwidth ( ) , 320 ) ;%NWL%test . equal ( s . domain ( [ " foo " ,  " bar " ] ) . bandwidth ( ) , 192 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . domain ( [ ] ) computes reasonable band and step values " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ ] ) . range ( [ 0 , 960 ] ) ;%NWL%test . equal ( s . step ( ) , 960 ) ;%NWL%s . padding ( 0 . 5 ) ;%NWL%1
s . padding ( 0 . 5 ) ;%NWL%test . equal ( s . domain ( [ ] ) . bandwidth ( ) , 480 ) ;%NWL%test . equal ( s . domain ( [ " foo " ] ) . bandwidth ( ) , 320 ) ;%NWL%test . equal ( s . domain ( [ " foo " ,  " bar " ] ) . bandwidth ( ) , 192 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . domain ( [ ] ) computes reasonable band and step values " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ ] ) . range ( [ 0 , 960 ] ) ;%NWL%test . equal ( s . step ( ) , 960 ) ;%NWL%test . equal ( s . bandwidth ( ) , 960 ) ;%NWL%test . equal ( s . step ( ) , 960 ) ;%NWL%8
test . equal ( s . domain ( [ " foo " ,  " bar " ] ) . bandwidth ( ) , 192 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . domain ( [ ] ) computes reasonable band and step values " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ ] ) . range ( [ 0 , 960 ] ) ;%NWL%test . equal ( s . step ( ) , 960 ) ;%NWL%test . equal ( s . bandwidth ( ) , 960 ) ;%NWL%s . padding ( 0 . 5 ) ;%NWL%test . equal ( s . step ( ) , 960 ) ;%NWL%test . equal ( s . bandwidth ( ) , 480 ) ;%NWL%test . equal ( s . step ( ) , 960 ) ;%NWL%5
s . padding ( 0 . 5 ) ;%NWL%test . equal ( s . step ( ) , 960 ) ;%NWL%test . equal ( s . bandwidth ( ) , 480 ) ;%NWL%s . padding ( 1 ) ;%NWL%test . equal ( s . step ( ) , 960 ) ;%NWL%test . equal ( s . bandwidth ( ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . domain ( [ value ] ) computes a reasonable singleton band , even with padding " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " foo " ] ) . range ( [ 0 , 960 ] ) ;%NWL%test . equal ( s . step ( ) , 960 ) ;%NWL%1
test . equal ( s . step ( ) , 480 ) ;%NWL%test . equal ( s . bandwidth ( ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . domain ( values ) recomputes the bands " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . rangeRound ( [ 0 , 100 ] ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 1 , 34 , 67 ] ) ;%NWL%test . equal ( s . bandwidth ( ) , 33 ) ;%NWL%s . domain ( [ " a " ,  " b " ,  " c " ,  " d " ] ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 0 , 25 , 50 , 75 ] ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( s . bandwidth ( ) , 33 ) ;%NWL%s . domain ( [ " a " ,  " b " ,  " c " ,  " d " ] ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 0 , 25 , 50 , 75 ] ) ;%NWL%test . equal ( s . bandwidth ( ) , 25 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . domain ( values ) makes a copy of the specified domain values " , function ( test )  {%NWL%var domain = [ " red " ,  " green " ] ,%NWL%s = scale . scaleBand ( ) . domain ( domain ) ;%NWL%domain . push ( " blue " ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " band . domain ( values ) makes a copy of the specified domain values " , function ( test )  {%NWL%var domain = [ " red " ,  " green " ] ,%NWL%s = scale . scaleBand ( ) . domain ( domain ) ;%NWL%domain . push ( " blue " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ " red " ,  " green " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . domain ( ) returns a copy of the domain " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " red " ,  " green " ] ) ,%NWL%domain = s . domain ( ) ;%NWL%domain . push ( " blue " ) ;%NWL%3
var domain = [ " red " ,  " green " ] ,%NWL%s = scale . scaleBand ( ) . domain ( domain ) ;%NWL%domain . push ( " blue " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ " red " ,  " green " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . domain ( ) returns a copy of the domain " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " red " ,  " green " ] ) ,%NWL%domain = s . domain ( ) ;%NWL%test . deepEqual ( domain ,  [ " red " ,  " green " ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ " red " ,  " green " ] ) ;%NWL%3
s = scale . scaleBand ( ) . domain ( domain ) ;%NWL%domain . push ( " blue " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ " red " ,  " green " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . domain ( ) returns a copy of the domain " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " red " ,  " green " ] ) ,%NWL%domain = s . domain ( ) ;%NWL%test . deepEqual ( domain ,  [ " red " ,  " green " ] ) ;%NWL%domain . push ( " blue " ) ;%NWL%test . end ( ) ;%NWL%3
domain . push ( " blue " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ " red " ,  " green " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . range ( values ) can be descending " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . range ( [ 120 , 0 ] ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 80 , 40 , 0 ] ) ;%NWL%test . equal ( s . bandwidth ( ) , 40 ) ;%NWL%s . padding ( 0 . 2 ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 82 . 5 , 45 , 7 . 5 ] ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( s . bandwidth ( ) , 40 ) ;%NWL%s . padding ( 0 . 2 ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 82 . 5 , 45 , 7 . 5 ] ) ;%NWL%test . equal ( s . bandwidth ( ) , 30 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . range ( values ) makes a copy of the specified range values " , function ( test )  {%NWL%var range = [ 1 , 2 ] ,%NWL%s = scale . scaleBand ( ) . range ( range ) ;%NWL%range . push ( " blue " ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " band . range ( values ) makes a copy of the specified range values " , function ( test )  {%NWL%var range = [ 1 , 2 ] ,%NWL%s = scale . scaleBand ( ) . range ( range ) ;%NWL%range . push ( " blue " ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . range ( ) returns a copy of the range " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . range ( [ 1 , 2 ] ) ,%NWL%range = s . range ( ) ;%NWL%range . push ( " blue " ) ;%NWL%3
var range = [ 1 , 2 ] ,%NWL%s = scale . scaleBand ( ) . range ( range ) ;%NWL%range . push ( " blue " ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . range ( ) returns a copy of the range " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . range ( [ 1 , 2 ] ) ,%NWL%range = s . range ( ) ;%NWL%test . deepEqual ( range ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%3
s = scale . scaleBand ( ) . range ( range ) ;%NWL%range . push ( " blue " ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . range ( ) returns a copy of the range " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . range ( [ 1 , 2 ] ) ,%NWL%range = s . range ( ) ;%NWL%test . deepEqual ( range ,  [ 1 , 2 ] ) ;%NWL%range . push ( " blue " ) ;%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " band . range ( ) returns a copy of the range " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . range ( [ 1 , 2 ] ) ,%NWL%range = s . range ( ) ;%NWL%test . deepEqual ( range ,  [ 1 , 2 ] ) ;%NWL%range . push ( " blue " ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . range ( values ) coerces values [ 0 ] and values [ 1 ] to numbers " , function ( test )  {%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%6
tape ( " band . range ( ) returns a copy of the range " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . range ( [ 1 , 2 ] ) ,%NWL%range = s . range ( ) ;%NWL%test . deepEqual ( range ,  [ 1 , 2 ] ) ;%NWL%range . push ( " blue " ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . range ( values ) coerces values [ 0 ] and values [ 1 ] to numbers " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . range ( { 0: " 1 . 0 " , 1: " 2 . 0 " , length: 2 } ) ;%NWL%test . end ( ) ;%NWL%6
var s = scale . scaleBand ( ) . range ( { 0: " 1 . 0 " , 1: " 2 . 0 " , length: 2 } ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . paddingInner ( p ) specifies the inner padding p " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . range ( [ 120 , 0 ] ) . paddingInner ( 0 . 1 ) . round ( true ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 83 , 42 , 1 ] ) ;%NWL%test . equal ( s . bandwidth ( ) , 37 ) ;%NWL%s . paddingInner ( 0 . 2 ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 85 , 43 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%2
s . paddingInner ( 0 . 2 ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 85 , 43 , 1 ] ) ;%NWL%test . equal ( s . bandwidth ( ) , 34 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . paddingInner ( p ) coerces p to a number in [ 0 , 1 ] " , function ( test )  {%NWL%var s = scale . scaleBand ( ) ;%NWL%test . equal ( s . paddingInner ( " 1 . 0 " ) . paddingInner ( ) , 1 ) ;%NWL%test . equal ( s . paddingInner ( " - 1 . 0 " ) . paddingInner ( ) , 0 ) ;%NWL%test . equal ( s . paddingInner ( " 2 . 0 " ) . paddingInner ( ) , 1 ) ;%NWL%test . end ( ) ;%NWL%3
test . equal ( s . paddingInner ( " 2 . 0 " ) . paddingInner ( ) , 1 ) ;%NWL%test . ok ( Number . isNaN ( s . paddingInner ( NaN ) . paddingInner ( ) ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . paddingOuter ( p ) specifies the outer padding p " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . range ( [ 120 , 0 ] ) . paddingInner ( 0 . 2 ) . paddingOuter ( 0 . 1 ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 84 , 44 , 4 ] ) ;%NWL%test . equal ( s . bandwidth ( ) , 32 ) ;%NWL%s . paddingOuter ( 1 ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 75 , 50 , 25 ] ) ;%NWL%test . end ( ) ;%NWL%2
s . paddingOuter ( 1 ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 75 , 50 , 25 ] ) ;%NWL%test . equal ( s . bandwidth ( ) , 20 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . paddingOuter ( p ) coerces p to a number in [ 0 , 1 ] " , function ( test )  {%NWL%var s = scale . scaleBand ( ) ;%NWL%test . equal ( s . paddingOuter ( " 1 . 0 " ) . paddingOuter ( ) , 1 ) ;%NWL%test . equal ( s . paddingOuter ( " - 1 . 0 " ) . paddingOuter ( ) , 0 ) ;%NWL%test . equal ( s . paddingOuter ( " 2 . 0 " ) . paddingOuter ( ) , 1 ) ;%NWL%test . end ( ) ;%NWL%3
var s = scale . scaleBand ( ) ;%NWL%test . equal ( s . paddingOuter ( " 1 . 0 " ) . paddingOuter ( ) , 1 ) ;%NWL%test . equal ( s . paddingOuter ( " - 1 . 0 " ) . paddingOuter ( ) , 0 ) ;%NWL%test . equal ( s . paddingOuter ( " 2 . 0 " ) . paddingOuter ( ) , 1 ) ;%NWL%test . ok ( Number . isNaN ( s . paddingOuter ( NaN ) . paddingOuter ( ) ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . rangeRound ( values ) is an alias for band . range ( values ) . round ( true ) " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . rangeRound ( [ 0 , 100 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 0 , 100 ] ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( s . range ( ) ,  [ 0 , 100 ] ) ;%NWL%test . equal ( s . round ( ) , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . round ( true ) computes discrete rounded bands in a continuous range " , function ( test )  {%NWL%var s = scale . scaleBand ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . range ( [ 0 , 100 ] ) . round ( true ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 1 , 34 , 67 ] ) ;%NWL%test . equal ( s . bandwidth ( ) , 33 ) ;%NWL%s . padding ( 0 . 2 ) ;%NWL%test . deepEqual ( s . domain ( ) . map ( s ) ,  [ 7 , 38 , 69 ] ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( s . bandwidth ( ) , 25 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . copy ( ) copies all fields " , function ( test )  {%NWL%var s1 = scale . scaleBand ( ) . domain ( [ " red " ,  " green " ] ) . range ( [ 1 , 2 ] ) . round ( true ) . paddingInner ( 0 . 1 ) . paddingOuter ( 0 . 2 ) ,%NWL%s2 = s1 . copy ( ) ;%NWL%test . deepEqual ( s2 . domain ( ) , s1 . domain ( ) ) ;%NWL%test . deepEqual ( s2 . range ( ) , s1 . range ( ) ) ;%NWL%test . equal ( s2 . round ( ) , s1 . round ( ) ) ;%NWL%test . equal ( s2 . paddingInner ( ) , s1 . paddingInner ( ) ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . copy ( ) isolates changes to the domain " , function ( test )  {%NWL%var s1 = scale . scaleBand ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 2 ] ) ,%NWL%s2 = s1 . copy ( ) ;%NWL%s1 . domain ( [ " red " ,  " blue " ] ) ;%NWL%test . deepEqual ( s2 . domain ( ) ,  [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s1 . domain ( ) . map ( s1 ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( s2 . domain ( ) . map ( s2 ) ,  [ 0 , 1 ] ) ;%NWL%s2 . domain ( [ " red " ,  " blue " ] ) ;%NWL%test . deepEqual ( s1 . domain ( ) . map ( s1 ) ,  [ 0 , 1 ] ) ;%NWL%7
} ) ;%NWL%tape ( " band . copy ( ) isolates changes to the domain " , function ( test )  {%NWL%var s1 = scale . scaleBand ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 2 ] ) ,%NWL%s2 = s1 . copy ( ) ;%NWL%s1 . domain ( [ " red " ,  " blue " ] ) ;%NWL%test . deepEqual ( s2 . domain ( ) ,  [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s1 . domain ( ) . map ( s1 ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( s2 . domain ( ) . map ( s2 ) ,  [ 0 , 1 ] ) ;%NWL%s2 . domain ( [ " red " ,  " blue " ] ) ;%NWL%test . deepEqual ( s1 . domain ( ) ,  [ " red " ,  " blue " ] ) ;%NWL%test . deepEqual ( s2 . domain ( ) . map ( s2 ) ,  [ 0 , 1 ] ) ;%NWL%7
test . deepEqual ( s1 . domain ( ) ,  [ " red " ,  " blue " ] ) ;%NWL%test . deepEqual ( s1 . domain ( ) . map ( s1 ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( s2 . domain ( ) . map ( s2 ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . copy ( ) isolates changes to the range " , function ( test )  {%NWL%var s1 = scale . scaleBand ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 2 ] ) ,%NWL%s2 = s1 . copy ( ) ;%NWL%s1 . range ( [ 3 , 5 ] ) ;%NWL%test . deepEqual ( s2 . range ( ) ,  [ 0 , 2 ] ) ;%NWL%test . deepEqual ( s2 . domain ( ) . map ( s2 ) ,  [ 0 , 1 ] ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " band . copy ( ) isolates changes to the range " , function ( test )  {%NWL%var s1 = scale . scaleBand ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 2 ] ) ,%NWL%s2 = s1 . copy ( ) ;%NWL%s1 . range ( [ 3 , 5 ] ) ;%NWL%test . deepEqual ( s2 . range ( ) ,  [ 0 , 2 ] ) ;%NWL%test . deepEqual ( s1 . domain ( ) . map ( s1 ) ,  [ 3 , 4 ] ) ;%NWL%test . deepEqual ( s2 . domain ( ) . map ( s2 ) ,  [ 0 , 1 ] ) ;%NWL%s2 . range ( [ 5 , 7 ] ) ;%NWL%test . deepEqual ( s1 . domain ( ) . map ( s1 ) ,  [ 3 , 4 ] ) ;%NWL%7
test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity ( x ) is the identity function " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . domain ( [ 1 , 2 ] ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%test . equal ( s ( 1 ) , 1 ) ;%NWL%test . equal ( s ( 1 . 5 ) , 1 . 5 ) ;%NWL%test . equal ( s ( 2 ) , 2 ) ;%NWL%test . end ( ) ;%NWL%2
var s = scale . scaleIdentity ( ) . domain ( [ 1 , 2 ] ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%test . equal ( s ( 1 ) , 1 ) ;%NWL%test . equal ( s ( 1 . 5 ) , 1 . 5 ) ;%NWL%test . equal ( s ( 2 ) , 2 ) ;%NWL%test . equal ( s ( 2 . 5 ) , 2 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity ( x ) coerces input to a number " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . domain ( [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%6
var s = scale . scaleIdentity ( ) . domain ( [ 1 , 2 ] ) ;%NWL%test . equal ( s ( " 2 " ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity . invert ( y ) is the identity function " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . domain ( [ 1 , 2 ] ) ;%NWL%test . equal ( s . invert ( 0 . 5 ) , 0 . 5 ) ;%NWL%test . equal ( s . invert ( 1 ) , 1 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 2 ) , 2 ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( s . invert ( 2 ) , 2 ) ;%NWL%test . equal ( s . invert ( 2 . 5 ) , 2 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity . invert ( y ) coerces range value to numbers " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . range ( [ " 0 " ,  " 2 " ] ) ;%NWL%test . equal ( s . invert ( " 1 " ) , 1 ) ;%NWL%s . range ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%test . equal ( s . invert ( new Date ( 1990 , 6 , 2 , 13 ) ) ,  + new Date ( 1990 , 6 , 2 , 13 ) ) ;%NWL%s . range ( [ " #000 " ,  " #fff " ] ) ;%NWL%test . end ( ) ;%NWL%2
var s = scale . scaleIdentity ( ) . range ( [ " 0 " ,  " 2 " ] ) ;%NWL%test . equal ( s . invert ( " 1 " ) , 1 ) ;%NWL%s . range ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%test . equal ( s . invert ( new Date ( 1990 , 6 , 2 , 13 ) ) ,  + new Date ( 1990 , 6 , 2 , 13 ) ) ;%NWL%s . range ( [ " #000 " ,  " #fff " ] ) ;%NWL%test . ok ( isNaN ( s . invert ( " #999 " ) ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity . invert ( y ) coerces input to a number " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . domain ( [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%6
tape ( " identity . invert ( y ) coerces input to a number " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . domain ( [ 1 , 2 ] ) ;%NWL%test . equal ( s . invert ( " 2 " ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity . domain ( ) is an alias for scale . range ( ) " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) ;%NWL%test . equal ( s . domain , s . range ) ;%NWL%test . deepEqual ( s . domain ( ) , s . range ( ) ) ;%NWL%s . domain ( [ - 10 , 0 , 100 ] ) ;%NWL%s . range ( [ - 10 , 0 , 100 ] ) ;%NWL%9
test . equal ( s . invert ( " 2 " ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity . domain ( ) is an alias for scale . range ( ) " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) ;%NWL%test . equal ( s . domain , s . range ) ;%NWL%test . deepEqual ( s . domain ( ) , s . range ( ) ) ;%NWL%s . domain ( [ - 10 , 0 , 100 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%s . range ( [ - 10 , 0 , 100 ] ) ;%NWL%test . end ( ) ;%NWL%1
s . domain ( [ - 10 , 0 , 100 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%s . range ( [ - 10 , 0 , 100 ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity . domain ( ) defaults to [ 0 , 1 ] " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%4
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity . domain ( ) coerces values to numbers " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s . domain ( ) [ 0 ] ,  + new Date ( 1990 , 0 , 1 ) ) ;%NWL%test . equal ( s . domain ( ) [ 1 ] ,  + new Date ( 1991 , 0 , 1 ) ) ;%NWL%test . equal ( typeof s ( new Date ( 1989 , 9 , 20 ) ) ,  " number " ) ;%NWL%test . equal ( s ( new Date ( 1989 , 9 , 20 ) ) ,  + new Date ( 1989 , 9 , 20 ) ) ;%NWL%test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%4
} ) ;%NWL%tape ( " identity . domain ( ) coerces values to numbers " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s . domain ( ) [ 0 ] ,  + new Date ( 1990 , 0 , 1 ) ) ;%NWL%test . equal ( s . domain ( ) [ 1 ] ,  + new Date ( 1991 , 0 , 1 ) ) ;%NWL%test . equal ( typeof s ( new Date ( 1989 , 9 , 20 ) ) ,  " number " ) ;%NWL%test . equal ( s ( new Date ( 1989 , 9 , 20 ) ) ,  + new Date ( 1989 , 9 , 20 ) ) ;%NWL%s . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%4
test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s . domain ( ) [ 0 ] ,  + new Date ( 1990 , 0 , 1 ) ) ;%NWL%test . equal ( s . domain ( ) [ 1 ] ,  + new Date ( 1991 , 0 , 1 ) ) ;%NWL%test . equal ( typeof s ( new Date ( 1989 , 9 , 20 ) ) ,  " number " ) ;%NWL%test . equal ( s ( new Date ( 1989 , 9 , 20 ) ) ,  + new Date ( 1989 , 9 , 20 ) ) ;%NWL%s . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%0
test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s . domain ( ) [ 0 ] ,  + new Date ( 1990 , 0 , 1 ) ) ;%NWL%test . equal ( s . domain ( ) [ 1 ] ,  + new Date ( 1991 , 0 , 1 ) ) ;%NWL%test . equal ( typeof s ( new Date ( 1989 , 9 , 20 ) ) ,  " number " ) ;%NWL%test . equal ( s ( new Date ( 1989 , 9 , 20 ) ) ,  + new Date ( 1989 , 9 , 20 ) ) ;%NWL%s . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%s . domain ( [ new Number ( 0 ) , new Number ( 1 ) ] ) ;%NWL%test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%0
test . equal ( s . domain ( ) [ 0 ] ,  + new Date ( 1990 , 0 , 1 ) ) ;%NWL%test . equal ( s . domain ( ) [ 1 ] ,  + new Date ( 1991 , 0 , 1 ) ) ;%NWL%test . equal ( typeof s ( new Date ( 1989 , 9 , 20 ) ) ,  " number " ) ;%NWL%test . equal ( s ( new Date ( 1989 , 9 , 20 ) ) ,  + new Date ( 1989 , 9 , 20 ) ) ;%NWL%s . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%s . domain ( [ new Number ( 0 ) , new Number ( 1 ) ] ) ;%NWL%test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%7
test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%s . range ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%test . equal ( typeof s . range ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . range ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s . range ( ) [ 0 ] ,  + new Date ( 1990 , 0 , 1 ) ) ;%NWL%test . equal ( s . range ( ) [ 1 ] ,  + new Date ( 1991 , 0 , 1 ) ) ;%NWL%test . equal ( typeof s ( new Date ( 1989 , 9 , 20 ) ) ,  " number " ) ;%NWL%test . equal ( s ( new Date ( 1989 , 9 , 20 ) ) ,  + new Date ( 1989 , 9 , 20 ) ) ;%NWL%test . equal ( typeof s . range ( ) [ 0 ] ,  " number " ) ;%NWL%4
test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%s . range ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%test . equal ( typeof s . range ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . range ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s . range ( ) [ 0 ] ,  + new Date ( 1990 , 0 , 1 ) ) ;%NWL%test . equal ( s . range ( ) [ 1 ] ,  + new Date ( 1991 , 0 , 1 ) ) ;%NWL%test . equal ( typeof s ( new Date ( 1989 , 9 , 20 ) ) ,  " number " ) ;%NWL%test . equal ( s ( new Date ( 1989 , 9 , 20 ) ) ,  + new Date ( 1989 , 9 , 20 ) ) ;%NWL%s . range ( [ " 0 " ,  " 1 " ] ) ;%NWL%test . equal ( typeof s . range ( ) [ 1 ] ,  " number " ) ;%NWL%4
test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%s . range ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%test . equal ( typeof s . range ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . range ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s . range ( ) [ 0 ] ,  + new Date ( 1990 , 0 , 1 ) ) ;%NWL%test . equal ( s . range ( ) [ 1 ] ,  + new Date ( 1991 , 0 , 1 ) ) ;%NWL%test . equal ( typeof s ( new Date ( 1989 , 9 , 20 ) ) ,  " number " ) ;%NWL%test . equal ( s ( new Date ( 1989 , 9 , 20 ) ) ,  + new Date ( 1989 , 9 , 20 ) ) ;%NWL%s . range ( [ " 0 " ,  " 1 " ] ) ;%NWL%test . equal ( typeof s . range ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%0
test . equal ( typeof s . range ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . range ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s . range ( ) [ 0 ] ,  + new Date ( 1990 , 0 , 1 ) ) ;%NWL%test . equal ( s . range ( ) [ 1 ] ,  + new Date ( 1991 , 0 , 1 ) ) ;%NWL%test . equal ( typeof s ( new Date ( 1989 , 9 , 20 ) ) ,  " number " ) ;%NWL%test . equal ( s ( new Date ( 1989 , 9 , 20 ) ) ,  + new Date ( 1989 , 9 , 20 ) ) ;%NWL%s . range ( [ " 0 " ,  " 1 " ] ) ;%NWL%test . equal ( typeof s . range ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . range ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%test . equal ( typeof s . range ( ) [ 0 ] ,  " number " ) ;%NWL%0
test . equal ( typeof s . range ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s . range ( ) [ 0 ] ,  + new Date ( 1990 , 0 , 1 ) ) ;%NWL%test . equal ( s . range ( ) [ 1 ] ,  + new Date ( 1991 , 0 , 1 ) ) ;%NWL%test . equal ( typeof s ( new Date ( 1989 , 9 , 20 ) ) ,  " number " ) ;%NWL%test . equal ( s ( new Date ( 1989 , 9 , 20 ) ) ,  + new Date ( 1989 , 9 , 20 ) ) ;%NWL%s . range ( [ " 0 " ,  " 1 " ] ) ;%NWL%test . equal ( typeof s . range ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . range ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%s . range ( [ new Number ( 0 ) , new Number ( 1 ) ] ) ;%NWL%test . equal ( typeof s . range ( ) [ 1 ] ,  " number " ) ;%NWL%0
test . equal ( s . range ( ) [ 0 ] ,  + new Date ( 1990 , 0 , 1 ) ) ;%NWL%test . equal ( s . range ( ) [ 1 ] ,  + new Date ( 1991 , 0 , 1 ) ) ;%NWL%test . equal ( typeof s ( new Date ( 1989 , 9 , 20 ) ) ,  " number " ) ;%NWL%test . equal ( s ( new Date ( 1989 , 9 , 20 ) ) ,  + new Date ( 1989 , 9 , 20 ) ) ;%NWL%s . range ( [ " 0 " ,  " 1 " ] ) ;%NWL%test . equal ( typeof s . range ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . range ( ) [ 1 ] ,  " number " ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%s . range ( [ new Number ( 0 ) , new Number ( 1 ) ] ) ;%NWL%test . equal ( typeof s . range ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%7
test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity . domain ( ) can specify a polyidentity domain and range " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . domain ( [ - 10 , 0 , 100 ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%test . equal ( s ( - 5 ) ,  - 5 ) ;%NWL%test . equal ( s ( 50 ) , 50 ) ;%NWL%test . equal ( s ( 75 ) , 75 ) ;%NWL%s . range ( [ - 10 , 0 , 100 ] ) ;%NWL%test . equal ( s ( - 5 ) ,  - 5 ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity . domain ( ) can specify a polyidentity domain and range " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . domain ( [ - 10 , 0 , 100 ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%test . equal ( s ( - 5 ) ,  - 5 ) ;%NWL%test . equal ( s ( 50 ) , 50 ) ;%NWL%test . equal ( s ( 75 ) , 75 ) ;%NWL%s . range ( [ - 10 , 0 , 100 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%test . equal ( s ( 50 ) , 50 ) ;%NWL%6
} ) ;%NWL%tape ( " identity . domain ( ) can specify a polyidentity domain and range " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . domain ( [ - 10 , 0 , 100 ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%test . equal ( s ( - 5 ) ,  - 5 ) ;%NWL%test . equal ( s ( 50 ) , 50 ) ;%NWL%test . equal ( s ( 75 ) , 75 ) ;%NWL%s . range ( [ - 10 , 0 , 100 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%test . equal ( s ( - 5 ) ,  - 5 ) ;%NWL%test . equal ( s ( 75 ) , 75 ) ;%NWL%6
s . range ( [ - 10 , 0 , 100 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%test . equal ( s ( - 5 ) ,  - 5 ) ;%NWL%test . equal ( s ( 50 ) , 50 ) ;%NWL%test . equal ( s ( 75 ) , 75 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " identity . domain ( ) does not affect the identity function " , function ( test )  {%NWL%var s = scale . scaleIdentity ( ) . domain ( [ Infinity , NaN ] ) ;%NWL%test . equal ( s ( 42 ) , 42 ) ;%NWL%test . end ( ) ;%NWL%5
var s1 = scale . scaleIdentity ( ) ,%NWL%s2 = s1 . copy ( ) ,%NWL%s3 = s1 . copy ( ) ;%NWL%s1 . domain ( [ 1 , 2 ] ) ;%NWL%test . deepEqual ( s2 . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%s2 . domain ( [ 2 , 3 ] ) ;%NWL%test . deepEqual ( s1 . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( s2 . domain ( ) ,  [ 2 , 3 ] ) ;%NWL%s2 = s3 . copy ( ) ;%NWL%s3 . range ( [ 1 , 2 ] ) ;%NWL%s2 . range ( [ 2 , 3 ] ) ;%NWL%5
roundEpsilon = require ( " . / roundEpsilon " ) ;%NWL%tape ( " scaleLinear ( ) has the expected defaults " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 0 , 1 ] ) ;%NWL%test . equal ( s . clamp ( ) , false ) ;%NWL%test . deepEqual ( s . interpolate ( ) ( { array: [ " red " ] } ,  { array: [ " blue " ] } ) ( 0 . 5 ) ,  { array: [ " rgb ( 128 , 0 , 128 ) " ] } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear ( x ) maps a domain value x to a range value y " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . equal ( s . clamp ( ) , false ) ;%NWL%test . deepEqual ( s . interpolate ( ) ( { array: [ " red " ] } ,  { array: [ " blue " ] } ) ( 0 . 5 ) ,  { array: [ " rgb ( 128 , 0 , 128 ) " ] } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear ( x ) maps a domain value x to a range value y " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ 1 , 2 ] ) ( 0 . 5 ) , 1 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear ( x ) ignores extra range values if the domain is smaller than the range " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ - 10 , 0 ] ) . range ( [ " red " ,  " white " ,  " green " ] ) . clamp ( true ) ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( scale . scaleLinear ( ) . range ( [ 1 , 2 ] ) ( 0 . 5 ) , 1 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear ( x ) ignores extra range values if the domain is smaller than the range " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ - 10 , 0 ] ) . range ( [ " red " ,  " white " ,  " green " ] ) . clamp ( true ) ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ - 10 , 0 ] ) . range ( [ " red " ,  " white " ,  " green " ] ) . clamp ( true ) ( 50 ) ,  " rgb ( 255 , 255 , 255 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear ( x ) ignores extra domain values if the range is smaller than the domain " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ - 10 , 0 , 100 ] ) . range ( [ " red " ,  " white " ] ) . clamp ( true ) ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( scale . scaleLinear ( ) . domain ( [ - 10 , 0 ] ) . range ( [ " red " ,  " white " ,  " green " ] ) . clamp ( true ) ( 50 ) ,  " rgb ( 255 , 255 , 255 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear ( x ) ignores extra domain values if the range is smaller than the domain " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ - 10 , 0 , 100 ] ) . range ( [ " red " ,  " white " ] ) . clamp ( true ) ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ - 10 , 0 , 100 ] ) . range ( [ " red " ,  " white " ] ) . clamp ( true ) ( 50 ) ,  " rgb ( 255 , 255 , 255 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear ( x ) maps an empty domain to the range start " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 0 , 0 ] ) . range ( [ 1 , 2 ] ) ( 0 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
var s = scale . scaleLinear ( ) . domain ( [ - 10 , 0 , 100 ] ) . range ( [ " red " ,  " white " ,  " green " ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%test . equal ( s ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . equal ( s ( 50 ) ,  " rgb ( 128 , 192 , 128 ) " ) ;%NWL%test . equal ( s ( 75 ) ,  " rgb ( 64 , 160 , 64 ) " ) ;%NWL%s . domain ( [ 4 , 2 , 1 ] ) . range ( [ 1 , 2 , 4 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%6
test . deepEqual ( s . domain ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%test . equal ( s ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . equal ( s ( 50 ) ,  " rgb ( 128 , 192 , 128 ) " ) ;%NWL%test . equal ( s ( 75 ) ,  " rgb ( 64 , 160 , 64 ) " ) ;%NWL%s . domain ( [ 4 , 2 , 1 ] ) . range ( [ 1 , 2 , 4 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%s . domain ( [ 1 , 2 , 4 ] ) . range ( [ 4 , 2 , 1 ] ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%6
test . equal ( s ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . equal ( s ( 50 ) ,  " rgb ( 128 , 192 , 128 ) " ) ;%NWL%test . equal ( s ( 75 ) ,  " rgb ( 64 , 160 , 64 ) " ) ;%NWL%s . domain ( [ 4 , 2 , 1 ] ) . range ( [ 1 , 2 , 4 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%s . domain ( [ 1 , 2 , 4 ] ) . range ( [ 4 , 2 , 1 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%6
test . equal ( s ( 50 ) ,  " rgb ( 128 , 192 , 128 ) " ) ;%NWL%test . equal ( s ( 75 ) ,  " rgb ( 64 , 160 , 64 ) " ) ;%NWL%s . domain ( [ 4 , 2 , 1 ] ) . range ( [ 1 , 2 , 4 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%s . domain ( [ 1 , 2 , 4 ] ) . range ( [ 4 , 2 , 1 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%6
test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%s . domain ( [ 1 , 2 , 4 ] ) . range ( [ 4 , 2 , 1 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . invert ( y ) maps a range value y to a domain value x " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . invert ( y ) maps a range value y to a domain value x " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ 1 , 2 ] ) . invert ( 1 . 5 ) , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . invert ( y ) maps an empty range to the domain start " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 1 , 2 ] ) . range ( [ 0 , 0 ] ) . invert ( 0 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( scale . scaleLinear ( ) . range ( [ 1 , 2 ] ) . invert ( 1 . 5 ) , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . invert ( y ) maps an empty range to the domain start " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 1 , 2 ] ) . range ( [ 0 , 0 ] ) . invert ( 0 ) , 1 ) ;%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 2 , 1 ] ) . range ( [ 0 , 0 ] ) . invert ( 1 ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . invert ( y ) coerces range values to numbers " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " 0 " ,  " 2 " ] ) . invert ( " 1 " ) , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( scale . scaleLinear ( ) . domain ( [ 2 , 1 ] ) . range ( [ 0 , 0 ] ) . invert ( 1 ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . invert ( y ) coerces range values to numbers " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " 0 " ,  " 2 " ] ) . invert ( " 1 " ) , 0 . 5 ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) . invert ( new Date ( 1990 , 6 , 2 , 13 ) ) , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . invert ( y ) returns NaN if the range is not coercible to number " , function ( test )  {%NWL%test . ok ( isNaN ( scale . scaleLinear ( ) . range ( [ " #000 " ,  " #fff " ] ) . invert ( " #999 " ) ) ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . invert ( y ) returns NaN if the range is not coercible to number " , function ( test )  {%NWL%test . ok ( isNaN ( scale . scaleLinear ( ) . range ( [ " #000 " ,  " #fff " ] ) . invert ( " #999 " ) ) ) ;%NWL%test . ok ( isNaN ( scale . scaleLinear ( ) . range ( [ 0 ,  " #fff " ] ) . invert ( " #999 " ) ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . domain ( domain ) accepts an array of numbers " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ ] ) . domain ( ) ,  [ ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 1 , 0 ] ) . domain ( ) ,  [ 1 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " linear . domain ( domain ) accepts an array of numbers " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ ] ) . domain ( ) ,  [ ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 1 , 0 ] ) . domain ( ) ,  [ 1 , 0 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 1 , 2 , 3 ] ) . domain ( ) ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . domain ( domain ) coerces domain values to numbers " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) . domain ( ) ,  [ 631180800000 , 662716800000 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ " 0 . 0 " ,  " 1 . 0 " ] ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " linear . domain ( domain ) coerces domain values to numbers " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) . domain ( ) ,  [ 631180800000 , 662716800000 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ " 0 . 0 " ,  " 1 . 0 " ] ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ new Number ( 0 ) , new Number ( 1 ) ] ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . domain ( domain ) makes a copy of domain values " , function ( test )  {%NWL%var d = [ 1 , 2 ] , s = scale . scaleLinear ( ) . domain ( d ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%9
test . deepEqual ( scale . scaleLinear ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) . domain ( ) ,  [ 631180800000 , 662716800000 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ " 0 . 0 " ,  " 1 . 0 " ] ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ new Number ( 0 ) , new Number ( 1 ) ] ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . domain ( domain ) makes a copy of domain values " , function ( test )  {%NWL%var d = [ 1 , 2 ] , s = scale . scaleLinear ( ) . domain ( d ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . domain ( domain ) makes a copy of domain values " , function ( test )  {%NWL%var d = [ 1 , 2 ] , s = scale . scaleLinear ( ) . domain ( d ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( d ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var s = scale . scaleLinear ( ) , d = s . domain ( ) ;%NWL%3
tape ( " linear . domain ( domain ) makes a copy of domain values " , function ( test )  {%NWL%var d = [ 1 , 2 ] , s = scale . scaleLinear ( ) . domain ( d ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( d ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . domain ( ) returns a copy of domain values " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) , d = s . domain ( ) ;%NWL%d . push ( 3 ) ;%NWL%3
test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( d ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . domain ( ) returns a copy of domain values " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) , d = s . domain ( ) ;%NWL%test . deepEqual ( d ,  [ 0 , 1 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " linear . domain ( ) returns a copy of domain values " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) , d = s . domain ( ) ;%NWL%test . deepEqual ( d ,  [ 0 , 1 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . range ( range ) does not coerce range to numbers " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) . range ( [ " 0px " ,  " 2px " ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ " 0px " ,  " 2px " ] ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( s . range ( ) ,  [ " 0px " ,  " 2px " ] ) ;%NWL%test . equal ( s ( 0 . 5 ) ,  " 1px " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . range ( range ) can accept range values as colors " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " red " ,  " blue " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " #ff0000 " ,  " #0000ff " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " #f00 " ,  " #00f " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " rgb ( 255 , 0 , 0 ) " ,  " hsl ( 240 , 100% , 50% ) " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " rgb ( 100% , 0% , 0% ) " ,  " hsl ( 240 , 100% , 50% ) " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( scale . scaleLinear ( ) . range ( [ " red " ,  " blue " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " #ff0000 " ,  " #0000ff " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " #f00 " ,  " #00f " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " rgb ( 255 , 0 , 0 ) " ,  " hsl ( 240 , 100% , 50% ) " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " rgb ( 100% , 0% , 0% ) " ,  " hsl ( 240 , 100% , 50% ) " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ " hsl ( 0 , 100% , 50% ) " ,  " hsl ( 240 , 100% , 50% ) " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . range ( range ) can accept range values as arrays or objects " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . range ( [ { color: " red " } ,  { color: " blue " } ] ) ( 0 . 5 ) ,  { color: " rgb ( 128 , 0 , 128 ) " } ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . range ( range ) can accept range values as arrays or objects " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . range ( [ { color: " red " } ,  { color: " blue " } ] ) ( 0 . 5 ) ,  { color: " rgb ( 128 , 0 , 128 ) " } ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . range ( [ [ " red " ] ,  [ " blue " ] ] ) ( 0 . 5 ) ,  [ " rgb ( 128 , 0 , 128 ) " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . range ( range ) makes a copy of range values " , function ( test )  {%NWL%var r = [ 1 , 2 ] , s = scale . scaleLinear ( ) . range ( r ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%9
tape ( " linear . range ( range ) can accept range values as arrays or objects " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . range ( [ { color: " red " } ,  { color: " blue " } ] ) ( 0 . 5 ) ,  { color: " rgb ( 128 , 0 , 128 ) " } ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . range ( [ [ " red " ] ,  [ " blue " ] ] ) ( 0 . 5 ) ,  [ " rgb ( 128 , 0 , 128 ) " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . range ( range ) makes a copy of range values " , function ( test )  {%NWL%var r = [ 1 , 2 ] , s = scale . scaleLinear ( ) . range ( r ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . range ( range ) makes a copy of range values " , function ( test )  {%NWL%var r = [ 1 , 2 ] , s = scale . scaleLinear ( ) . range ( r ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( r ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var s = scale . scaleLinear ( ) , r = s . range ( ) ;%NWL%3
tape ( " linear . range ( range ) makes a copy of range values " , function ( test )  {%NWL%var r = [ 1 , 2 ] , s = scale . scaleLinear ( ) . range ( r ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( r ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . range ( ) returns a copy of range values " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) , r = s . range ( ) ;%NWL%r . push ( 3 ) ;%NWL%3
test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( r ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . range ( ) returns a copy of range values " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) , r = s . range ( ) ;%NWL%test . deepEqual ( r ,  [ 0 , 1 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . end ( ) ;%NWL%4
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . range ( ) returns a copy of range values " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) , r = s . range ( ) ;%NWL%test . deepEqual ( r ,  [ 0 , 1 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . rangeRound ( range ) is an alias for linear . range ( range ) . interpolate ( interpolateRound ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " linear . rangeRound ( range ) is an alias for linear . range ( range ) . interpolate ( interpolateRound ) " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . rangeRound ( [ 0 , 10 ] ) ( 0 . 59 ) , 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . clamp ( ) is false by default " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( ) , false ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ 10 , 20 ] ) ( 2 ) , 30 ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ 10 , 20 ] ) ( - 1 ) , 0 ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ 10 , 20 ] ) . invert ( 30 ) , 2 ) ;%NWL%test . end ( ) ;%NWL%3
tape ( " linear . clamp ( ) is false by default " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( ) , false ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ 10 , 20 ] ) ( 2 ) , 30 ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ 10 , 20 ] ) ( - 1 ) , 0 ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ 10 , 20 ] ) . invert ( 30 ) , 2 ) ;%NWL%test . equal ( scale . scaleLinear ( ) . range ( [ 10 , 20 ] ) . invert ( 0 ) ,  - 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . clamp ( true ) restricts output values to the range " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) ( 2 ) , 20 ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( scale . scaleLinear ( ) . range ( [ 10 , 20 ] ) . invert ( 0 ) ,  - 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . clamp ( true ) restricts output values to the range " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) ( 2 ) , 20 ) ;%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) ( - 1 ) , 10 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . clamp ( true ) restricts input values to the domain " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) . invert ( 30 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%tape ( " linear . clamp ( true ) restricts input values to the domain " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) . invert ( 30 ) , 1 ) ;%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) . invert ( 0 ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . clamp ( clamp ) coerces the specified clamp value to a boolean " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( " true " ) . clamp ( ) , true ) ;%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( 1 ) . clamp ( ) , true ) ;%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( " " ) . clamp ( ) , false ) ;%NWL%test . end ( ) ;%NWL%4
test . equal ( scale . scaleLinear ( ) . clamp ( " true " ) . clamp ( ) , true ) ;%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( 1 ) . clamp ( ) , true ) ;%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( " " ) . clamp ( ) , false ) ;%NWL%test . equal ( scale . scaleLinear ( ) . clamp ( 0 ) . clamp ( ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . interpolate ( interpolate ) takes a custom interpolator factory " , function ( test )  {%NWL%function interpolate ( a , b )  { return function ( t )  { return [ a , b , t ] ; } ; }%NWL%var s = scale . scaleLinear ( ) . domain ( [ 10 , 20 ] ) . range ( [ " a " ,  " b " ] ) . interpolate ( interpolate ) ;%NWL%test . equal ( s . interpolate ( ) , interpolate ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " linear . interpolate ( interpolate ) takes a custom interpolator factory " , function ( test )  {%NWL%function interpolate ( a , b )  { return function ( t )  { return [ a , b , t ] ; } ; }%NWL%var s = scale . scaleLinear ( ) . domain ( [ 10 , 20 ] ) . range ( [ " a " ,  " b " ] ) . interpolate ( interpolate ) ;%NWL%test . equal ( s . interpolate ( ) , interpolate ) ;%NWL%test . deepEqual ( s ( 15 ) ,  [ " a " ,  " b " , 0 . 5 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . nice ( ) is an alias for linear . nice ( 10 ) " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 , 0 . 96 ] ) . nice ( ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( scale . scaleLinear ( ) . domain ( [ - 0 . 1 , 51 . 1 ] ) . nice ( 8 ) . domain ( ) ,  [ - 10 , 60 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . nice ( count ) nices the domain , extending it to round numbers " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 1 . 1 , 10 . 9 ] ) . nice ( 10 ) . domain ( ) ,  [ 1 , 11 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 10 . 9 , 1 . 1 ] ) . nice ( 10 ) . domain ( ) ,  [ 11 , 1 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 . 7 , 11 . 001 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 12 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 123 . 1 , 6 . 7 ] ) . nice ( 10 ) . domain ( ) ,  [ 130 , 0 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 , 0 . 49 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 0 . 5 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 , 14 . 1 ] ) . nice ( 5 ) . domain ( ) ,  [ 0 , 20 ] ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 10 . 9 , 1 . 1 ] ) . nice ( 10 ) . domain ( ) ,  [ 11 , 1 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 . 7 , 11 . 001 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 12 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 123 . 1 , 6 . 7 ] ) . nice ( 10 ) . domain ( ) ,  [ 130 , 0 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 , 0 . 49 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 0 . 5 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 , 14 . 1 ] ) . nice ( 5 ) . domain ( ) ,  [ 0 , 20 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 , 15 ] ) . nice ( 5 ) . domain ( ) ,  [ 0 , 20 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . nice ( count ) has no effect on degenerate domains " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 , 0 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 , 15 ] ) . nice ( 5 ) . domain ( ) ,  [ 0 , 20 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . nice ( count ) has no effect on degenerate domains " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 , 0 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 0 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 0 . 5 , 0 . 5 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 . 5 , 0 . 5 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . nice ( count ) nicing a polylinear domain only affects the extent " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 1 . 1 , 1 , 2 , 3 , 10 . 9 ] ) . nice ( 10 ) . domain ( ) ,  [ 1 , 1 , 2 , 3 , 11 ] ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . nice ( count ) nicing a polylinear domain only affects the extent " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 1 . 1 , 1 , 2 , 3 , 10 . 9 ] ) . nice ( 10 ) . domain ( ) ,  [ 1 , 1 , 2 , 3 , 11 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 123 . 1 , 1 , 2 , 3 ,  - 0 . 9 ] ) . nice ( 10 ) . domain ( ) ,  [ 130 , 1 , 2 , 3 ,  - 10 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . nice ( count ) accepts a tick count to control nicing step " , function ( test )  {%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 12 , 87 ] ) . nice ( 5 ) . domain ( ) ,  [ 0 , 100 ] ) ;%NWL%test . deepEqual ( scale . scaleLinear ( ) . domain ( [ 12 , 87 ] ) . nice ( 10 ) . domain ( ) ,  [ 10 , 90 ] ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( s . ticks ( 3 ) ,  [ - 100 ,       - 50 ,      0 ,     50 ,     100 ] ) ;%NWL%test . deepEqual ( s . ticks ( 2 ) ,  [ - 100 ,              0 ,           100 ] ) ;%NWL%test . deepEqual ( s . ticks ( 1 ) ,  [                0             ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . ticks ( count ) returns the empty array if count is not a positive integer " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) ;%NWL%test . deepEqual ( s . ticks ( NaN ) ,  [ ] ) ;%NWL%test . deepEqual ( s . ticks ( 0 ) ,  [ ] ) ;%NWL%test . deepEqual ( s . ticks ( - 1 ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%3
tape ( " linear . ticks ( count ) returns the empty array if count is not a positive integer " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) ;%NWL%test . deepEqual ( s . ticks ( NaN ) ,  [ ] ) ;%NWL%test . deepEqual ( s . ticks ( 0 ) ,  [ ] ) ;%NWL%test . deepEqual ( s . ticks ( - 1 ) ,  [ ] ) ;%NWL%test . deepEqual ( s . ticks ( Infinity ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . ticks ( ) is an alias for linear . ticks ( 10 ) " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( s . ticks ( Infinity ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . ticks ( ) is an alias for linear . ticks ( 10 ) " , function ( test )  {%NWL%var s = scale . scaleLinear ( ) ;%NWL%test . deepEqual ( s . ticks ( ) , s . ticks ( 10 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . tickFormat ( ) is an alias for linear . tickFormat ( 10 ) " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . tickFormat ( ) ( 0 . 2 ) ,  " 0 . 2 " ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . tickFormat ( ) is an alias for linear . tickFormat ( 10 ) " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . tickFormat ( ) ( 0 . 2 ) ,  " 0 . 2 " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ - 100 , 100 ] ) . tickFormat ( ) ( - 20 ) ,  " - 20 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . tickFormat ( count ) returns a format suitable for the ticks " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . tickFormat ( 10 ) ( 0 . 2 ) ,  " 0 . 2 " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . tickFormat ( 20 ) ( 0 . 2 ) ,  " 0 . 20 " ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " linear . tickFormat ( count ) returns a format suitable for the ticks " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . tickFormat ( 10 ) ( 0 . 2 ) ,  " 0 . 2 " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . tickFormat ( 20 ) ( 0 . 2 ) ,  " 0 . 20 " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ - 100 , 100 ] ) . tickFormat ( 10 ) ( - 20 ) ,  " - 20 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . tickFormat ( count , specifier ) sets the appropriate fixed precision if not specified " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . tickFormat ( 10 ,  " + f " ) ( 0 . 2 ) ,  " + 0 . 2 " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . tickFormat ( 20 ,  " + f " ) ( 0 . 2 ) ,  " + 0 . 20 " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . tickFormat ( 10 ,  " + % " ) ( 0 . 2 ) ,  " + 20% " ) ;%NWL%test . end ( ) ;%NWL%4
test . equal ( scale . scaleLinear ( ) . domain ( [ 0 , 9 ] ) . tickFormat ( 100 ,  " g " ) ( 2 . 11 ) ,  " 2 . 1 " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 0 , 9 ] ) . tickFormat ( 10 ,  " r " ) ( 2 . 10e6 ) ,  " 2000000 " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 0 , 9 ] ) . tickFormat ( 100 ,  " r " ) ( 2 . 01e6 ) ,  " 2000000 " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 0 , 9 ] ) . tickFormat ( 100 ,  " r " ) ( 2 . 11e6 ) ,  " 2100000 " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 0 , 0 . 9 ] ) . tickFormat ( 10 ,  " p " ) ( 0 . 210 ) ,  " 20% " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 0 . 19 , 0 . 21 ] ) . tickFormat ( 10 ,  " p " ) ( 0 . 201 ) ,  " 20 . 1% " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . tickFormat ( count , specifier ) sets the appropriate prefix precision if not specified " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 0 , 1e6 ] ) . tickFormat ( 10 ,  " $s " ) ( 0 . 51e6 ) ,  " $0 . 5M " ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . tickFormat ( count , specifier ) sets the appropriate prefix precision if not specified " , function ( test )  {%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 0 , 1e6 ] ) . tickFormat ( 10 ,  " $s " ) ( 0 . 51e6 ) ,  " $0 . 5M " ) ;%NWL%test . equal ( scale . scaleLinear ( ) . domain ( [ 0 , 1e6 ] ) . tickFormat ( 100 ,  " $s " ) ( 0 . 501e6 ) ,  " $0 . 50M " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . tickFormat ( ) uses the default precision when the domain is invalid " , function ( test )  {%NWL%var f = scale . scaleLinear ( ) . domain ( [ 0 , NaN ] ) . tickFormat ( ) ;%NWL%test . equal ( f +  " " ,  " > - , f " ) ;%NWL%test . end ( ) ;%NWL%0
x . domain ( [ 1 , 2 ] ) ;%NWL%test . deepEqual ( y . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . equal ( x ( 1 ) , 0 ) ;%NWL%test . equal ( y ( 1 ) , 1 ) ;%NWL%y . domain ( [ 2 , 3 ] ) ;%NWL%test . equal ( x ( 2 ) , 1 ) ;%NWL%test . equal ( y ( 2 ) , 0 ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( y . domain ( ) ,  [ 2 , 3 ] ) ;%NWL%y = x . domain ( [ 1 , 1 . 9 ] ) . copy ( ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%7
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . copy ( ) returns a copy with changes to the interpolator are isolated " , function ( test )  {%NWL%var x = scale . scaleLinear ( ) . range ( [ " red " ,  " blue " ] ) ,%NWL%y = x . copy ( ) ,%NWL%i0 = x . interpolate ( ) ,%NWL%i1 = function ( a , b )  { return function ( )  { return b; } ; } ;%NWL%x . interpolate ( i1 ) ;%NWL%test . equal ( y . interpolate ( ) , i0 ) ;%NWL%test . equal ( x ( 0 . 5 ) ,  " blue " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( x ( 0 . 5 ) ,  " blue " ) ;%NWL%test . equal ( y ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " linear . copy ( ) returns a copy with changes to clamping are isolated " , function ( test )  {%NWL%var x = scale . scaleLinear ( ) . clamp ( true ) , y = x . copy ( ) ;%NWL%x . clamp ( false ) ;%NWL%test . equal ( x ( 2 ) , 2 ) ;%NWL%test . equal ( y ( 2 ) , 1 ) ;%NWL%test . equal ( y . clamp ( ) , true ) ;%NWL%test . equal ( x ( 2 ) , 2 ) ;%NWL%7
test . equal ( s ( 2 . 0 ) ,  " c " ) ;%NWL%test . equal ( s ( new Number ( 2 ) ) ,  " c " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal ( x ) implicitly extends the domain when a range is explicitly specified " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . range ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ ] ) ;%NWL%test . equal ( s ( 0 ) ,  " foo " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 ] ) ;%NWL%test . equal ( s ( 1 ) ,  " bar " ) ;%NWL%test . equal ( s ( 0 ) ,  " foo " ) ;%NWL%7
test . equal ( s ( new Number ( 2 ) ) ,  " c " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal ( x ) implicitly extends the domain when a range is explicitly specified " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . range ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ ] ) ;%NWL%test . equal ( s ( 0 ) ,  " foo " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 ] ) ;%NWL%test . equal ( s ( 1 ) ,  " bar " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%9
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal ( x ) implicitly extends the domain when a range is explicitly specified " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . range ( [ " foo " ,  " bar " ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ ] ) ;%NWL%test . equal ( s ( 0 ) ,  " foo " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 ] ) ;%NWL%test . equal ( s ( 1 ) ,  " bar " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . equal ( s ( 0 ) ,  " foo " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( s ( 1 ) ,  " bar " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . equal ( s ( 0 ) ,  " foo " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . domain ( x ) makes a copy of the domain " , function ( test )  {%NWL%var domain = [ " red " ,  " green " ] ,%NWL%s = scale . scaleOrdinal ( ) . domain ( domain ) ;%NWL%domain . push ( " blue " ) ;%NWL%test . end ( ) ;%NWL%4
var domain = [ " red " ,  " green " ] ,%NWL%s = scale . scaleOrdinal ( ) . domain ( domain ) ;%NWL%domain . push ( " blue " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ " red " ,  " green " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . domain ( ) returns a copy of the domain " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . domain ( [ " red " ,  " green " ] ) ,%NWL%domain = s . domain ( ) ;%NWL%s ( " blue " ) ;%NWL%test . end ( ) ;%NWL%4
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . domain ( ) replaces previous domain values " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . range ( [ " foo " ,  " bar " ] ) ;%NWL%test . equal ( s ( 1 ) ,  " foo " ) ;%NWL%test . equal ( s ( 0 ) ,  " bar " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 0 ] ) ;%NWL%s . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%test . equal ( s ( 0 ) ,  " foo " ) ; / / it changed!%NWL%test . equal ( s ( 1 ) ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%0
s . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%test . equal ( s ( 0 ) ,  " foo " ) ; / / it changed!%NWL%test . equal ( s ( 1 ) ,  " bar " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ " 0 " ,  " 1 " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . domain ( ) uniqueness is based on string coercion " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . domain ( [ " foo " ] ) . range ( [ 42 , 43 , 44 ] ) ;%NWL%test . equal ( s ( new String ( " foo " ) ) , 42 ) ;%NWL%test . equal ( s ( { toString: function ( )  { return " foo " ; } } ) , 42 ) ;%NWL%test . end ( ) ;%NWL%4
var s = scale . scaleOrdinal ( ) . domain ( [ " foo " ] ) . range ( [ 42 , 43 , 44 ] ) ;%NWL%test . equal ( s ( new String ( " foo " ) ) , 42 ) ;%NWL%test . equal ( s ( { toString: function ( )  { return " foo " ; } } ) , 42 ) ;%NWL%test . equal ( s ( { toString: function ( )  { return " bar " ; } } ) , 43 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . domain ( ) does not coerce domain values to strings " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . domain ( [ 0 , 1 ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%test . end ( ) ;%NWL%4
var s = scale . scaleOrdinal ( ) . domain ( [ 0 , 1 ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . equal ( typeof s . domain ( ) [ 0 ] ,  " number " ) ;%NWL%test . equal ( typeof s . domain ( ) [ 1 ] ,  " number " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . domain ( ) does not barf on object built - ins " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . domain ( [ " __proto__ " ,  " hasOwnProperty " ] ) . range ( [ 42 , 43 ] ) ;%NWL%test . equal ( s ( " __proto__ " ) , 42 ) ;%NWL%test . equal ( s ( " hasOwnProperty " ) , 43 ) ;%NWL%test . end ( ) ;%NWL%4
s . domain ( [ ] ) ;%NWL%s ( " foo " ) ;%NWL%s ( " bar " ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ " foo " ,  " bar " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . range ( x ) makes a copy of the range " , function ( test )  {%NWL%var range = [ " red " ,  " green " ] ,%NWL%s = scale . scaleOrdinal ( ) . range ( range ) ;%NWL%range . push ( " blue " ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " ordinal . range ( x ) makes a copy of the range " , function ( test )  {%NWL%var range = [ " red " ,  " green " ] ,%NWL%s = scale . scaleOrdinal ( ) . range ( range ) ;%NWL%range . push ( " blue " ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ " red " ,  " green " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . range ( ) returns a copy of the range " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . range ( [ " red " ,  " green " ] ) ,%NWL%range = s . range ( ) ;%NWL%range . push ( " blue " ) ;%NWL%3
var range = [ " red " ,  " green " ] ,%NWL%s = scale . scaleOrdinal ( ) . range ( range ) ;%NWL%range . push ( " blue " ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ " red " ,  " green " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . range ( ) returns a copy of the range " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . range ( [ " red " ,  " green " ] ) ,%NWL%range = s . range ( ) ;%NWL%test . deepEqual ( range ,  [ " red " ,  " green " ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ " red " ,  " green " ] ) ;%NWL%3
s = scale . scaleOrdinal ( ) . range ( range ) ;%NWL%range . push ( " blue " ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ " red " ,  " green " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . range ( ) returns a copy of the range " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . range ( [ " red " ,  " green " ] ) ,%NWL%range = s . range ( ) ;%NWL%test . deepEqual ( range ,  [ " red " ,  " green " ] ) ;%NWL%range . push ( " blue " ) ;%NWL%test . end ( ) ;%NWL%3
range . push ( " blue " ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ " red " ,  " green " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . range ( values ) does not discard implicit domain associations " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) ;%NWL%test . equal ( s ( 0 ) , undefined ) ;%NWL%test . equal ( s ( 1 ) , undefined ) ;%NWL%s . range ( [ " foo " ,  " bar " ] ) ;%NWL%test . equal ( s ( 1 ) ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( s ( 0 ) ,  " foo " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal ( value ) recycles values when exhausted " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . range ( [ " a " ,  " b " ,  " c " ] ) ;%NWL%test . equal ( s ( 0 ) ,  " a " ) ;%NWL%test . equal ( s ( 1 ) ,  " b " ) ;%NWL%test . equal ( s ( 2 ) ,  " c " ) ;%NWL%test . equal ( s ( 3 ) ,  " a " ) ;%NWL%test . equal ( s ( 4 ) ,  " b " ) ;%NWL%test . equal ( s ( 2 ) ,  " c " ) ;%NWL%7
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal ( value ) recycles values when exhausted " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . range ( [ " a " ,  " b " ,  " c " ] ) ;%NWL%test . equal ( s ( 0 ) ,  " a " ) ;%NWL%test . equal ( s ( 1 ) ,  " b " ) ;%NWL%test . equal ( s ( 2 ) ,  " c " ) ;%NWL%test . equal ( s ( 3 ) ,  " a " ) ;%NWL%test . equal ( s ( 4 ) ,  " b " ) ;%NWL%test . equal ( s ( 5 ) ,  " c " ) ;%NWL%test . equal ( s ( 1 ) ,  " b " ) ;%NWL%5
} ) ;%NWL%tape ( " ordinal ( value ) recycles values when exhausted " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . range ( [ " a " ,  " b " ,  " c " ] ) ;%NWL%test . equal ( s ( 0 ) ,  " a " ) ;%NWL%test . equal ( s ( 1 ) ,  " b " ) ;%NWL%test . equal ( s ( 2 ) ,  " c " ) ;%NWL%test . equal ( s ( 3 ) ,  " a " ) ;%NWL%test . equal ( s ( 4 ) ,  " b " ) ;%NWL%test . equal ( s ( 5 ) ,  " c " ) ;%NWL%test . equal ( s ( 2 ) ,  " c " ) ;%NWL%test . equal ( s ( 0 ) ,  " a " ) ;%NWL%3
test . equal ( s ( 2 ) ,  " c " ) ;%NWL%test . equal ( s ( 1 ) ,  " b " ) ;%NWL%test . equal ( s ( 0 ) ,  " a " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . unknown ( x ) sets the output value for unknown inputs " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . domain ( [ " foo " ,  " bar " ] ) . unknown ( " gray " ) . range ( [ " red " ,  " blue " ] ) ;%NWL%test . equal ( s ( " foo " ) ,  " red " ) ;%NWL%test . equal ( s ( " bar " ) ,  " blue " ) ;%NWL%test . equal ( s ( " baz " ) ,  " gray " ) ;%NWL%test . end ( ) ;%NWL%3
var s = scale . scaleOrdinal ( ) . domain ( [ " foo " ,  " bar " ] ) . unknown ( " gray " ) . range ( [ " red " ,  " blue " ] ) ;%NWL%test . equal ( s ( " foo " ) ,  " red " ) ;%NWL%test . equal ( s ( " bar " ) ,  " blue " ) ;%NWL%test . equal ( s ( " baz " ) ,  " gray " ) ;%NWL%test . equal ( s ( " quux " ) ,  " gray " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . unknown ( x ) prevents implicit domain extension if x is not implicit " , function ( test )  {%NWL%var s = scale . scaleOrdinal ( ) . domain ( [ " foo " ,  " bar " ] ) . unknown ( undefined ) . range ( [ " red " ,  " blue " ] ) ;%NWL%test . equal ( s ( " baz " ) , undefined ) ;%NWL%test . end ( ) ;%NWL%5
var s = scale . scaleOrdinal ( ) . domain ( [ " foo " ,  " bar " ] ) . unknown ( undefined ) . range ( [ " red " ,  " blue " ] ) ;%NWL%test . equal ( s ( " baz " ) , undefined ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ " foo " ,  " bar " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " ordinal . copy ( ) copies all fields " , function ( test )  {%NWL%var s1 = scale . scaleOrdinal ( ) . domain ( [ 1 , 2 ] ) . range ( [ " red " ,  " green " ] ) . unknown ( " gray " ) ,%NWL%s2 = s1 . copy ( ) ;%NWL%test . deepEqual ( s2 . domain ( ) , s1 . domain ( ) ) ;%NWL%test . deepEqual ( s2 . range ( ) , s1 . range ( ) ) ;%NWL%test . end ( ) ;%NWL%3
test . equal ( s . bandwidth ( ) , 0 ) ;%NWL%test . equal ( s . step ( ) , 1 ) ;%NWL%test . equal ( s . round ( ) , false ) ;%NWL%test . equal ( s . padding ( ) , 0 ) ;%NWL%test . equal ( s . align ( ) , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scalePoint ( ) does not expose paddingInner and paddingOuter " , function ( test )  {%NWL%var s = scale . scalePoint ( ) ;%NWL%test . equal ( s . paddingInner , undefined ) ;%NWL%test . end ( ) ;%NWL%5
var s = scale . scalePoint ( ) ;%NWL%test . equal ( s . paddingInner , undefined ) ;%NWL%test . equal ( s . paddingOuter , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scalePoint ( ) is similar to scaleBand ( ) . paddingInner ( 1 ) " , function ( test )  {%NWL%var p = scale . scalePoint ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) ,%NWL%b = scale . scaleBand ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) . paddingInner ( 1 ) ;%NWL%test . deepEqual ( p . domain ( ) . map ( p ) , b . domain ( ) . map ( b ) ) ;%NWL%test . equal ( p . bandwidth ( ) , b . bandwidth ( ) ) ;%NWL%test . end ( ) ;%NWL%3
tape ( " scalePoint ( ) is similar to scaleBand ( ) . paddingInner ( 1 ) " , function ( test )  {%NWL%var p = scale . scalePoint ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) ,%NWL%b = scale . scaleBand ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) . paddingInner ( 1 ) ;%NWL%test . deepEqual ( p . domain ( ) . map ( p ) , b . domain ( ) . map ( b ) ) ;%NWL%test . equal ( p . bandwidth ( ) , b . bandwidth ( ) ) ;%NWL%test . equal ( p . step ( ) , b . step ( ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " point . padding ( p ) sets the band outer padding to p " , function ( test )  {%NWL%var p = scale . scalePoint ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) . padding ( 0 . 5 ) ,%NWL%test . deepEqual ( p . domain ( ) . map ( p ) , b . domain ( ) . map ( b ) ) ;%NWL%3
var p = scale . scalePoint ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) ,%NWL%b = scale . scaleBand ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) . paddingInner ( 1 ) ;%NWL%test . deepEqual ( p . domain ( ) . map ( p ) , b . domain ( ) . map ( b ) ) ;%NWL%test . equal ( p . bandwidth ( ) , b . bandwidth ( ) ) ;%NWL%test . equal ( p . step ( ) , b . step ( ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " point . padding ( p ) sets the band outer padding to p " , function ( test )  {%NWL%var p = scale . scalePoint ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) . padding ( 0 . 5 ) ,%NWL%b = scale . scaleBand ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) . paddingInner ( 1 ) . paddingOuter ( 0 . 5 ) ;%NWL%test . equal ( p . bandwidth ( ) , b . bandwidth ( ) ) ;%NWL%3
b = scale . scaleBand ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) . paddingInner ( 1 ) ;%NWL%test . deepEqual ( p . domain ( ) . map ( p ) , b . domain ( ) . map ( b ) ) ;%NWL%test . equal ( p . bandwidth ( ) , b . bandwidth ( ) ) ;%NWL%test . equal ( p . step ( ) , b . step ( ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " point . padding ( p ) sets the band outer padding to p " , function ( test )  {%NWL%var p = scale . scalePoint ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) . padding ( 0 . 5 ) ,%NWL%b = scale . scaleBand ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) . paddingInner ( 1 ) . paddingOuter ( 0 . 5 ) ;%NWL%test . deepEqual ( p . domain ( ) . map ( p ) , b . domain ( ) . map ( b ) ) ;%NWL%test . equal ( p . step ( ) , b . step ( ) ) ;%NWL%3
test . deepEqual ( p . domain ( ) . map ( p ) , b . domain ( ) . map ( b ) ) ;%NWL%test . equal ( p . bandwidth ( ) , b . bandwidth ( ) ) ;%NWL%test . equal ( p . step ( ) , b . step ( ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " point . padding ( p ) sets the band outer padding to p " , function ( test )  {%NWL%var p = scale . scalePoint ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) . padding ( 0 . 5 ) ,%NWL%b = scale . scaleBand ( ) . domain ( [ " foo " ,  " bar " ] ) . range ( [ 0 , 960 ] ) . paddingInner ( 1 ) . paddingOuter ( 0 . 5 ) ;%NWL%test . deepEqual ( p . domain ( ) . map ( p ) , b . domain ( ) . map ( b ) ) ;%NWL%test . equal ( p . bandwidth ( ) , b . bandwidth ( ) ) ;%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " point . copy ( ) returns a copy " , function ( test )  {%NWL%var s = scale . scalePoint ( ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 0 , 1 ] ) ;%NWL%test . equal ( s . bandwidth ( ) , 0 ) ;%NWL%test . equal ( s . step ( ) , 1 ) ;%NWL%test . equal ( s . round ( ) , false ) ;%NWL%test . equal ( s . padding ( ) , 0 ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " scalePow ( ) has the expected defaults " , function ( test )  {%NWL%var s = scale . scalePow ( ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 0 , 1 ] ) ;%NWL%test . equal ( s . clamp ( ) , false ) ;%NWL%test . equal ( s . exponent ( ) , 1 ) ;%NWL%test . deepEqual ( s . interpolate ( ) ( { array: [ " red " ] } ,  { array: [ " blue " ] } ) ( 0 . 5 ) ,  { array: [ " rgb ( 128 , 0 , 128 ) " ] } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow ( x ) maps a domain value x to a range value y " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . equal ( s . exponent ( ) , 1 ) ;%NWL%test . deepEqual ( s . interpolate ( ) ( { array: [ " red " ] } ,  { array: [ " blue " ] } ) ( 0 . 5 ) ,  { array: [ " rgb ( 128 , 0 , 128 ) " ] } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow ( x ) maps a domain value x to a range value y " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . exponent ( 0 . 5 ) ( 0 . 5 ) , Math . SQRT1_2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow ( x ) ignores extra range values if the domain is smaller than the range " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . domain ( [ - 10 , 0 ] ) . range ( [ " red " ,  " white " ,  " green " ] ) . clamp ( true ) ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( scale . scalePow ( ) . exponent ( 0 . 5 ) ( 0 . 5 ) , Math . SQRT1_2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow ( x ) ignores extra range values if the domain is smaller than the range " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . domain ( [ - 10 , 0 ] ) . range ( [ " red " ,  " white " ,  " green " ] ) . clamp ( true ) ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . equal ( scale . scalePow ( ) . domain ( [ - 10 , 0 ] ) . range ( [ " red " ,  " white " ,  " green " ] ) . clamp ( true ) ( 50 ) ,  " rgb ( 255 , 255 , 255 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow ( x ) ignores extra domain values if the range is smaller than the domain " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . domain ( [ - 10 , 0 , 100 ] ) . range ( [ " red " ,  " white " ] ) . clamp ( true ) ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( scale . scalePow ( ) . domain ( [ - 10 , 0 ] ) . range ( [ " red " ,  " white " ,  " green " ] ) . clamp ( true ) ( 50 ) ,  " rgb ( 255 , 255 , 255 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow ( x ) ignores extra domain values if the range is smaller than the domain " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . domain ( [ - 10 , 0 , 100 ] ) . range ( [ " red " ,  " white " ] ) . clamp ( true ) ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . equal ( scale . scalePow ( ) . domain ( [ - 10 , 0 , 100 ] ) . range ( [ " red " ,  " white " ] ) . clamp ( true ) ( 50 ) ,  " rgb ( 255 , 255 , 255 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow ( x ) maps an empty domain to the range start " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . domain ( [ 0 , 0 ] ) . range ( [ 1 , 2 ] ) ( 0 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
var s = scale . scalePow ( ) . domain ( [ - 10 , 0 , 100 ] ) . range ( [ " red " ,  " white " ,  " green " ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%test . equal ( s ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . equal ( s ( 50 ) ,  " rgb ( 128 , 192 , 128 ) " ) ;%NWL%test . equal ( s ( 75 ) ,  " rgb ( 64 , 160 , 64 ) " ) ;%NWL%s . domain ( [ 4 , 2 , 1 ] ) . range ( [ 1 , 2 , 4 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%6
test . deepEqual ( s . domain ( ) ,  [ - 10 , 0 , 100 ] ) ;%NWL%test . equal ( s ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . equal ( s ( 50 ) ,  " rgb ( 128 , 192 , 128 ) " ) ;%NWL%test . equal ( s ( 75 ) ,  " rgb ( 64 , 160 , 64 ) " ) ;%NWL%s . domain ( [ 4 , 2 , 1 ] ) . range ( [ 1 , 2 , 4 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%s . domain ( [ 1 , 2 , 4 ] ) . range ( [ 4 , 2 , 1 ] ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%6
test . equal ( s ( - 5 ) ,  " rgb ( 255 , 128 , 128 ) " ) ;%NWL%test . equal ( s ( 50 ) ,  " rgb ( 128 , 192 , 128 ) " ) ;%NWL%test . equal ( s ( 75 ) ,  " rgb ( 64 , 160 , 64 ) " ) ;%NWL%s . domain ( [ 4 , 2 , 1 ] ) . range ( [ 1 , 2 , 4 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%s . domain ( [ 1 , 2 , 4 ] ) . range ( [ 4 , 2 , 1 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%6
test . equal ( s ( 50 ) ,  " rgb ( 128 , 192 , 128 ) " ) ;%NWL%test . equal ( s ( 75 ) ,  " rgb ( 64 , 160 , 64 ) " ) ;%NWL%s . domain ( [ 4 , 2 , 1 ] ) . range ( [ 1 , 2 , 4 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%s . domain ( [ 1 , 2 , 4 ] ) . range ( [ 4 , 2 , 1 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%6
test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%s . domain ( [ 1 , 2 , 4 ] ) . range ( [ 4 , 2 , 1 ] ) ;%NWL%test . equal ( s ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s ( 3 ) , 1 . 5 ) ;%NWL%test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . invert ( y ) maps a range value y to a domain value x " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . equal ( s . invert ( 1 . 5 ) , 3 ) ;%NWL%test . equal ( s . invert ( 3 ) , 1 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . invert ( y ) maps a range value y to a domain value x " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . range ( [ 1 , 2 ] ) . invert ( 1 . 5 ) , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . invert ( y ) maps an empty range to the domain start " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . domain ( [ 1 , 2 ] ) . range ( [ 0 , 0 ] ) . invert ( 0 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( scale . scalePow ( ) . range ( [ 1 , 2 ] ) . invert ( 1 . 5 ) , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . invert ( y ) maps an empty range to the domain start " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . domain ( [ 1 , 2 ] ) . range ( [ 0 , 0 ] ) . invert ( 0 ) , 1 ) ;%NWL%test . equal ( scale . scalePow ( ) . domain ( [ 2 , 1 ] ) . range ( [ 0 , 0 ] ) . invert ( 1 ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . invert ( y ) coerces range values to numbers " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . range ( [ " 0 " ,  " 2 " ] ) . invert ( " 1 " ) , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( scale . scalePow ( ) . domain ( [ 2 , 1 ] ) . range ( [ 0 , 0 ] ) . invert ( 1 ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . invert ( y ) coerces range values to numbers " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . range ( [ " 0 " ,  " 2 " ] ) . invert ( " 1 " ) , 0 . 5 ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) . invert ( new Date ( 1990 , 6 , 2 , 13 ) ) , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . invert ( y ) returns NaN if the range is not coercible to number " , function ( test )  {%NWL%test . ok ( isNaN ( scale . scalePow ( ) . range ( [ " #000 " ,  " #fff " ] ) . invert ( " #999 " ) ) ) ;%NWL%test . end ( ) ;%NWL%1
test . ok ( isNaN ( scale . scalePow ( ) . range ( [ " #000 " ,  " #fff " ] ) . invert ( " #999 " ) ) ) ;%NWL%test . ok ( isNaN ( scale . scalePow ( ) . range ( [ 0 ,  " #fff " ] ) . invert ( " #999 " ) ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . exponent ( exponent ) sets the exponent to the specified value " , function ( test )  {%NWL%var x = scale . scalePow ( ) . exponent ( 0 . 5 ) . domain ( [ 1 , 2 ] ) ;%NWL%test . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 1 . 5 ) , 0 . 5425821 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%test . equal ( x . exponent ( ) , 0 . 5 ) ;%NWL%test . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . exponent ( exponent ) sets the exponent to the specified value " , function ( test )  {%NWL%var x = scale . scalePow ( ) . exponent ( 0 . 5 ) . domain ( [ 1 , 2 ] ) ;%NWL%test . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 1 . 5 ) , 0 . 5425821 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%test . equal ( x . exponent ( ) , 0 . 5 ) ;%NWL%x . exponent ( 2 ) . domain ( [ 1 , 2 ] ) ;%NWL%test . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%6
var x = scale . scalePow ( ) . exponent ( 0 . 5 ) . domain ( [ 1 , 2 ] ) ;%NWL%test . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 1 . 5 ) , 0 . 5425821 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%test . equal ( x . exponent ( ) , 0 . 5 ) ;%NWL%x . exponent ( 2 ) . domain ( [ 1 , 2 ] ) ;%NWL%test . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 1 . 5 ) , 0 . 41666667 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%test . equal ( x . exponent ( ) , 2 ) ;%NWL%test . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%1
test . inDelta ( x ( 1 . 5 ) , 0 . 5425821 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%test . equal ( x . exponent ( ) , 0 . 5 ) ;%NWL%x . exponent ( 2 ) . domain ( [ 1 , 2 ] ) ;%NWL%test . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 1 . 5 ) , 0 . 41666667 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%test . equal ( x . exponent ( ) , 2 ) ;%NWL%x . exponent ( - 1 ) . domain ( [ 1 , 2 ] ) ;%NWL%test . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%1
test . inDelta ( x ( 1 . 5 ) , 0 . 6666667 , 1e - 6 ) ;%NWL%test . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%test . equal ( x . exponent ( ) ,  - 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . exponent ( exponent ) changing the exponent does not change the domain or range " , function ( test )  {%NWL%var x = scale . scalePow ( ) . domain ( [ 1 , 2 ] ) . range ( [ 3 , 4 ] ) ;%NWL%x . exponent ( 0 . 5 ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%8
test . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%test . equal ( x . exponent ( ) ,  - 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . exponent ( exponent ) changing the exponent does not change the domain or range " , function ( test )  {%NWL%var x = scale . scalePow ( ) . domain ( [ 1 , 2 ] ) . range ( [ 3 , 4 ] ) ;%NWL%x . exponent ( 0 . 5 ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%x . exponent ( 2 ) ;%NWL%test . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%8
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . exponent ( exponent ) changing the exponent does not change the domain or range " , function ( test )  {%NWL%var x = scale . scalePow ( ) . domain ( [ 1 , 2 ] ) . range ( [ 3 , 4 ] ) ;%NWL%x . exponent ( 0 . 5 ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%x . exponent ( 2 ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%5
} ) ;%NWL%tape ( " pow . exponent ( exponent ) changing the exponent does not change the domain or range " , function ( test )  {%NWL%var x = scale . scalePow ( ) . domain ( [ 1 , 2 ] ) . range ( [ 3 , 4 ] ) ;%NWL%x . exponent ( 0 . 5 ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%x . exponent ( 2 ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%x . exponent ( - 1 ) ;%NWL%test . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%5
test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%x . exponent ( - 1 ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . domain ( domain ) accepts an array of numbers " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ ] ) . domain ( ) ,  [ ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 1 , 0 ] ) . domain ( ) ,  [ 1 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " pow . domain ( domain ) accepts an array of numbers " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ ] ) . domain ( ) ,  [ ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 1 , 0 ] ) . domain ( ) ,  [ 1 , 0 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 1 , 2 , 3 ] ) . domain ( ) ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . domain ( domain ) coerces domain values to numbers " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) . domain ( ) ,  [ 631180800000 , 662716800000 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ " 0 . 0 " ,  " 1 . 0 " ] ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " pow . domain ( domain ) coerces domain values to numbers " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) . domain ( ) ,  [ 631180800000 , 662716800000 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ " 0 . 0 " ,  " 1 . 0 " ] ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ new Number ( 0 ) , new Number ( 1 ) ] ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . domain ( domain ) makes a copy of domain values " , function ( test )  {%NWL%var d = [ 1 , 2 ] , s = scale . scalePow ( ) . domain ( d ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%9
test . deepEqual ( scale . scalePow ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) . domain ( ) ,  [ 631180800000 , 662716800000 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ " 0 . 0 " ,  " 1 . 0 " ] ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ new Number ( 0 ) , new Number ( 1 ) ] ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . domain ( domain ) makes a copy of domain values " , function ( test )  {%NWL%var d = [ 1 , 2 ] , s = scale . scalePow ( ) . domain ( d ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . domain ( domain ) makes a copy of domain values " , function ( test )  {%NWL%var d = [ 1 , 2 ] , s = scale . scalePow ( ) . domain ( d ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( d ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var s = scale . scalePow ( ) , d = s . domain ( ) ;%NWL%3
tape ( " pow . domain ( domain ) makes a copy of domain values " , function ( test )  {%NWL%var d = [ 1 , 2 ] , s = scale . scalePow ( ) . domain ( d ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( d ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . domain ( ) returns a copy of domain values " , function ( test )  {%NWL%var s = scale . scalePow ( ) , d = s . domain ( ) ;%NWL%d . push ( 3 ) ;%NWL%3
test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( d ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . domain ( ) returns a copy of domain values " , function ( test )  {%NWL%var s = scale . scalePow ( ) , d = s . domain ( ) ;%NWL%test . deepEqual ( d ,  [ 0 , 1 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . end ( ) ;%NWL%4